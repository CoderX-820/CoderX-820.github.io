<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>BP神经网络模型</title>
    <link href="/2022/07/25/BP%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B/"/>
    <url>/2022/07/25/BP%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B/</url>
    
    <content type="html"><![CDATA[<h2 id="BP神经网络"><a href="#BP神经网络" class="headerlink" title="BP神经网络"></a>BP神经网络</h2><h3 id="1-概念"><a href="#1-概念" class="headerlink" title="1.概念"></a>1.概念</h3><p>首先从名称中可以看出，Bp神经网络可以分为两个部分，bp和神经网络。bp是 Back Propagation 的简写 ，意思是反向传播。</p><p>BP网络能学习和存贮大量的输入-输出模式映射关系，而无需事前揭示描述这种映射关系的数学方程。它的学习规则是使用最速下降法，通过反向传播来不断调整网络的权值和阈值，使网络的误差平方和最小。</p><p>其主要的特点是：信号是正向传播的，而误差是反向传播的。</p><p>举一个例子，某厂商生产一种产品，投放到市场之后得到了消费者的反馈，根据消费者的反馈，厂商对产品进一步升级，优化，一直循环往复，直到实现最终目的——生产出让消费者更满意的产品。产品投放就是“信号前向传播”，消费者的反馈就是“误差反向传播”。这就是BP神经网络的核心。</p><h3 id="2-算法流程图"><a href="#2-算法流程图" class="headerlink" title="2.算法流程图"></a>2.算法流程图</h3><p><img src="https://pic3.zhimg.com/v2-b84fee51daf26d27bd90420311d410a2_r.jpg" alt="img"></p><h3 id="3-神经元模型"><a href="#3-神经元模型" class="headerlink" title="3.神经元模型"></a>3.神经元模型</h3><p><img src="https://pic1.zhimg.com/v2-9fb5f7731adbdc44a61b30d60aa63100_r.jpg" alt="img"></p><p>每个神经元都接受来自其它神经元的输入信号，每个信号都通过一个带有权重的连接传递，神经元把这些信号加起来得到一个总输入值，然后将总输入值与神经元的阈值进行对比（模拟阈值电位），然后通过一个“<strong>激活函数</strong>”处理得到最终的输出（模拟细胞的激活），这个输出又会作为之后神经元的输入一层一层传递下去。</p><h3 id="4-激活函数："><a href="#4-激活函数：" class="headerlink" title="4.激活函数：(  )"></a>4.激活函数：( <img src="https://www.zhihu.com/equation?tex=%5Ctheta" alt="[公式]"> )</h3><p>引入激活函数的<strong>目的</strong>是在模型中引入非线性。如果没有激活函数（其实相当于激励函数是f(x) &#x3D; x），那么无论你的神经网络有多少层，最终都是一个线性映射，那么网络的逼近能力就相当有限，单纯的线性映射无法解决线性不可分问题。正因为上面的原因，我们决定引入非线性函数作为激励函数，这样深层神经网络表达能力就更加强大</p><p><strong>BP神经网络算法常用的激活函数：</strong></p><p><strong>1）Sigmoid（logistic）</strong>，也称为S型生长曲线，函数在用于分类器时，效果更好。</p><p><img src="https://pic4.zhimg.com/v2-285cbc88c0d18649c75a4d70b50e2e4b_r.jpg" alt="img"></p><p><img src="https://pic2.zhimg.com/v2-1d2e38a94a3cb2f9313ac4e2c782bd49_r.jpg" alt="img"></p><p><strong>2）Tanh函数（双曲正切函数）</strong>，解决了logistic中心不为0的缺点，但依旧有梯度易消失的缺点。</p><p><img src="https://pic1.zhimg.com/v2-6ab5548aabae1732b523db7f3085b6ac_r.jpg" alt="img"></p><p><img src="https://pic1.zhimg.com/v2-ffbfe17326bba2f1a277eb8be100b618_r.jpg" alt="img"></p><p><strong>3）relu函数</strong>是一个通用的激活函数，针对Sigmoid函数和tanh的缺点进行改进的，<strong>目前在大多数情况下使用</strong>。</p><p><img src="https://pic3.zhimg.com/80/v2-d4c19177bc09677dfc976a1013f76512_720w.jpg" alt="img"></p><p><img src="https://pic3.zhimg.com/80/v2-90320e14754d5151b7aa2a410207c1b6_720w.jpg" alt="img"></p><h3 id="5-神经网络基础架构"><a href="#5-神经网络基础架构" class="headerlink" title="5.神经网络基础架构"></a>5.神经网络基础架构</h3><p>BP网络由输入层、隐藏层、输出层组成。</p><p><img src="https://pic2.zhimg.com/v2-41046ca9f67987c2b1b2ff730a3c9925_r.jpg" alt="img"></p><p>输入层：信息的输入端，是读入你输入的数据的</p><p>隐藏层：信息的处理端，可以设置这个隐藏层的层数（在这里一层隐藏层，q个神经元）</p><p>输出层：信息的输出端，也就是我们要的结果</p><p>v，w分别的输入层到隐藏层，隐藏层到输出层的是权重</p><p>对于上图的只含一个隐层的神经网络模型：BP神经网络的过程主要分为两个阶段，第一阶段是信号的正向传播，从输入层经过隐含层，最后到达输出层；第二阶段是误差的反向传播，从输出层到隐含层，最后到输入层，依次调节隐含层到输出层的权重和偏置，输入层到隐含层的权重和偏置。</p><h3 id="6-BP神经网络参数"><a href="#6-BP神经网络参数" class="headerlink" title="6.BP神经网络参数"></a>6.BP神经网络参数</h3><p>在进行BP神经网络的设计时,应从网络的层数、每层中的神经元数、初始值以及学习速率等几个方面进行考虑。</p><p>（1）网络的层数。已经证明:三层BP神经网络可以实现多维单位立方体 到 的映射，即能够逼近任何有理函数。这实际上给了一个设计BP神经网络的基本原则。增加层数可以更进一步地降低误差,提高精度，但同时也使网络复杂化，从而增加网络权值的训练时间。而误差精度的提高实际上也可以通过增加隐含层中的神经元数目来获得,其训练结果也比增加层数更容易观察和调整。所以一般情况下，应优先考虑增加隐含层中的神经元数。</p><p>（2）隐含层的神经元数。网络训练精度的提高,可以通过采用一个隐含层而增加神经元数的方法来获得。这在结构的实现上要比增加更多的隐含层简单得多。在具体设计时,比较实际的做法是隐含层取输人层的两倍，然后适当地加上一点余量。评价一个网络设计得好坏，首先是它的精度,其次是训练时间。时间包含有两层: 一层是循环次数,二是每一次循环中计算所花的时间。</p><p>（3）初始权值的选取。由于系统是非线性的，初始值的选取对于学习是否达到局部最小、是否能够收敛以及训练时间的长短有很大关系。初始值过大过小都会影响学习速度,因此权值的初始值应选为均匀分布的小数经验值，一般取初始权值在(-1,1)之间的随机数,也可选取在[-2.4&#x2F;n,2.4&#x2F;n] 之间的随机数,其中n为输人特征个数。为避免每步权值的调整方向是同向的，应将初始值设为随机数。</p><p>（4）学习速率。学习速率决定每次循环训练中 所产生的权值变化量。高的学习速率可能导致系统的不稳定;但低的学习速率导致较长的训练时间，可能收敛很慢，不过能保证网络的误差值跳出误差表面的低谷而最终趋于最小误差值。在一般情况下，倾向于选取较小的学习速率以保证系统的稳定性。学习速率的选取0.01 ~0. 8。</p><p>（5）期望误差的选取。在网络的训练过程中期望误差值也应当通过对比训练后确定一个合适的值。所谓的“合适”,是相对于所需要的隐含层的结点数来确定的，因为较小的期望误差要靠增加隐含层的结点,以及训练时间来获得。一般情况下，作为对比，可以同时对两个不同期望误差的网络进行训练,最后通过综合因素的考虑来确定采用其中</p><h3 id="7-正向传播过程"><a href="#7-正向传播过程" class="headerlink" title="7.正向传播过程"></a>7.正向传播过程</h3><p>正向传播就是让信息从输入层进入网络，依次经过每一层的计算，得到最终输出层结果的过程。在上面的网络中，我们的计算过程比较直接，用每一层的数值乘以对应的权重+偏置变量（激活函数）</p><p>从输入层到隐藏层： <img src="https://www.zhihu.com/equation?tex=%5Calpha_%7Bh%7D=%5Csum_%7Bi=1%7D%5E%7Bd%7D%7Bv_%7Bih%7Dx_%7Bi%7D%7D+%5Ctheta_%7Bh%7D" alt="[公式]"></p><p>从隐藏层到输出层： <img src="https://www.zhihu.com/equation?tex=%5Cbeta_%7Bj%7D=%5Csum_%7Bh=1%7D%5E%7Bq%7D%7Bw_%7Bhj%7Db_%7Bh%7D%7D+%5Ctheta_%7Bj%7D" alt="[公式]"></p><p>以y1举例。y1里的输出自然有来自b1,b2,…bq的。那么分别按照权重去乘就可以了。</p><p><img src="https://www.zhihu.com/equation?tex=y_%7B1%7D=b_%7B1%7D*w_%7B11%7D+b_%7B2%7D*w_%7B21%7D+...+b_%7Bq%7D*w_%7Bq1%7D+%5Ctheta+" alt="[公式]"></p><p>类似的我们可以求解出y2——y1</p><p>因为参数是随机的，所以第一次计算出的结果跟真实的结果会有一个非常大的误差，所以我们需要根据误差去调整参数，让参数可以更好的去拟合，直到误差达到最小值，这时就需要模型的反向传播</p><h3 id="8-反向传播过程"><a href="#8-反向传播过程" class="headerlink" title="8.反向传播过程"></a>8.反向传播过程</h3><p>基本思想就是通过计算输出层与期望值之间的误差来调整网络参数，从而使得误差变小。</p><p>计算误差公式如下：(差值的平方)</p><p><img src="https://www.zhihu.com/equation?tex=E=%5Cfrac%7B1%7D%7B2%7D%5Csum_%7Bk=1%7D%5E%7B2%7D%7B(y_%7Bk%7D-T_%7Bk%7D)%5E%7B2%7D%7D" alt="[公式]"></p><p>如何调整权重的大小，才能使损失函数不断地变小呢？这里给大家介绍几种常用的方法：</p><ul><li>梯度下降法：从几何意义讲，梯度矩阵代表了函数增加最快的方向，因此，沿着与之相反的方向就可以更快找到最小值</li><li>sgd：在梯度下降法基础上，sgd对单个训练样本进行参数更新，加快收敛速率。</li><li>adam:在梯度下降法基础上,通过计算梯度的一阶矩估计和二阶矩估计而为不同的参数设计独立的自适应性学习率，加快收敛速率</li><li>lbfgs：sgd，Adam等都是在一阶法(梯度下降法)的基础上进行改进，加快收敛速率。而lbfgs在二阶泰勒展开式进行局部近似平均损失的基础上进行改进的，以降低了迭代过程中的存储量，加快收敛速率。</li></ul><p><strong>权重反向更新：</strong></p><p><img src="https://www.zhihu.com/equation?tex=%5CDelta+w_%7Bij%7D=(l)Ey_%7Bk%7D" alt="[公式]"></p><p><img src="https://www.zhihu.com/equation?tex=w_%7Bij%7D=%5CDelta+w_%7Bij%7D+w_%7Bij%7D" alt="[公式]"></p><p><img src="https://www.zhihu.com/equation?tex=l" alt="[公式]"> 称为学习率，可以调整更新的步伐，合适的学习率能够使目标函数在合适的时间内收敛到局部最小值。</p><p>学习率设置太小，结果收敛非常缓慢；学习率设置太大，结果在最优值附近徘徊，难以收敛，一般选取为0.01−0.8</p><p>至此，我们完成了一次神经网络的训练过程，通过不断的使用所有数据记录进行训练，从而得到一个分类模型。不断地迭代，不可能无休止的下去，总归有个终止条件。</p><ul><li>设置最大迭代次数，比如使用数据集迭代100次后停止训练</li><li>计算训练集在网络上的预测准确率，达到一定门限值后停止训练</li></ul>]]></content>
    
    
    <categories>
      
      <category>数学建模</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数学建模</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ARIMA模型</title>
    <link href="/2022/07/25/ARIMA%E6%A8%A1%E5%9E%8B/"/>
    <url>/2022/07/25/ARIMA%E6%A8%A1%E5%9E%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="ARIMA预测模型"><a href="#ARIMA预测模型" class="headerlink" title="ARIMA预测模型"></a>ARIMA预测模型</h1><h3 id="1-简介"><a href="#1-简介" class="headerlink" title="1.简介"></a>1.简介</h3><p>​      ARIMA模型全称为自回归移动平均模型(Autoregressive Integrated Moving Average Model,简记ARIMA)，是由博克思(Box)和詹金斯(Jenkins)于70年代初提出的一著名时间序列预测方法，所以又称为box-jenkins模型、博克思-詹金斯法。其中ARIMA（p，d，q）称为差分自回归移动平均模型，AR是自回归, p为自回归项; MA为移动平均，q为移动平均项数，d为时间序列成为平稳时所做的差分次数。</p><h3 id="2-基本思想"><a href="#2-基本思想" class="headerlink" title="2.基本思想"></a>2.基本思想</h3><p>　 ARIMA模型的基本思想是：将预测对象随时间推移而形成的数据序列视为一个随机序列，用一定的数学模型来近似描述这个序列。这个模型一旦被识别后就可以从时间序列的过去值及现在值来预测未来值。现代统计方法、计量经济模型在某种程度上已经能够帮助企业对未来进行预测。</p><p>ARIMA(p，d，q)模型可以表示为：</p><p><img src="https://pic2.zhimg.com/80/v2-ea33bb159d8fe9ccea6db91abca5bcfd_720w.jpg" alt="img"></p><p>其中L是滞后算子（Lag operator），</p><p><img src="https://pic3.zhimg.com/80/v2-02a2e7f662589f35bea3020d36f107a2_720w.jpg" alt="img"></p><p>ARIMA模型含有三个参数：p,d,q。</p><p>p–代表预测模型中采用的时序数据本身的滞后数(lags) ,也叫做AR&#x2F;Auto-Regressive项</p><p>d–代表时序数据需要进行几阶差分化，才是稳定的，也叫Integrated项。</p><p>q–代表预测模型中采用的预测误差的滞后数(lags)，也叫做MA&#x2F;Moving Average项</p><p><strong>2.1参数d的确认</strong></p><p>d就是差分的阶数，首先通过ADF检验，看原时间序列的平稳性，如果原时间序列是平稳的，那么d&#x3D;0；</p><p>如果原数据不平稳，那么做差分，通过ADF检验直到时间序列平稳。一般差分次数不超过2次。</p><p><strong>2.2参数p、q的确认</strong></p><p>通常在时间序列分析中，采用自相关函数（ACF）、偏自相关函数（PACF）来判别ARMA(p,q)模型的系数和阶数。自相关函数(ACF)描述时间序列观测值与其过去的观测值之间的线性相关性。偏自相关函数(PACF)描述在</p><p>给定中间观测值的条件下时间序列观测值与其过去的观测值之间的线性相关性。</p><h3 id="3-ARIMA模型介绍"><a href="#3-ARIMA模型介绍" class="headerlink" title="3.ARIMA模型介绍"></a>3.ARIMA模型介绍</h3><h4 id="3-1自回归模型AR"><a href="#3-1自回归模型AR" class="headerlink" title="3.1自回归模型AR"></a>3.1自回归模型AR</h4><p>自回归模型描述当前值与历史值之间的关系，用变量自身的历史时间数据对自身进行预测。自回归模型必须满足平稳性的要求。</p><p>自回归模型首先需要确定一个阶数p，表示用几期的历史值来预测当前值。p阶自回归模型的公式定义为：</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy80MTU1OTg2LWUzYjIzYjEwMGRiZTgxZjMucG5n?x-oss-process=image/format,png" alt="img"></p><p>上式中yt是当前值,u是常数项,p是阶数 ri是自相关系数,et是误差。</p><p>自回归模型有很多的限制：<br>1、自回归模型是用自身的数据进行预测<br>2、时间序列数据必须具有平稳性<br>3、自回归只适用于预测与自身前期相关的现象</p><h4 id="3-2移动平均模型MA"><a href="#3-2移动平均模型MA" class="headerlink" title="3.2移动平均模型MA"></a>3.2移动平均模型MA</h4><p>移动平均模型关注的是自回归模型中的误差项的累加 ，q阶自回归过程的公式定义如下：</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy80MTU1OTg2LWEzMzI4NGQ1ZDc5MWEwZDgucG5n?x-oss-process=image/format,png" alt="img"></p><p>移动平均法能有效地消除预测中的随机波动。</p><h4 id="3-3自回归移动平均模型ARMA"><a href="#3-3自回归移动平均模型ARMA" class="headerlink" title="3.3自回归移动平均模型ARMA"></a>3.3自回归移动平均模型ARMA</h4><p>自回归模型AR和移动平均模型MA模型相结合，我们就得到了自回归移动平均模型ARMA(p,q)，计算公式如下：</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy80MTU1OTg2LWY0NGJjMjgxYmQ1YTkzMjMucG5n?x-oss-process=image/format,png" alt="img"></p><h4 id="3-4差分自回归移动平均模型ARIMA"><a href="#3-4差分自回归移动平均模型ARIMA" class="headerlink" title="3.4差分自回归移动平均模型ARIMA"></a>3.4差分自回归移动平均模型ARIMA</h4><p>将自回归模型、移动平均模型和差分法结合，我们就得到了差分自回归移动平均模型ARIMA(p,d,q)，其中d是需要对数据进行差分的阶数。</p><h3 id="4-建立ARIMA模型的过程"><a href="#4-建立ARIMA模型的过程" class="headerlink" title="4.建立ARIMA模型的过程"></a>4.建立ARIMA模型的过程</h3><p>一般来说，建立ARIMA模型一般有三个阶段，分别是模型识别和定阶、参数估计和模型检验，接下来，我们一步步来介绍：</p><h4 id="4-1-模型识别和定阶"><a href="#4-1-模型识别和定阶" class="headerlink" title="4.1 模型识别和定阶"></a>4.1 模型识别和定阶</h4><p>模型的识别问题和定阶问题，主要是确定p，d，q三个参数，差分的阶数d一般通过观察图示，1阶或2阶即可。这里我们主要介绍p和q的确定。我们首先介绍两个函数。</p><p><strong>自相关函数ACF(autocorrelation function)</strong><br>自相关函数ACF描述的是时间序列观测值与其过去的观测值之间的线性相关性。计算公式如下：</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy80MTU1OTg2LWZmZmQ5MmEzMGQwNjg5MzEucG5n?x-oss-process=image/format,png" alt="img"></p><p>其中k代表滞后期数，如果k&#x3D;2，则代表yt和yt-2</p><p><strong>偏自相关函数PACF(partial autocorrelation function)</strong><br>偏自相关函数PACF描述的是在给定中间观测值的条件下，时间序列观测值预期过去的观测值之间的线性相关性。</p><p>举个简单的例子，假设k&#x3D;3，那么我们描述的是yt和yt-3之间的相关性，但是这个相关性还受到yt-1和yt-2的影响。PACF剔除了这个影响，而ACF包含这个影响。</p><p><strong>拖尾和截尾</strong><br>拖尾指序列以指数率单调递减或震荡衰减，而截尾指序列从某个时点变得非常小：</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy80MTU1OTg2LTRhZjYwZGVkZjlmODZlMGYucG5n?x-oss-process=image/format,png" alt="img"></p><p>出现以下情况，通常视为(偏)自相关系数d阶截尾：<br>1）在最初的d阶明显大于2倍标准差范围<br>2）之后几乎95%的(偏)自相关系数都落在2倍标准差范围以内<br>3）且由非零自相关系数衰减为在零附近小值波动的过程非常突然</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy80MTU1OTg2LWIyYzdkYzk0Zjc4MTE3NjMucG5n?x-oss-process=image/format,png" alt="img"></p><p>出现以下情况，通常视为(偏)自相关系数拖尾：<br>1）如果有超过5%的样本(偏)自相关系数都落入2倍标准差范围之外<br>2）或者是由显著非0的(偏)自相关系数衰减为小值波动的过程比较缓慢或非常连续。</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy80MTU1OTg2LWMwZTRmZTFkMmVjY2E3MGIucG5n?x-oss-process=image/format,png" alt="img"></p><p><strong>p，q阶数的确定</strong><br>根据刚才判定截尾和拖尾的准则，p，q的确定基于如下的规则：</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy80MTU1OTg2LTg2YTMyOWE0NDVmOGVhYjcucG5n?x-oss-process=image/format,png" alt="img"></p><p>根据不同的截尾和拖尾的情况，我们可以选择AR模型，也可以选择MA模型，当然也可以选择ARIMA模型。接下来，我们就来画一下我们数据的拖尾和截尾情况:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> statsmodels.<span class="hljs-property">api</span> <span class="hljs-keyword">as</span> sm<br>fig = plt.<span class="hljs-title function_">figure</span>(figsize=(<span class="hljs-number">12</span>,<span class="hljs-number">8</span>))<br> <br>ax1 = fig.<span class="hljs-title function_">add_subplot</span>(<span class="hljs-number">211</span>)<br>fig = sm.<span class="hljs-property">graphics</span>.<span class="hljs-property">tsa</span>.<span class="hljs-title function_">plot_acf</span>(train, lags=<span class="hljs-number">20</span>,ax=ax1)<br>ax1.<span class="hljs-property">xaxis</span>.<span class="hljs-title function_">set_ticks_position</span>(<span class="hljs-string">&#x27;bottom&#x27;</span>)<br>fig.<span class="hljs-title function_">tight_layout</span>()<br> <br>ax2 = fig.<span class="hljs-title function_">add_subplot</span>(<span class="hljs-number">212</span>)<br>fig = sm.<span class="hljs-property">graphics</span>.<span class="hljs-property">tsa</span>.<span class="hljs-title function_">plot_pacf</span>(train, lags=<span class="hljs-number">20</span>, ax=ax2)<br>ax2.<span class="hljs-property">xaxis</span>.<span class="hljs-title function_">set_ticks_position</span>(<span class="hljs-string">&#x27;bottom&#x27;</span>)<br>fig.<span class="hljs-title function_">tight_layout</span>()<br>plt.<span class="hljs-title function_">show</span>()<br></code></pre></td></tr></table></figure><p>结果如下：</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy80MTU1OTg2LWM4N2VjZWM4ZjBkZjZiZmEucG5n?x-oss-process=image/format,png" alt="img"></p><p>哈哈，咱们这个数据自相关系数4阶拖尾，偏自相关系数2阶截尾，因此可以选择的是AR(2)模型。</p><h4 id="4-2-参数估计"><a href="#4-2-参数估计" class="headerlink" title="4.2 参数估计"></a>4.2 参数估计</h4><p>通过拖尾和截尾对模型进行定阶的方法，往往具有很强的主观性。回想我们之前在参数预估的时候往往是怎么做的，不就是损失和正则项的加权么？我们这里能不能结合最终的预测误差来确定p，q的阶数呢？在相同的预测误差情况下，根据奥斯卡姆剃刀准则，模型越小是越好的。那么，平衡预测误差和参数个数，我们可以根据信息准则函数法，来确定模型的阶数。预测误差通常用平方误差即残差平方和来表示。</p><p>常用的信息准则函数法有下面几种：<br><strong>AIC准则</strong><br>AIC准则全称为全称是最小化信息量准则（Akaike Information Criterion），计算公式如下：<br>AIC &#x3D; &#x3D;2 *（模型参数的个数）-2ln（模型的极大似然函数）</p><p><strong>BIC准则</strong><br>AIC准则存在一定的不足之处。当样本容量很大时，在AIC准则中拟合误差提供的信息就要受到样本容量的放大，而参数个数的惩罚因子却和样本容量没关系（一直是2），因此当样本容量很大时，使用AIC准则选择的模型不收敛与真实模型，它通常比真实模型所含的未知参数个数要多。BIC（Bayesian InformationCriterion）贝叶斯信息准则弥补了AIC的不足，计算公式如下：</p><p>BIC &#x3D; ln(n) * (模型中参数的个数) - 2ln(模型的极大似然函数值)，n是样本容量</p><p>好了，我们通过类似于网格搜索的方式来寻找我们模型最佳的p，q组合吧，这里我们使用BIC进行试验，AIC同理:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#遍历，寻找适宜的参数</span><br><span class="hljs-keyword">import</span> itertools<br><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><span class="hljs-keyword">import</span> seaborn <span class="hljs-keyword">as</span> sns<br> <br>p_min = <span class="hljs-number">0</span><br>d_min = <span class="hljs-number">0</span><br>q_min = <span class="hljs-number">0</span><br>p_max = <span class="hljs-number">5</span><br>d_max = <span class="hljs-number">0</span><br>q_max = <span class="hljs-number">5</span><br> <br><span class="hljs-comment"># Initialize a DataFrame to store the results,，以BIC准则</span><br>results_bic = pd.DataFrame(index=[<span class="hljs-string">&#x27;AR&#123;&#125;&#x27;</span>.<span class="hljs-built_in">format</span>(i) <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(p_min,p_max+<span class="hljs-number">1</span>)],<br>                           columns=[<span class="hljs-string">&#x27;MA&#123;&#125;&#x27;</span>.<span class="hljs-built_in">format</span>(i) <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(q_min,q_max+<span class="hljs-number">1</span>)])<br> <br><span class="hljs-keyword">for</span> p,d,q <span class="hljs-keyword">in</span> itertools.product(<span class="hljs-built_in">range</span>(p_min,p_max+<span class="hljs-number">1</span>),<br>                               <span class="hljs-built_in">range</span>(d_min,d_max+<span class="hljs-number">1</span>),<br>                               <span class="hljs-built_in">range</span>(q_min,q_max+<span class="hljs-number">1</span>)):<br>    <span class="hljs-keyword">if</span> p==<span class="hljs-number">0</span> <span class="hljs-keyword">and</span> d==<span class="hljs-number">0</span> <span class="hljs-keyword">and</span> q==<span class="hljs-number">0</span>:<br>        results_bic.loc[<span class="hljs-string">&#x27;AR&#123;&#125;&#x27;</span>.<span class="hljs-built_in">format</span>(p), <span class="hljs-string">&#x27;MA&#123;&#125;&#x27;</span>.<span class="hljs-built_in">format</span>(q)] = np.nan<br>        <span class="hljs-keyword">continue</span><br> <br>    <span class="hljs-keyword">try</span>:<br>        model = sm.tsa.ARIMA(train, order=(p, d, q),<br>                               <span class="hljs-comment">#enforce_stationarity=False,</span><br>                               <span class="hljs-comment">#enforce_invertibility=False,</span><br>                              )<br>        results = model.fit()<br>        results_bic.loc[<span class="hljs-string">&#x27;AR&#123;&#125;&#x27;</span>.<span class="hljs-built_in">format</span>(p), <span class="hljs-string">&#x27;MA&#123;&#125;&#x27;</span>.<span class="hljs-built_in">format</span>(q)] = results.bic<br>    <span class="hljs-keyword">except</span>:<br>        <span class="hljs-keyword">continue</span><br>results_bic = results_bic[results_bic.columns].astype(<span class="hljs-built_in">float</span>)<br> <br>fig, ax = plt.subplots(figsize=(<span class="hljs-number">10</span>, <span class="hljs-number">8</span>))<br>ax = sns.heatmap(results_bic,<br>                 mask=results_bic.isnull(),<br>                 ax=ax,<br>                 annot=<span class="hljs-literal">True</span>,<br>                 fmt=<span class="hljs-string">&#x27;.2f&#x27;</span>,<br>                 )<br>ax.set_title(<span class="hljs-string">&#x27;BIC&#x27;</span>)<br>plt.show()<br></code></pre></td></tr></table></figure><p>绘制的热力图如下：</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy80MTU1OTg2LWEyZTZjNjM1ZWRjNTNiMTYucG5n?x-oss-process=image/format,png" alt="img"></p><p>我们上面采用了循环的方式，其实可以用更简单的方法得到p和q的最优值：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">train_results = sm.tsa.arma_order_select_ic(train, ic=[<span class="hljs-string">&#x27;aic&#x27;</span>, <span class="hljs-string">&#x27;bic&#x27;</span>], trend=<span class="hljs-string">&#x27;nc&#x27;</span>, max_ar=<span class="hljs-number">8</span>, max_ma=<span class="hljs-number">8</span>)<br> <br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;AIC&#x27;</span>, train_results.aic_min_order)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;BIC&#x27;</span>, train_results.bic_min_order)<br></code></pre></td></tr></table></figure><p>结果为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs undefined">AIC (1, 0)<br>BIC (1, 0)<br></code></pre></td></tr></table></figure><p>表明我们应该选择AR(1)模型。</p><p>一般来说，BIC准则得到的ARMA模型的阶数较AIC的低。</p><h4 id="4-3-模型检验"><a href="#4-3-模型检验" class="headerlink" title="4.3 模型检验"></a>4.3 模型检验</h4><p>这里的模型检验主要有两个：<br>1）检验参数估计的显著性（t检验）<br>2）检验残差序列的随机性，即残差之间是独立的</p><p>残差序列的随机性可以通过自相关函数法来检验，即做残差的自相关函数图：</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs r">model <span class="hljs-operator">=</span> sm.tsa.ARIMA<span class="hljs-punctuation">(</span>train<span class="hljs-punctuation">,</span> order<span class="hljs-operator">=</span><span class="hljs-punctuation">(</span><span class="hljs-number">1</span><span class="hljs-punctuation">,</span> <span class="hljs-number">0</span><span class="hljs-punctuation">,</span> <span class="hljs-number">0</span><span class="hljs-punctuation">)</span><span class="hljs-punctuation">)</span><br>results <span class="hljs-operator">=</span> model.fit<span class="hljs-punctuation">(</span><span class="hljs-punctuation">)</span><br>resid <span class="hljs-operator">=</span> results.resid <span class="hljs-comment">#赋值</span><br>fig <span class="hljs-operator">=</span> plt.figure<span class="hljs-punctuation">(</span>figsize<span class="hljs-operator">=</span><span class="hljs-punctuation">(</span><span class="hljs-number">12</span><span class="hljs-punctuation">,</span><span class="hljs-number">8</span><span class="hljs-punctuation">)</span><span class="hljs-punctuation">)</span><br>fig <span class="hljs-operator">=</span> sm.graphics.tsa.plot_acf<span class="hljs-punctuation">(</span>resid.values.squeeze<span class="hljs-punctuation">(</span><span class="hljs-punctuation">)</span><span class="hljs-punctuation">,</span> lags<span class="hljs-operator">=</span><span class="hljs-number">40</span><span class="hljs-punctuation">)</span><br>plt.show<span class="hljs-punctuation">(</span><span class="hljs-punctuation">)</span><br></code></pre></td></tr></table></figure><p>结果如下：</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy80MTU1OTg2LTE5YTFjMDZiZTA0Mjc5NmMucG5n?x-oss-process=image/format,png" alt="img"></p><p>这里很明显的检测是通过的。</p><h4 id="4-4-模型预测"><a href="#4-4-模型预测" class="headerlink" title="4.4 模型预测"></a>4.4 模型预测</h4><p>预测主要有两个函数，一个是predict函数，一个是forecast函数，predict中进行预测的时间段必须在我们训练ARIMA模型的数据中，forecast则是对训练数据集末尾下一个时间段的值进行预估。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs sql">model <span class="hljs-operator">=</span> sm.tsa.ARIMA(sub, <span class="hljs-keyword">order</span><span class="hljs-operator">=</span>(<span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>))<br>results <span class="hljs-operator">=</span> model.fit()<br>predict_sunspots <span class="hljs-operator">=</span> results.predict(<span class="hljs-keyword">start</span><span class="hljs-operator">=</span>str(<span class="hljs-string">&#x27;2014-04&#x27;</span>),<span class="hljs-keyword">end</span><span class="hljs-operator">=</span>str(<span class="hljs-string">&#x27;2014-05&#x27;</span>),<span class="hljs-keyword">dynamic</span><span class="hljs-operator">=</span><span class="hljs-literal">False</span>)<br>print(predict_sunspots)<br>fig, ax <span class="hljs-operator">=</span> plt.subplots(figsize<span class="hljs-operator">=</span>(<span class="hljs-number">12</span>, <span class="hljs-number">8</span>))<br>ax <span class="hljs-operator">=</span> sub.plot(ax<span class="hljs-operator">=</span>ax)<br>predict_sunspots.plot(ax<span class="hljs-operator">=</span>ax)<br>plt.show()<br></code></pre></td></tr></table></figure><p>结果如下：</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy80MTU1OTg2LTA1ZDU1ZGI2M2VhNDdiNzIucG5n?x-oss-process=image/format,png" alt="img"></p>]]></content>
    
    
    <categories>
      
      <category>数学建模</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数学建模</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>蚁群算法</title>
    <link href="/2022/07/25/%E8%9A%81%E7%BE%A4%E7%AE%97%E6%B3%95/"/>
    <url>/2022/07/25/%E8%9A%81%E7%BE%A4%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h2 id="蚁群算法（ACO）"><a href="#蚁群算法（ACO）" class="headerlink" title="蚁群算法（ACO）"></a>蚁群算法（ACO）</h2><h3 id="1-简介"><a href="#1-简介" class="headerlink" title="1.简介"></a>1.简介</h3><p>蚁群算法（Ant Clony Optimization， ACO）是一种群智能算法，它是由一群无智能或有轻微智能的个体（Agent）通过相互协作而表现出智能行为，从而为求解复杂问题提供了一个新的可能性。蚁群算法最早是由意大利学者Colorni A., Dorigo M. 等于1991年提出。经过20多年的发展，蚁群算法在理论以及应用研究上已经得到巨大的进步。</p><p>蚁群算法是一种仿生学算法，是由自然界中蚂蚁觅食的行为而启发的。在自然界中，蚂蚁觅食过程中，蚁群总能够按照寻找到一条从蚁巢和食物源的最优路径。下图显示了这样一个觅食的过程。</p><p><img src="https://pic1.zhimg.com/v2-79a1fe8f56260a0ce2773947db9c7794_r.jpg" alt="img"></p><p>在图（a）中，有一群蚂蚁，假如A是蚁巢，E是食物源（反之亦然）。这群蚂蚁将沿着蚁巢和食物源之间的直线路径行驶。假如在A和E之间突然出现了一个障碍物（图（b）），那么，在B点（或D点）的蚂蚁将要做出决策，到底是向左行驶还是向右行驶？由于一开始路上没有前面蚂蚁留下的 信息素（pheromone），蚂蚁朝着两个方向行进的概率是相等的。但是当有蚂蚁走过时，它将会在它行进的路上释放出信息素，并且这种信息素会议一定的速率散发掉。信息素是蚂蚁之间交流的工具之一。它后面的蚂蚁通过路上信息素的浓度，做出决策，往左还是往右。很明显，沿着短边的的路径上信息素将会越来越浓（图（c）），从而吸引了越来越多的蚂蚁沿着这条路径行驶。</p><h3 id="2-原理"><a href="#2-原理" class="headerlink" title="2.原理"></a>2.原理</h3><p>假如蚁群中所有蚂蚁的数量为m，所有城市之间的信息素用矩阵pheromone表示，最短路径为bestLength，最佳路径为bestTour。每只蚂蚁都有自己的内存，内存中用一个禁忌表（Tabu）来存储该蚂蚁已经访问过的城市，表示其在以后的搜索中将不能访问这些城市；还有用另外一个允许访问的城市表（Allowed）来存储它还可以访问的城市；另外还用一个矩阵（Delta）来存储它在一个循环（或者迭代）中给所经过的路径释放的信息素；还有另外一些数据，例如一些控制参数(α，β，ρ，Q)，该蚂蚁行走玩全程的总成本或距离（tourLength），等等。假定算法总共运行MAX_GEN次，运行时间为t。</p><p>蚁群算法计算过程如下：</p><p>（1）初始化。</p><p>（2）为每只蚂蚁选择下一个节点。</p><p>（3）更新信息素矩阵。</p><p>（4）检查终止条件</p><blockquote><p>如果达到最大代数MAX_GEN，算法终止，转到第（5）步；否则，重新初始化所有的蚂蚁的Delt矩阵所有元素初始化为0，Tabu表清空，Allowed表中加入所有的城市节点。随机选择它们的起始位置（也可以人工指定）。在Tabu中加入起始节点，Allowed中去掉该起始节点，重复执行(2),(3),(4)步。</p></blockquote><p>（5）输出最优值</p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># -*- coding: utf-8 -*-</span><br><span class="hljs-keyword">import</span> random<br><span class="hljs-keyword">import</span> copy<br><span class="hljs-keyword">import</span> time<br><span class="hljs-keyword">import</span> sys<br><span class="hljs-keyword">import</span> math<br><span class="hljs-keyword">import</span> tkinter <span class="hljs-comment">#//GUI模块</span><br><span class="hljs-keyword">import</span> threading<br><span class="hljs-keyword">from</span> functools <span class="hljs-keyword">import</span> reduce<br><br><br><span class="hljs-comment"># 参数</span><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">ALPHA:信息启发因子，值越大，则蚂蚁选择之前走过的路径可能性就越大</span><br><span class="hljs-string">      ，值越小，则蚁群搜索范围就会减少，容易陷入局部最优</span><br><span class="hljs-string">BETA:Beta值越大，蚁群越就容易选择局部较短路径，这时算法收敛速度会</span><br><span class="hljs-string">     加快，但是随机性不高，容易得到局部的相对最优</span><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br>(ALPHA, BETA, RHO, Q) = (<span class="hljs-number">1.0</span>,<span class="hljs-number">2.0</span>,<span class="hljs-number">0.5</span>,<span class="hljs-number">100.0</span>)<br><span class="hljs-comment"># 城市数，蚁群</span><br>(city_num, ant_num) = (<span class="hljs-number">50</span>,<span class="hljs-number">50</span>)<br>distance_x = [<br>    <span class="hljs-number">178</span>,<span class="hljs-number">272</span>,<span class="hljs-number">176</span>,<span class="hljs-number">171</span>,<span class="hljs-number">650</span>,<span class="hljs-number">499</span>,<span class="hljs-number">267</span>,<span class="hljs-number">703</span>,<span class="hljs-number">408</span>,<span class="hljs-number">437</span>,<span class="hljs-number">491</span>,<span class="hljs-number">74</span>,<span class="hljs-number">532</span>,<br>    <span class="hljs-number">416</span>,<span class="hljs-number">626</span>,<span class="hljs-number">42</span>,<span class="hljs-number">271</span>,<span class="hljs-number">359</span>,<span class="hljs-number">163</span>,<span class="hljs-number">508</span>,<span class="hljs-number">229</span>,<span class="hljs-number">576</span>,<span class="hljs-number">147</span>,<span class="hljs-number">560</span>,<span class="hljs-number">35</span>,<span class="hljs-number">714</span>,<br>    <span class="hljs-number">757</span>,<span class="hljs-number">517</span>,<span class="hljs-number">64</span>,<span class="hljs-number">314</span>,<span class="hljs-number">675</span>,<span class="hljs-number">690</span>,<span class="hljs-number">391</span>,<span class="hljs-number">628</span>,<span class="hljs-number">87</span>,<span class="hljs-number">240</span>,<span class="hljs-number">705</span>,<span class="hljs-number">699</span>,<span class="hljs-number">258</span>,<br>    <span class="hljs-number">428</span>,<span class="hljs-number">614</span>,<span class="hljs-number">36</span>,<span class="hljs-number">360</span>,<span class="hljs-number">482</span>,<span class="hljs-number">666</span>,<span class="hljs-number">597</span>,<span class="hljs-number">209</span>,<span class="hljs-number">201</span>,<span class="hljs-number">492</span>,<span class="hljs-number">294</span>]<br>distance_y = [<br>    <span class="hljs-number">170</span>,<span class="hljs-number">395</span>,<span class="hljs-number">198</span>,<span class="hljs-number">151</span>,<span class="hljs-number">242</span>,<span class="hljs-number">556</span>,<span class="hljs-number">57</span>,<span class="hljs-number">401</span>,<span class="hljs-number">305</span>,<span class="hljs-number">421</span>,<span class="hljs-number">267</span>,<span class="hljs-number">105</span>,<span class="hljs-number">525</span>,<br>    <span class="hljs-number">381</span>,<span class="hljs-number">244</span>,<span class="hljs-number">330</span>,<span class="hljs-number">395</span>,<span class="hljs-number">169</span>,<span class="hljs-number">141</span>,<span class="hljs-number">380</span>,<span class="hljs-number">153</span>,<span class="hljs-number">442</span>,<span class="hljs-number">528</span>,<span class="hljs-number">329</span>,<span class="hljs-number">232</span>,<span class="hljs-number">48</span>,<br>    <span class="hljs-number">498</span>,<span class="hljs-number">265</span>,<span class="hljs-number">343</span>,<span class="hljs-number">120</span>,<span class="hljs-number">165</span>,<span class="hljs-number">50</span>,<span class="hljs-number">433</span>,<span class="hljs-number">63</span>,<span class="hljs-number">491</span>,<span class="hljs-number">275</span>,<span class="hljs-number">348</span>,<span class="hljs-number">222</span>,<span class="hljs-number">288</span>,<br>    <span class="hljs-number">490</span>,<span class="hljs-number">213</span>,<span class="hljs-number">524</span>,<span class="hljs-number">244</span>,<span class="hljs-number">114</span>,<span class="hljs-number">104</span>,<span class="hljs-number">552</span>,<span class="hljs-number">70</span>,<span class="hljs-number">425</span>,<span class="hljs-number">227</span>,<span class="hljs-number">331</span>]<br><span class="hljs-comment">#城市距离和信息素</span><br>distance_graph = [ [<span class="hljs-number">0.0</span> <span class="hljs-keyword">for</span> col <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(city_num)] <span class="hljs-keyword">for</span> raw <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(city_num)]<br>pheromone_graph = [ [<span class="hljs-number">1.0</span> <span class="hljs-keyword">for</span> col <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(city_num)] <span class="hljs-keyword">for</span> raw <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(city_num)]<br><br><br><br><span class="hljs-comment">#----------- 蚂蚁 -----------</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Ant</span>(<span class="hljs-title class_ inherited__">object</span>):<br><br>    <span class="hljs-comment"># 初始化</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self,ID</span>):<br><br>        self.ID = ID                 <span class="hljs-comment"># ID</span><br>        self.__clean_data()          <span class="hljs-comment"># 随机初始化出生点</span><br><br>    <span class="hljs-comment"># 初始数据</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__clean_data</span>(<span class="hljs-params">self</span>):<br><br>        self.path = []               <span class="hljs-comment"># 当前蚂蚁的路径           </span><br>        self.total_distance = <span class="hljs-number">0.0</span>    <span class="hljs-comment"># 当前路径的总距离</span><br>        self.move_count = <span class="hljs-number">0</span>          <span class="hljs-comment"># 移动次数</span><br>        self.current_city = -<span class="hljs-number">1</span>       <span class="hljs-comment"># 当前停留的城市</span><br>        self.open_table_city = [<span class="hljs-literal">True</span> <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(city_num)] <span class="hljs-comment"># 探索城市的状态</span><br><br>        city_index = random.randint(<span class="hljs-number">0</span>,city_num-<span class="hljs-number">1</span>) <span class="hljs-comment"># 随机初始出生点</span><br>        self.current_city = city_index<br>        self.path.append(city_index)<br>        self.open_table_city[city_index] = <span class="hljs-literal">False</span><br>        self.move_count = <span class="hljs-number">1</span><br><br>    <span class="hljs-comment"># 选择下一个城市</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__choice_next_city</span>(<span class="hljs-params">self</span>):<br><br>        next_city = -<span class="hljs-number">1</span><br>        select_citys_prob = [<span class="hljs-number">0.0</span> <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(city_num)]  <span class="hljs-comment">#存储去下个城市的概率</span><br>        total_prob = <span class="hljs-number">0.0</span><br><br>        <span class="hljs-comment"># 获取去下一个城市的概率</span><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(city_num):<br>            <span class="hljs-keyword">if</span> self.open_table_city[i]:<br>                <span class="hljs-keyword">try</span> :<br>                    <span class="hljs-comment"># 计算概率：与信息素浓度成正比，与距离成反比</span><br>                    select_citys_prob[i] = <span class="hljs-built_in">pow</span>(pheromone_graph[self.current_city][i], ALPHA) * <span class="hljs-built_in">pow</span>((<span class="hljs-number">1.0</span>/distance_graph[self.current_city][i]), BETA)<br>                    total_prob += select_citys_prob[i]<br>                <span class="hljs-keyword">except</span> ZeroDivisionError <span class="hljs-keyword">as</span> e:<br>                    <span class="hljs-built_in">print</span> (<span class="hljs-string">&#x27;Ant ID: &#123;ID&#125;, current city: &#123;current&#125;, target city: &#123;target&#125;&#x27;</span>.<span class="hljs-built_in">format</span>(ID = self.ID, current = self.current_city, target = i))<br>                    sys.exit(<span class="hljs-number">1</span>)<br><br>        <span class="hljs-comment"># 轮盘选择城市</span><br>        <span class="hljs-keyword">if</span> total_prob &gt; <span class="hljs-number">0.0</span>:<br>            <span class="hljs-comment"># 产生一个随机概率,0.0-total_prob</span><br>            temp_prob = random.uniform(<span class="hljs-number">0.0</span>, total_prob)<br>            <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(city_num):<br>                <span class="hljs-keyword">if</span> self.open_table_city[i]:<br>                    <span class="hljs-comment"># 轮次相减</span><br>                    temp_prob -= select_citys_prob[i]<br>                    <span class="hljs-keyword">if</span> temp_prob &lt; <span class="hljs-number">0.0</span>:<br>                        next_city = i<br>                        <span class="hljs-keyword">break</span><br><br>        <span class="hljs-comment"># 未从概率产生，顺序选择一个未访问城市</span><br>        <span class="hljs-comment"># if next_city == -1:</span><br>        <span class="hljs-comment">#     for i in range(city_num):</span><br>        <span class="hljs-comment">#         if self.open_table_city[i]:</span><br>        <span class="hljs-comment">#             next_city = i</span><br>        <span class="hljs-comment">#             break</span><br><br>        <span class="hljs-keyword">if</span> (next_city == -<span class="hljs-number">1</span>):<br>            next_city = random.randint(<span class="hljs-number">0</span>, city_num - <span class="hljs-number">1</span>)<br>            <span class="hljs-keyword">while</span> ((self.open_table_city[next_city]) == <span class="hljs-literal">False</span>):  <span class="hljs-comment"># if==False,说明已经遍历过了</span><br>                next_city = random.randint(<span class="hljs-number">0</span>, city_num - <span class="hljs-number">1</span>)<br><br>        <span class="hljs-comment"># 返回下一个城市序号</span><br>        <span class="hljs-keyword">return</span> next_city<br><br>    <span class="hljs-comment"># 计算路径总距离</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__cal_total_distance</span>(<span class="hljs-params">self</span>):<br><br>        temp_distance = <span class="hljs-number">0.0</span><br><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, city_num):<br>            start, end = self.path[i], self.path[i-<span class="hljs-number">1</span>]<br>            temp_distance += distance_graph[start][end]<br><br>        <span class="hljs-comment"># 回路</span><br>        end = self.path[<span class="hljs-number">0</span>]<br>        temp_distance += distance_graph[start][end]<br>        self.total_distance = temp_distance<br><br><br>    <span class="hljs-comment"># 移动操作</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__move</span>(<span class="hljs-params">self, next_city</span>):<br><br>        self.path.append(next_city)<br>        self.open_table_city[next_city] = <span class="hljs-literal">False</span><br>        self.total_distance += distance_graph[self.current_city][next_city]<br>        self.current_city = next_city<br>        self.move_count += <span class="hljs-number">1</span><br><br>    <span class="hljs-comment"># 搜索路径</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">search_path</span>(<span class="hljs-params">self</span>):<br><br>        <span class="hljs-comment"># 初始化数据</span><br>        self.__clean_data()<br><br>        <span class="hljs-comment"># 搜素路径，遍历完所有城市为止</span><br>        <span class="hljs-keyword">while</span> self.move_count &lt; city_num:<br>            <span class="hljs-comment"># 移动到下一个城市</span><br>            next_city =  self.__choice_next_city()<br>            self.__move(next_city)<br><br>        <span class="hljs-comment"># 计算路径总长度</span><br>        self.__cal_total_distance()<br><br><span class="hljs-comment">#----------- TSP问题 -----------</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">TSP</span>(<span class="hljs-title class_ inherited__">object</span>):<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, root, width = <span class="hljs-number">800</span>, height = <span class="hljs-number">600</span>, n = city_num</span>):<br><br>        <span class="hljs-comment"># 创建画布</span><br>        self.root = root                               <br>        self.width = width      <br>        self.height = height<br>        <span class="hljs-comment"># 城市数目初始化为city_num</span><br>        self.n = n<br>        <span class="hljs-comment"># tkinter.Canvas</span><br>        self.canvas = tkinter.Canvas(<br>                root,<br>                width = self.width,<br>                height = self.height,<br>                bg = <span class="hljs-string">&quot;#EBEBEB&quot;</span>,             <span class="hljs-comment"># 背景白色 </span><br>                xscrollincrement = <span class="hljs-number">1</span>,<br>                yscrollincrement = <span class="hljs-number">1</span><br>            )<br>        self.canvas.pack(expand = tkinter.YES, fill = tkinter.BOTH)<br>        self.title(<span class="hljs-string">&quot;TSP蚁群算法(n:初始化 e:开始搜索 s:停止搜索 q:退出程序)&quot;</span>)<br>        self.__r = <span class="hljs-number">5</span><br>        self.__lock = threading.RLock()     <span class="hljs-comment"># 线程锁</span><br><br>        self.__bindEvents()<br>        self.new()<br><br>        <span class="hljs-comment"># 计算城市之间的距离</span><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(city_num):<br>            <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(city_num):<br>                temp_distance = <span class="hljs-built_in">pow</span>((distance_x[i] - distance_x[j]), <span class="hljs-number">2</span>) + <span class="hljs-built_in">pow</span>((distance_y[i] - distance_y[j]), <span class="hljs-number">2</span>)<br>                temp_distance = <span class="hljs-built_in">pow</span>(temp_distance, <span class="hljs-number">0.5</span>)<br>                distance_graph[i][j] =<span class="hljs-built_in">float</span>(<span class="hljs-built_in">int</span>(temp_distance + <span class="hljs-number">0.5</span>))<br><br>    <span class="hljs-comment"># 按键响应程序</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__bindEvents</span>(<span class="hljs-params">self</span>):<br><br>        self.root.bind(<span class="hljs-string">&quot;q&quot;</span>, self.quite)        <span class="hljs-comment"># 退出程序</span><br>        self.root.bind(<span class="hljs-string">&quot;n&quot;</span>, self.new)          <span class="hljs-comment"># 初始化</span><br>        self.root.bind(<span class="hljs-string">&quot;e&quot;</span>, self.search_path)  <span class="hljs-comment"># 开始搜索</span><br>        self.root.bind(<span class="hljs-string">&quot;s&quot;</span>, self.stop)         <span class="hljs-comment"># 停止搜索</span><br><br>    <span class="hljs-comment"># 更改标题</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">title</span>(<span class="hljs-params">self, s</span>):<br><br>        self.root.title(s)<br><br>    <span class="hljs-comment"># 初始化</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">new</span>(<span class="hljs-params">self, evt = <span class="hljs-literal">None</span></span>):<br><br>        <span class="hljs-comment"># 停止线程</span><br>        self.__lock.acquire()<br>        self.__running = <span class="hljs-literal">False</span><br>        self.__lock.release()<br><br>        self.clear()     <span class="hljs-comment"># 清除信息 </span><br>        self.nodes = []  <span class="hljs-comment"># 节点坐标</span><br>        self.nodes2 = [] <span class="hljs-comment"># 节点对象</span><br><br>        <span class="hljs-comment"># 初始化城市节点</span><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(distance_x)):<br>            <span class="hljs-comment"># 在画布上随机初始坐标</span><br>            x = distance_x[i]<br>            y = distance_y[i]<br>            self.nodes.append((x, y))<br>            <span class="hljs-comment"># 生成节点椭圆，半径为self.__r</span><br>            node = self.canvas.create_oval(x - self.__r,<br>                    y - self.__r, x + self.__r, y + self.__r,<br>                    fill = <span class="hljs-string">&quot;#ff0000&quot;</span>,      <span class="hljs-comment"># 填充红色</span><br>                    outline = <span class="hljs-string">&quot;#000000&quot;</span>,   <span class="hljs-comment"># 轮廓白色</span><br>                    tags = <span class="hljs-string">&quot;node&quot;</span>,<br>                )<br>            self.nodes2.append(node)<br>            <span class="hljs-comment"># 显示坐标</span><br>            self.canvas.create_text(x,y-<span class="hljs-number">10</span>,              <span class="hljs-comment"># 使用create_text方法在坐标（302，77）处绘制文字</span><br>                    text = <span class="hljs-string">&#x27;(&#x27;</span>+<span class="hljs-built_in">str</span>(x)+<span class="hljs-string">&#x27;,&#x27;</span>+<span class="hljs-built_in">str</span>(y)+<span class="hljs-string">&#x27;)&#x27;</span>,    <span class="hljs-comment"># 所绘制文字的内容</span><br>                    fill = <span class="hljs-string">&#x27;black&#x27;</span>                       <span class="hljs-comment"># 所绘制文字的颜色为灰色</span><br>                )<br><br>        <span class="hljs-comment"># 顺序连接城市</span><br>        <span class="hljs-comment">#self.line(range(city_num))</span><br><br>        <span class="hljs-comment"># 初始城市之间的距离和信息素</span><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(city_num):<br>            <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(city_num):<br>                pheromone_graph[i][j] = <span class="hljs-number">1.0</span><br><br>        self.ants = [Ant(ID) <span class="hljs-keyword">for</span> ID <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(ant_num)]  <span class="hljs-comment"># 初始蚁群</span><br>        self.best_ant = Ant(-<span class="hljs-number">1</span>)                          <span class="hljs-comment"># 初始最优解</span><br>        self.best_ant.total_distance = <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">31</span>           <span class="hljs-comment"># 初始最大距离</span><br>        self.<span class="hljs-built_in">iter</span> = <span class="hljs-number">1</span>                                    <span class="hljs-comment"># 初始化迭代次数 </span><br><br>    <span class="hljs-comment"># 将节点按order顺序连线</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">line</span>(<span class="hljs-params">self, order</span>):<br>        <span class="hljs-comment"># 删除原线</span><br>        self.canvas.delete(<span class="hljs-string">&quot;line&quot;</span>)<br>        <span class="hljs-keyword">def</span> <span class="hljs-title function_">line2</span>(<span class="hljs-params">i1, i2</span>):<br>            p1, p2 = self.nodes[i1], self.nodes[i2]<br>            self.canvas.create_line(p1, p2, fill = <span class="hljs-string">&quot;#000000&quot;</span>, tags = <span class="hljs-string">&quot;line&quot;</span>)<br>            <span class="hljs-keyword">return</span> i2<br><br>        <span class="hljs-comment"># order[-1]为初始值</span><br>        reduce(line2, order, order[-<span class="hljs-number">1</span>])<br><br>    <span class="hljs-comment"># 清除画布</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">clear</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-keyword">for</span> item <span class="hljs-keyword">in</span> self.canvas.find_all():<br>            self.canvas.delete(item)<br><br>    <span class="hljs-comment"># 退出程序</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">quite</span>(<span class="hljs-params">self, evt</span>):<br>        self.__lock.acquire()<br>        self.__running = <span class="hljs-literal">False</span><br>        self.__lock.release()<br>        self.root.destroy()<br>        <span class="hljs-built_in">print</span> (<span class="hljs-string">u&quot;\n程序已退出...&quot;</span>)<br>        sys.exit()<br><br>    <span class="hljs-comment"># 停止搜索</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">stop</span>(<span class="hljs-params">self, evt</span>):<br>        self.__lock.acquire()<br>        self.__running = <span class="hljs-literal">False</span><br>        self.__lock.release()<br><br>    <span class="hljs-comment"># 开始搜索</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">search_path</span>(<span class="hljs-params">self, evt = <span class="hljs-literal">None</span></span>):<br><br>        <span class="hljs-comment"># 开启线程</span><br>        self.__lock.acquire()<br>        self.__running = <span class="hljs-literal">True</span><br>        self.__lock.release()<br><br>        <span class="hljs-keyword">while</span> self.__running:<br>            <span class="hljs-comment"># 遍历每一只蚂蚁</span><br>            <span class="hljs-keyword">for</span> ant <span class="hljs-keyword">in</span> self.ants:<br>                <span class="hljs-comment"># 搜索一条路径</span><br>                ant.search_path()<br>                <span class="hljs-comment"># 与当前最优蚂蚁比较</span><br>                <span class="hljs-keyword">if</span> ant.total_distance &lt; self.best_ant.total_distance:<br>                    <span class="hljs-comment"># 更新最优解</span><br>                    self.best_ant = copy.deepcopy(ant)<br>            <span class="hljs-comment"># 更新信息素</span><br>            self.__update_pheromone_gragh()<br>            <span class="hljs-built_in">print</span> (<span class="hljs-string">u&quot;迭代次数：&quot;</span>,self.<span class="hljs-built_in">iter</span>,<span class="hljs-string">u&quot;最佳路径总距离：&quot;</span>,<span class="hljs-built_in">int</span>(self.best_ant.total_distance))<br>            <span class="hljs-comment"># 连线</span><br>            self.line(self.best_ant.path)<br>            <span class="hljs-comment"># 设置标题</span><br>            self.title(<span class="hljs-string">&quot;TSP蚁群算法(n:随机初始 e:开始搜索 s:停止搜索 q:退出程序) 迭代次数: %d&quot;</span> % self.<span class="hljs-built_in">iter</span>)<br>            <span class="hljs-comment"># 更新画布</span><br>            self.canvas.update()<br>            self.<span class="hljs-built_in">iter</span> += <span class="hljs-number">1</span><br><br>    <span class="hljs-comment"># 更新信息素</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__update_pheromone_gragh</span>(<span class="hljs-params">self</span>):<br><br>        <span class="hljs-comment"># 获取每只蚂蚁在其路径上留下的信息素</span><br>        temp_pheromone = [[<span class="hljs-number">0.0</span> <span class="hljs-keyword">for</span> col <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(city_num)] <span class="hljs-keyword">for</span> raw <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(city_num)]<br>        <span class="hljs-keyword">for</span> ant <span class="hljs-keyword">in</span> self.ants:<br>            <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>,city_num):<br>                start, end = ant.path[i-<span class="hljs-number">1</span>], ant.path[i]<br>                <span class="hljs-comment"># 在路径上的每两个相邻城市间留下信息素，与路径总距离反比</span><br>                temp_pheromone[start][end] += Q / ant.total_distance<br>                temp_pheromone[end][start] = temp_pheromone[start][end]<br><br>        <span class="hljs-comment"># 更新所有城市之间的信息素，旧信息素衰减加上新迭代信息素</span><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(city_num):<br>            <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(city_num):<br>                pheromone_graph[i][j] = pheromone_graph[i][j] * RHO + temp_pheromone[i][j]<br><br>    <span class="hljs-comment"># 主循环</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">mainloop</span>(<span class="hljs-params">self</span>):<br>        self.root.mainloop()<br><br><span class="hljs-comment">#----------- 程序的入口处 -----------</span><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br><br><br>    TSP(tkinter.Tk()).mainloop()<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>数学建模</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数学建模</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>模拟退火算法</title>
    <link href="/2022/07/25/%E6%A8%A1%E6%8B%9F%E9%80%80%E7%81%AB%E7%AE%97%E6%B3%95/"/>
    <url>/2022/07/25/%E6%A8%A1%E6%8B%9F%E9%80%80%E7%81%AB%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h2 id="模拟退火算法（SA）"><a href="#模拟退火算法（SA）" class="headerlink" title="模拟退火算法（SA）"></a>模拟退火算法（SA）</h2><h3 id="1-简介"><a href="#1-简介" class="headerlink" title="1.简介"></a>1.简介</h3><p>​        模拟退火算法来源于固体退火原理，将固体加温至充分高，再让其徐徐冷却，加温时，固体内部粒子随温升变为无序状，内能增大，而徐徐冷却时粒子渐趋有序，在每个温度都达到平衡态，最后在常温时达到基态，内能减为最小。根据 <code>Metropolis</code> 准则，粒子在温度T时趋于平衡的概率为 <code>e-ΔE/(kT)</code> ，其中 <code>E</code> 为温度 <code>T</code> 时的内能， <code>ΔE</code> 为其改变量， <code>k</code> 为 <code>Boltzmann</code> 常数。用固体退火模拟组合优化问题，将内能E模拟为目标函数值 <code>f</code> ，温度 <code>T</code> 演化成控制参数 <code>t</code> ，即得到解组合优化问题的模拟退火算法：由初始解 <code>i</code> 和控制参数初值 <code>t</code> 开始，对当前解重复“产生新解计算目标函数差接受或舍弃”的迭代，并逐步衰减t值，算法终止时的当前解即为所得近似最优解，这是基于蒙特卡罗迭代求解法的一种启发式随机搜索过程。退火过程由冷却进度表 <code>(Cooling Schedule)</code> 控制，包括控制参数的初值 <code>t</code> 及其衰减因子 <code>Δt</code> 、每个 <code>t</code> 值时的迭代次数 <code>L</code> 和停止条件 <code>S</code> 。</p><h3 id="2-模型"><a href="#2-模型" class="headerlink" title="2.模型"></a>2.模型</h3><p>模拟退火算法可以分解为解空间、目标函数和初始解三部分。</p><h3 id="3-基本思想"><a href="#3-基本思想" class="headerlink" title="3.基本思想"></a>3.基本思想</h3><p>(1) 初始化：初始温度 <code>T</code> (充分大)，初始解状态 <code>S</code> (是算法迭代的起点)， 每个 <code>T</code> 值的迭代次数 <code>L</code></p><p>(2) 对 <code>k=1，……，L</code> 做第 <code>3</code> 至第 <code>6</code> 步：</p><p>(3) 产生新解 <code>S&#39;</code></p><p>(4) 计算增量 <code>Δt′=C(S′)-C(S)</code> ，其中 <code>C(S)</code> 为评价函数</p><p>(5) 若 <code>Δt′&lt;0</code> 则接受 <code>S′</code> 作为新的当前解，否则以概率 <code>exp(-Δt′/T)</code> 接受 <code>S′</code> 作为新的当前解.</p><p>(6) 如果满足终止条件则输出当前解作为最优解，结束程序。 终止条件通常取为连续若干个新解都没有被接受时终止算法。</p><p>(7) <code>T</code> 逐渐减少，且 <code>T-&gt;0</code> ，然后转第 <code>2</code> 步。</p><p>模拟退火的算法流程图如下:</p><p><img src="https://pic3.zhimg.com/v2-a1fad275aca1f01555d0e88cc43c94e2_r.jpg" alt="img"></p><p>模拟退火算法新解的产生和接受可分为如下四个步骤：</p><p>第一步是由一个产生函数从当前解产生一个位于解空间的新解；为便于后续的计算和接受，减少算法耗时，通常选择由当前新解经过简单地变换即可产生新解的方法，如对构成新解的全部或部分元素进行置换、互换等，注意到产生新解的变换方法决定了当前新解的邻域结构，因而对冷却进度表的选取有一定的影响。</p><p>第二步是计算与新解所对应的目标函数差。因为目标函数差仅由变换部分产生，所以目标函数差的计算最好按增量计算。事实表明，对大多数应用而言，这是计算目标函数差的最快方法。</p><p>第三步是判断新解是否被接受,判断的依据是一个接受准则，最常用的接受准则是 <code>Metropolis</code> 准则: 若 <code>Δt′&lt;0</code> 则接受 <code>S′</code> 作为新的当前解 <code>S</code> ，否则以概率 <code>exp(-Δt′/T)</code> 接受 <code>S′</code> 作为新的当前解 <code>S</code> 。</p><p>第四步是当新解被确定接受时，用新解代替当前解，这只需将当前解中对应于产生新解时的变换部分予以实现，同时修正目标函数值即可。此时，当前解实现了一次迭代。可在此基础上开始下一轮试验。而当新解被判定为舍弃时，则在原当前解的基础上继续下一轮试验。模拟退火算法与初始值无关，算法求得的解与初始解状态 <code>S</code> (是算法迭代的起点)无关；模拟退火算法具有渐近收敛性，已在理论上被证明是一种以概率 <code>l</code> 收敛于全局最优解的全局优化算法；模拟退火算法具有并行性</p><p>想象一下如果我们现在有下面这样一个函数，现在想求函数的（全局）最优解。如果采用 <code>Greedy</code> 策略，那么从 <code>A</code> 点开始试探，如果函数值继续减少，那么试探过程就会继续。而当到达点B时，显然我们的探求过程就结束了（因为无论朝哪个方向努力，结果只会越来越大）。最终我们只能找打一个局部最后解 <code>B</code> 。</p><p><img src="https://pic4.zhimg.com/v2-325d61d601d35108cb2a47e051c2aa1b_r.jpg" alt="img"></p><p>模拟退火其实也是一种 <code>Greedy</code> 算法，但是它的搜索过程引入了随机因素。模拟退火算法以一定的概率来接受一个比当前解要差的解，因此有可能会跳出这个局部的最优解，达到全局的最优解。以上图为例，模拟退火算法在搜索到局部最优解 <code>B</code> 后，会以一定的概率接受向右继续移动。也许经过几次这样的不是局部最优的移动后会到达 <code>B</code> 和 <code>C</code> 之间的峰点，于是就跳出了局部最小值B。</p><p>根据Metropolis准则，粒子在温度T时趋于平衡的概率为 <code>exp(-ΔE/(kT))</code> ，其中 <code>E</code> 为温度 <code>T</code> 时的内能，ΔE为其改变数, <code>k</code> 为 <code>Boltzmann</code> 常数。 <code>Metropolis</code> 准则常表示为</p><p><img src="https://pic2.zhimg.com/v2-3c82763bd38b4f0f00bb0a9e9716f51d_r.jpg" alt="img"></p><p><code>Metropolis</code> 准则表明，在温度为 <code>T</code> 时，出现能量差为 <code>dE</code> 的降温的概率为 <code>P(dE)</code>，表示为： <code>P(dE) = exp(dE/(kT))</code> 。其中 <code>k</code> 是一个常数， <code>exp</code> 表示自然指数，且 <code>dE&lt;0</code> 。所以 <code>P</code> 和 <code>T</code> 正相关。这条公式就表示：温度越高，出现一次能量差为 <code>dE</code> 的降温的概率就越大；温度越低，则出现降温的概率就越小。又由于 <code>dE</code> 总是小于 <code>0</code> （因为退火的过程是温度逐渐下降的过程），因此 <code>dE/kT &lt; 0</code> ，所以 <code>P(dE)</code> 的函数取值范围是 <code>(0,1)</code> 。随着温度 <code>T</code> 的降低， <code>P(dE)</code> 会逐渐降低。<br>我们将一次向较差解的移动看做一次温度跳变过程，我们以概率 <code>P(dE)</code> 来接受这样的移动。也就是说，在用固体退火模拟组合优化问题，将内能E模拟为目标函数值 f，温度T演化成控制参数 t，即得到解组合优化问题的模拟退火演算法：由初始解 i 和控制参数初值 t 开始，对当前解重复“产生新解计算目标函数差接受或丢弃”的迭代，并逐步衰减 t 值，算法终止时的当前解即为所得近似最优解，这是基于蒙特卡罗迭代求解法的一种启发式随机搜索过程。退火过程由冷却进度表 <code>(Cooling Schedule)</code> 控制，包括控制参数的初值 t 及其衰减因子 Δt 、每个 t 值时的迭代次数 L 和停止条件 S 。</p><p>总结起来就是：</p><ul><li>若 f( Y(i+1) ) &lt;&#x3D; f( Y(i) ) (即移动后得到更优解)，则总是接受该移动；</li><li>若 f( Y(i+1) ) &gt; f( Y(i) ) (即移动后的解比当前解要差)，则以一定的概率接受移动，而且这个概率随着时间推移逐渐降低（逐渐降低才能趋向稳定）相当于上图中，从 <code>B</code> 移向 <code>BC</code> 之间的小波峰时，每次右移（即接受一个更糟糕值）的概率在逐渐降低。如果这个坡特别长，那么很有可能最终我们并不会翻过这个坡。如果它不太长，这很有可能会翻过它，这取决于衰减 t 值的设定。</li></ul><p>关于普通 <code>Greedy</code> 算法与模拟退火，有一个有趣的比喻：</p><ul><li><ul><li>普通 <code>Greedy</code> 算法：兔子朝着比现在低的地方跳去。它找到了不远处的最低的山谷。但是这座山谷不一定最低的。这就是普通 <code>Greedy</code> 算法，它不能保证局部最优值就是全局最优值。</li><li>模拟退火：兔子喝醉了。它随机地跳了很长时间。这期间，它可能走向低处，也可能踏入平地。但是，它渐渐清醒了并朝最低的方向跳去。这就是模拟退火。</li></ul></li></ul><h3 id="4-TSP问题的matlab求解"><a href="#4-TSP问题的matlab求解" class="headerlink" title="4.TSP问题的matlab求解"></a>4.TSP问题的matlab求解</h3><ol><li>TSP问题：TSP(Traveling salesman problem)即旅行商问题，旅行商希望在N个城市进行一次巡回旅行，可以恰好访问每一个城市一次，并且最终回到出发城市。并且要使得这次巡回旅行的总消耗最小（总距离或总花销等等），如何求这个路线？</li></ol><ul><li>TSP的解空间S是遍历每个城市恰好一次的所有回路（回到起点），那么一个可行解即为所有城市的一个排列，则解空间可以表示为：</li></ul><p><img src="https://www.zhihu.com/equation?tex=S=%5Cleft%5C%7B+(x_%7B1%7D,x_%7B2%7D,...,x_%7BN%7D)+%5Cright%5C%7D,x_%7Bi%7D(i=1,2,...,N)%5C%5C" alt="[公式]"></p><p>即为每个城市的编号，其中的每一个排列 <img src="https://www.zhihu.com/equation?tex=S_%7Bi%7D" alt="[公式]"> 即为一个离线，所以初始解就被表示成为了一个{1,2,…,N}的随机序列。</p><ol start="2"><li>目标函数</li></ol><p>遍历所有城市的代价最小，此处我们将代价刻画为总路径最小，目标函数：</p><p><img src="https://www.zhihu.com/equation?tex=C(x_%7B1%7D,...,x_%7BN%7D)=min%5Cleft%5B+%5Csum_%7Bi=1%7D%5E%7Bn-1%7D%7Bd(x_%7Bi%7D,x_%7Bi+1%7D)%7D+d(x_%7B1%7D,x_%7Bn%7D)%5Cright%5D%5C%5C" alt="[公式]"></p><p>而 <img src="https://www.zhihu.com/equation?tex=(x_%7B1%7D,...,x_%7BN%7D)" alt="[公式]"> 即为该最短路径（TSP问题的解即为城市标号的一个排列）</p><ol start="3"><li>新解的产生</li></ol><ul><li>两点交换法：交换 <img src="https://www.zhihu.com/equation?tex=u%EF%BC%8Cv%EF%BC%88u%5Cleq%7Bv%7D%EF%BC%89" alt="[公式]"> 的访问顺序</li><li>三变换：任选序号 <img src="https://www.zhihu.com/equation?tex=u,v,w(u%5Cleq%7Bv%7D%3Cw)" alt="[公式]"> ,将 <img src="https://www.zhihu.com/equation?tex=u,v" alt="[公式]"> 之间的路径插到 <img src="https://www.zhihu.com/equation?tex=w" alt="[公式]">之后访问。</li></ul><ol start="4"><li>Metropolis接收准则</li></ol><p>以新解与当前解的目标函数差（内能之差）来定义接受概率：</p><p><img src="https://www.zhihu.com/equation?tex=p=%5Cbegin%7Bcases%7D+1,~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~E(x_%7Bj%7D)-E(x_%7Bi%7D)%3C0%5C%5C+exp(%5Cfrac%7B-(E(x_%7Bj%7D)-E(x_%7Bi%7D))%7D%7BT%7D),~~~~~else%5C%5C++%5Cend%7Bcases%7D%5C%5C" alt="[公式]"></p><p>TSP问题的matlab程序</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br></pre></td><td class="code"><pre><code class="hljs matlab"><span class="hljs-function"><span class="hljs-keyword">function</span>  <span class="hljs-title">SA_TSP</span><span class="hljs-params">()</span></span><br><span class="hljs-comment">% Input: The coordinates of different cities</span><br>data=[<span class="hljs-number">565</span>,<span class="hljs-number">575</span>;<span class="hljs-number">25</span>,<span class="hljs-number">185</span>;<span class="hljs-number">345</span>,<span class="hljs-number">750</span>;<span class="hljs-number">945</span>,<span class="hljs-number">685</span>;<span class="hljs-number">845</span>,<span class="hljs-number">355</span>;<span class="hljs-number">880</span>,<span class="hljs-number">460</span>;<span class="hljs-number">25</span>,<span class="hljs-number">230</span>;<span class="hljs-number">525</span>,<span class="hljs-number">1000</span>;<span class="hljs-number">580</span>,<span class="hljs-number">1175</span>;<span class="hljs-number">650</span>,<span class="hljs-number">1130</span>;<span class="hljs-number">1605</span>,<span class="hljs-number">620</span>;<span class="hljs-number">1220</span>,<span class="hljs-number">580</span>;<span class="hljs-number">1465</span>,<span class="hljs-number">200</span>;<span class="hljs-number">1530</span>,<span class="hljs-number">5</span>;<span class="hljs-number">845</span>,<span class="hljs-number">680</span>;<span class="hljs-number">725</span>,<span class="hljs-number">370</span>];<br>num_city = <span class="hljs-built_in">size</span>(data,<span class="hljs-number">1</span>);<br>Initial_temp = <span class="hljs-number">1000</span>;<br>res = <span class="hljs-number">1e-3</span>;                             <span class="hljs-comment">% 最低温限制</span><br>ratio = <span class="hljs-number">0.9</span>;                            <span class="hljs-comment">% 降温参数，控制温度的下降</span><br>temperature = Initial_temp;<br>Markov_length = <span class="hljs-number">1000</span>;                   <span class="hljs-comment">% 改变解的次数</span><br>Distance_matrix = pdist2(data,data);    <span class="hljs-comment">% 矩阵的形式存储城市之间的距离</span><br>route_new = randperm(num_city);         <span class="hljs-comment">% 新产生的解路线</span><br>Energy_current = <span class="hljs-built_in">inf</span>;                   <span class="hljs-comment">% 当前解的能量</span><br>Energy_best = <span class="hljs-built_in">inf</span>;                      <span class="hljs-comment">% 最优解的能量</span><br><br>route_current = route_new;              <span class="hljs-comment">% 当前解路线</span><br>route_best = route_new;                 <span class="hljs-comment">% 最优解路线</span><br>pic_num = <span class="hljs-number">1</span>;<br><br><span class="hljs-comment">% 外层while循环控制降温过程，内层for循环控制新解的产生。</span><br><span class="hljs-keyword">while</span> temperature &gt; res<br>    Energy1=Energy_best;                             <span class="hljs-comment">% 用于控制循环的结束条件</span><br>    <span class="hljs-keyword">for</span> <span class="hljs-built_in">i</span> = <span class="hljs-number">1</span>: Markov_length<br>        <br>        <span class="hljs-comment">% 产生新解(对当前解添加扰动)</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">rand</span> &gt;<span class="hljs-number">0.5</span><br>            <span class="hljs-comment">% 两点交换</span><br>            a = <span class="hljs-number">0</span>;<br>            b = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">while</span> (a==b)<br>                a = <span class="hljs-built_in">ceil</span>(<span class="hljs-built_in">rand</span>*num_city);<br>                b = <span class="hljs-built_in">ceil</span>(<span class="hljs-built_in">rand</span>*num_city);<br>            <span class="hljs-keyword">end</span><br>            temp = route_new(a);<br>            route_new(a) = route_new(b);<br>            route_new(b) = temp;<br>        <span class="hljs-keyword">else</span><br>            <span class="hljs-comment">% 三变化</span><br>            <span class="hljs-built_in">factor</span> = randperm(num_city,<span class="hljs-number">3</span>);<br>            <span class="hljs-built_in">factor</span> = <span class="hljs-built_in">sort</span>(<span class="hljs-built_in">factor</span>);      <span class="hljs-comment">% 对三个元素排序，a&lt;b&lt;c</span><br>            a = <span class="hljs-built_in">factor</span>(<span class="hljs-number">1</span>);<br>            b = <span class="hljs-built_in">factor</span>(<span class="hljs-number">2</span>);<br>            c = <span class="hljs-built_in">factor</span>(<span class="hljs-number">3</span>);<br>            temp = route_new(a:b);<br>            route_new(a:a+c-b<span class="hljs-number">-1</span>) = route_new(b+<span class="hljs-number">1</span>:c);<br>            route_new(a+c-b:c) = temp;<br>        <span class="hljs-keyword">end</span><br>        <br>        Energy_new = <span class="hljs-number">0</span>;   <span class="hljs-comment">%计算该条路线的总距离</span><br>        <span class="hljs-keyword">for</span> <span class="hljs-built_in">j</span>=<span class="hljs-number">1</span>:num_city<span class="hljs-number">-1</span><br>            Energy_new = Energy_new + Distance_matrix(route_new(<span class="hljs-built_in">j</span>),route_new(<span class="hljs-built_in">j</span>+<span class="hljs-number">1</span>));<br>        <span class="hljs-keyword">end</span><br>        <span class="hljs-comment">% 回到起始点，加上首尾两个城市的距离</span><br>        Energy_new = Energy_new+Distance_matrix(route_new(<span class="hljs-number">1</span>),route_new(num_city));<br>        <br>        <br>        <span class="hljs-comment">% 按照Metroplis准则接收新解</span><br>        <span class="hljs-keyword">if</span> Energy_new&lt;Energy_current<br>            <span class="hljs-comment">% 更新局部最优</span><br>            Energy_current = Energy_new;<br>            route_current = route_new;<br>            <br>            <span class="hljs-comment">% 更新全局最优</span><br>            <span class="hljs-keyword">if</span> Energy_new&lt;Energy_best<br>                Energy_best=Energy_new;<br>                route_best = route_new;<br>            <span class="hljs-keyword">end</span><br>            <br>        <span class="hljs-keyword">else</span><br>            <span class="hljs-keyword">if</span> <span class="hljs-built_in">rand</span>&lt;<span class="hljs-built_in">exp</span>(-(Energy_new-Energy_current)/temperature)<br>                Energy_current = Energy_new;<br>                route_current = route_new;<br>            <span class="hljs-keyword">else</span><br>                route_new = route_current; <span class="hljs-comment">% 否则路线不更新，保存更改之前的路线</span><br>            <span class="hljs-keyword">end</span><br>            <br>        <span class="hljs-keyword">end</span><br>        <br>    <span class="hljs-keyword">end</span><br>    <br>    <span class="hljs-comment">%plots</span><br>    items = [route_new,route_new(<span class="hljs-number">1</span>)];                <span class="hljs-comment">% 从最后一个城市回到起始城市</span><br><br>    <span class="hljs-built_in">scatter</span>(data(route_new,<span class="hljs-number">1</span>),data(route_new,<span class="hljs-number">2</span>))<br>    <span class="hljs-keyword">for</span> <span class="hljs-built_in">i</span>=<span class="hljs-number">1</span>:<span class="hljs-built_in">length</span>(route_new)<br>        text(data(route_new(<span class="hljs-built_in">i</span>),<span class="hljs-number">1</span>),data(route_new(<span class="hljs-built_in">i</span>),<span class="hljs-number">2</span>),num2str(items(<span class="hljs-built_in">i</span>)))<br>    <span class="hljs-keyword">end</span><br>    <br>    <span class="hljs-built_in">hold</span> on<br>    <span class="hljs-built_in">plot</span>(data(items,<span class="hljs-number">1</span>),data(items,<span class="hljs-number">2</span>),<span class="hljs-string">&#x27;b-&#x27;</span>)<br>    text(<span class="hljs-number">1200</span>,<span class="hljs-number">1000</span>,[<span class="hljs-string">&#x27;Temp=&#x27;</span>,num2str(temperature)]);<br>    text(<span class="hljs-number">1200</span>,<span class="hljs-number">950</span>,[<span class="hljs-string">&#x27;Distance=&#x27;</span>,num2str(Energy_best)]);<br>    drawnow;<br>    F=getframe(gcf);<br>    I=frame2im(F);<br>    [I,map]=rgb2ind(I,<span class="hljs-number">256</span>);<br>    <span class="hljs-keyword">if</span> pic_num == <span class="hljs-number">1</span><br>        imwrite(I,map,<span class="hljs-string">&#x27;TSP.gif&#x27;</span>,<span class="hljs-string">&#x27;gif&#x27;</span>, <span class="hljs-string">&#x27;Loopcount&#x27;</span>,<span class="hljs-built_in">inf</span>,<span class="hljs-string">&#x27;DelayTime&#x27;</span>,<span class="hljs-number">2</span>);<br>    <span class="hljs-keyword">else</span><br>        imwrite(I,map,<span class="hljs-string">&#x27;TSP.gif&#x27;</span>,<span class="hljs-string">&#x27;gif&#x27;</span>,<span class="hljs-string">&#x27;WriteMode&#x27;</span>,<span class="hljs-string">&#x27;append&#x27;</span>,<span class="hljs-string">&#x27;DelayTime&#x27;</span>,<span class="hljs-number">2</span>);<br>    <span class="hljs-keyword">end</span><br>    <span class="hljs-built_in">hold</span> off<br>    title(<span class="hljs-string">&#x27;SA Algorithm for TSP problem&#x27;</span>)<br>    xlabel(<span class="hljs-string">&#x27;X coordinate&#x27;</span>)<br>    ylabel(<span class="hljs-string">&#x27;Y coordinate&#x27;</span>)<br>    pic_num = pic_num + <span class="hljs-number">1</span>;<br><br>    <span class="hljs-keyword">if</span> Energy1==Energy_best&amp;&amp;Energy_current==Energy_best<br>        <span class="hljs-keyword">break</span><br>    <span class="hljs-keyword">else</span><br>        temperature = temperature*ratio; <span class="hljs-comment">%降温过程</span><br>    <span class="hljs-keyword">end</span><br>    <br><span class="hljs-keyword">end</span><br><br><span class="hljs-comment">%Energy_best:最短路径；route_best:最短路径对应的最优距离（不唯一）</span><br><span class="hljs-built_in">disp</span>(<span class="hljs-string">&#x27;The best route is:&#x27;</span>);<span class="hljs-built_in">disp</span>([route_best,route_best(<span class="hljs-number">1</span>)])<br><span class="hljs-built_in">disp</span>([<span class="hljs-string">&#x27;The smallest distance:&#x27;</span>,num2str(<span class="hljs-built_in">round</span>(Energy_best,<span class="hljs-number">8</span>))]);<br></code></pre></td></tr></table></figure><p>其中一次运行结果：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">The</span> best route is:<br><br><span class="hljs-attribute">16</span> <span class="hljs-number">5</span> <span class="hljs-number">6</span> <span class="hljs-number">14</span> <span class="hljs-number">13</span> <span class="hljs-number">11</span> <span class="hljs-number">12</span> <span class="hljs-number">4</span> <span class="hljs-number">15</span> <span class="hljs-number">10</span> <span class="hljs-number">9</span> <span class="hljs-number">8</span> <span class="hljs-number">3</span> <span class="hljs-number">7</span> <span class="hljs-number">2</span> <span class="hljs-number">1</span> <span class="hljs-number">16</span><br><br><span class="hljs-attribute">The</span> smallest distance:<span class="hljs-number">5101</span>.<span class="hljs-number">7451</span><br></code></pre></td></tr></table></figure><p><img src="https://pic1.zhimg.com/v2-3edab6d7abd0c213520079f43a80bf70_b.webp" alt="动图"></p><p>​                                                                                             模拟退火算法搜索过程</p>]]></content>
    
    
    <categories>
      
      <category>数学建模</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数学建模</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>遗传算法</title>
    <link href="/2022/07/24/%E9%81%97%E4%BC%A0%E7%AE%97%E6%B3%95/"/>
    <url>/2022/07/24/%E9%81%97%E4%BC%A0%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h2 id="遗传算法-GA"><a href="#遗传算法-GA" class="headerlink" title="遗传算法(GA)"></a>遗传算法(GA)</h2><h3 id="1-简介"><a href="#1-简介" class="headerlink" title="1.简介"></a>1.简介</h3><p><strong>1.1 遗传算法的科学定义</strong></p><p>遗传算法（Genetic Algorithm, GA）是模拟达尔文生物进化论的自然选择和遗传学机理的生物进化过程的计算模型，是一种通过模拟自然进化过程搜索最优解的方法。</p><p>其主要特点是直接对结构对象进行操作，不存在求导和函数连续性的限定；具有内在的隐并行性和更好的全局寻优能力；采用概率化的寻优方法，不需要确定的规则就能自动获取和指导优化的搜索空间，自适应地调整搜索方向。</p><p><strong>1.2 遗传算法的执行过程</strong></p><p>遗传算法是从代表问题可能潜在的解集的一个种群（population）开始的，而一个种群则由经过基因（gene）编码的一定数目的个体(individual)组成。每个个体实际上是染色体(chromosome)带有特征的实体。</p><p>染色体作为遗传物质的主要载体，即多个基因的集合，其内部表现（即基因型）是某种基因组合，它决定了个体的形状的外部表现，如黑头发的特征是由染色体中控制这一特征的某种基因组合决定的。因此，在一开始需要实现从表现型到基因型的映射即编码工作。由于仿照基因编码的工作很复杂，我们往往进行简化，如二进制编码。</p><p>初代种群产生之后，按照适者生存和优胜劣汰的原理，逐代（generation）演化产生出越来越好的近似解，在每一代，根据问题域中个体的适应度（fitness）大小选择（selection）个体，并借助于自然遗传学的遗传算子（genetic operators）进行组合交叉（crossover）和变异（mutation），产生出代表新的解集的种群。</p><p>这个过程将导致种群像自然进化一样的后生代种群比前代更加适应于环境，末代种群中的最优个体经过解码（decoding），可以作为问题近似最优解。</p><p><strong>1.3 遗传算法过程图解</strong></p><p><img src="https://ask.qcloudimg.com/http-save/yehe-5385635/pnaqzpd7pb.jpeg?imageView2/2/w/1620" alt="img"></p><h3 id="2-相关生物学术语"><a href="#2-相关生物学术语" class="headerlink" title="2.相关生物学术语"></a>2.相关生物学术语</h3><p><strong>基因型(genotype)：</strong>性状染色体的内部表现。</p><p><strong>表现型(phenotype)：</strong>染色体决定的性状的外部表现，或者说，根据基因型形成的个体的外部表现。</p><p><strong>进化(evolution)：</strong>种群逐渐适应生存环境，品质不断得到改良。生物的进化是以种群的形式进行的。</p><p><strong>适应度(fitness)：</strong>度量某个物种对于生存环境的适应程度。</p><p><strong>选择(selection)：</strong>以一定的概率从种群中选择若干个个体。一般，选择过程是一种基于适应度的优胜劣汰的过程。</p><p><strong>复制(reproduction)：</strong>细胞分裂时，遗传物质DNA通过复制而转移到新产生的细胞中，新细胞就继承了旧细胞的基因。</p><p><strong>交叉(crossover)：</strong>两个染色体的某一相同位置处DNA被切断，前后两串分别交叉组合形成两个新的染色体。也称基因重组或杂交。</p><p><strong>变异(mutation)：</strong>复制时可能（很小的概率）产生某些复制差错，变异产生新的染色体，表现出新的性状。</p><p><strong>编码(coding)：</strong>DNA中遗传信息在一个长链上按一定的模式排列。遗传编码可看作从表现型到基因型的映射。</p><p><strong>解码(decoding)：</strong>基因型到表现型的映射。</p><p>**个体(individual):**指染色体带有特征的实体。</p><p>**种群(population:**个体的集合，该集合内个体数称为种群。</p><h3 id="3-问题分析：寻找函数的极值"><a href="#3-问题分析：寻找函数的极值" class="headerlink" title="3.问题分析：寻找函数的极值"></a>3.问题分析：寻找函数的极值</h3><p><img src="https://ask.qcloudimg.com/http-save/yehe-5385635/6ky4l4wdaw.jpeg?imageView2/2/w/1620" alt="img"></p><p><strong>3.1 一元函数最大值问题</strong></p><p>如上面的函数图像，现在我们要在既定的区间内找出函数的最大值。</p><p>从图像上具体表现为，极大值像是一座座山峰，极小值则是像一座座山谷。因此，我们也可以把遗传算法的过程看作是一个在多元函数里面求最优解的过程。</p><p>这些山峰对应着局部最优解，其中有一个山峰是海拔最高的，这个山峰则对应的是全局最优解。那么，遗传算法要做的就是尽量爬到最高峰，而不是困在较低的小山峰上。</p><p><strong>3.2 “袋鼠蹦跳”</strong></p><p>既然我们把函数曲线理解成一个一个山峰和山谷组成的山脉。那么我们可以设想所得到的每一个解就是一只袋鼠，我们希望它们不断的向着更高处跳去，直到跳到最高的山峰。所以求最大值的过程就转化成一个“袋鼠跳”的过程。</p><h3 id="4-实现过程"><a href="#4-实现过程" class="headerlink" title="4.实现过程"></a>4.实现过程</h3><p>遗传算法中每一条染色体，对应着遗传算法的一个解决方案，一般我们用适应性函数（fitness function）来衡量这个解决方案的优劣。所以从一个基因组到其解的适应度形成一个映射。遗传算法的实现过程实际上就像自然界的进化过程那样。</p><p>下面我们用袋鼠跳中的步骤一一对应解释，以方便大家理解：</p><p>(1) 首先寻找一种对问题潜在解进行“数字化”编码的方案。（建立表现型和基因型的映射关系）</p><p>(2) 随机初始化一个种群（那么第一批袋鼠就被随意地分散在山脉上），种群里面的个体就是这些数字化的编码。</p><p>(3) 接下来，通过适当的解码过程之后（得到袋鼠的位置坐标）。</p><p>(4) 用适应性函数对每一个基因个体作一次适应度评估（袋鼠爬得越高当然就越好，所以适应度相应越高）。</p><p>(5)用选择函数按照某种规定择优选择（每隔一段时间，射杀一些所在海拔较低的袋鼠，以保证袋鼠总体数目持平。）</p><p>(6) 让个体基因变异（让袋鼠随机地跳一跳）。</p><p>(7) 然后产生子代（希望存活下来的袋鼠是多产的，并在那里生儿育女）。</p><p>由此我们可以得出遗传算法的一般步骤：</p><p><em>(1) 随机产生种群。</em></p><p><em>(2) 根据策略判断个体的适应度，是否符合优化准则，若符合，输出最佳个体及其最优解，结束。否则，进行下一步。</em></p><p><em>(3) 依据适应度选择父母，适应度高的个体被选中的概率高，适应度低的个体被淘汰。</em></p><p><em>(4) 用父母的染色体按照一定的方法进行交叉，生成子代。</em></p><p><em>(5) 对子代染色体进行变异。</em></p><p>由交叉和变异产生新一代种群，返回步骤2，直到最优解产生。</p><h3 id="5-实现细节"><a href="#5-实现细节" class="headerlink" title="5.实现细节"></a>5.实现细节</h3><p><strong>5.1 编码</strong></p><p>编码是应用遗传算法时要解决的首要问题，也是设计遗传算法时的一个关键步骤。编码方法影响到交叉算子、变异算子等遗传算子的运算方法，很大程度上决定了遗传进化的效率。</p><p><strong>5.1.1 二进制编码法</strong></p><p>就像人类的基因有AGCT 4种碱基序列一样。在这里我们只用了0和1两种碱基,然后将它们串成一条链形成染色体。一个位能表示出2种状态的信息量，因此足够长的二进制染色体便能表示所有的特征。这便是二进制编码。如下：</p><p>1110001010111</p><p>它由二进制符号0和1所组成的二值符号集。它有以下一些优点：</p><p>(1) 编码、解码操作简单易行</p><p>(2) 交叉、变异等遗传操作便于实现</p><p>(3)合最小字符集编码原则</p><p>(4) 利用模式定理对算法进行理论分析</p><p><strong>5.1.2 浮点编码法</strong></p><p>二进制编码虽然简单直观，一目了然。但是存在着连续函数离散化时的映射误差。个体长度较短时，可能达不到精度要求，而个体编码长度较长时，虽然能提高精度，但增加了解码的难度，使遗传算法的搜索空间急剧扩大。</p><p>所谓浮点法，是指个体的每个基因值用某一范围内的一个浮点数来表示。在浮点数编码方法中，必须保证基因值在给定的区间限制范围内，遗传算法中所使用的交叉、变异等遗传算子也必须保证其运算结果所产生的新个体的基因值也在这个区间限制范围内。如下所示：</p><p>1.2-3.2-5.3-7.2-1.4-9.7</p><p>浮点数编码方法有下面几个优点：</p><p>(1) 适用于在遗传算法中表示范围较大的数。</p><p>(2)适用于精度要求较高的遗传算法。</p><p>(3) 便于较大空间的遗传搜索。</p><p>(4) 改善了遗传算法的计算复杂性，提高了运算交率。</p><p>(5) 便于遗传算法与经典优化方法的混合使用。</p><p>(6) 便于设计针对问题的专门知识的知识型遗传算子。</p><p>(7) 便于处理复杂的决策变量约束条件。</p><p><strong>5.1.3 符号编码法</strong></p><p>符号编码法是指个体染色体编码串中的基因值取自一个无数值含义、而只有代码含义的符号集如｛A,B,C…｝。</p><p>符号编码的主要优点是：</p><p>(1)符合有意义积术块编码原则。</p><p>(2) 便于在遗传算法中利用所求解问题的专门知识。</p><p>(3) 便于遗传算法与相关近似算法之间的混合使用。</p><p><strong>5.2 为我们的袋鼠染色体编码</strong></p><p>首先：编码就是建立从基因型到表现型的映射关系。这里的表现型可以理解为个体特征。那么，在此问题下，我们关心的个体特征就是：袋鼠的位置坐标。只要知道了袋鼠的位置坐标（位置坐标就是相应的染色体编码，可以通过解码得出），我们就可以：</p><p>(1)在喜马拉雅山脉的地图上找到相应的位置坐标，算出海拔高度。（相当于通过自变量求得适应函数的值）然后判读该不该射杀该袋鼠。</p><p>(2)可以知道染色体交叉和变异后袋鼠新的位置坐标。</p><p>袋鼠的位置坐标可以比喻为区间[-1, 2]的某一个x坐标（有了x坐标，再通过函数表达式可以算出函数值 &lt;&#x3D;&#x3D;&gt; 得到了袋鼠染色体编码，解码得到位置坐标，在喜马拉雅山脉地图查询位置坐标算出海拔高度）。这个x坐标是一个实数，现在，就是怎么对这个x坐标进行编码。下面我们以二进制编码为例讲解。</p><p>我们说过，一定长度的二进制编码序列，只能表示一定精度的浮点数。在这里假如我们要求解精确到六位小数，由于区间长度为2 - (-1) &#x3D; 3 ,为了保证精度要求，至少把区间[-1,2]分为3 × 10^6等份。又因为</p><p>2^21 &#x3D; 2097152 &lt; 3*10^6 &lt; 2^22 &#x3D; 4194304</p><p>所以编码的二进制串至少需要22位。</p><p>把一个二进制串(b0,b1,….bn)转化为区间里面对应的实数值可以通过下面两个步骤：</p><p>（1）将一个二进制串代表的二进制数转化为10进制数：</p><p><img src="https://ask.qcloudimg.com/http-save/yehe-5385635/8s22j1i2xt.png?imageView2/2/w/1620" alt="img"></p><p>（2）对应区间内的实数：</p><p><img src="https://ask.qcloudimg.com/http-save/yehe-5385635/dlpg331w0f.png?imageView2/2/w/1620" alt="img"></p><p>例如一个二进制串(1000101110110101000111)通过上面换算以后，表示实数值0.637197。</p><p><strong>5.3 评价个体的适应度</strong></p><p>前面说了，适应度函数主要是通过个体特征从而判断个体的适应度。在本例的袋鼠跳中，我们只关心袋鼠的海拔高度，以此来判断是否该射杀该袋鼠。这样一来，该函数就非常简单了。只要输入袋鼠的位置坐标，在通过相应查找运算，返回袋鼠当前位置的海拔高度就行。</p><p>适应度函数也称评价函数，是根据目标函数确定的用于区分群体中个体好坏的标准。适应度函数总是非负的，而目标函数可能有正有负，故需要在目标函数与适应度函数之间进行变换。</p><p>评价个体适应度的一般过程为：</p><p><em>1. 对个体编码串进行解码处理后，可得到个体的表现型。</em></p><p><em>2. 由个体的表现型可计算出对应个体的目标函数值。</em></p><p><em>3. 根据最优化问题的类型，由目标函数值按一定的转换规则求出个体的适应度。</em></p><p><strong>5.4 射杀一些袋鼠</strong></p><p>遗传算法中的选择操作就是用来确定如何从父代群体中按某种方法选取那些个体，以便遗传到下一代群体。选择操作用来确定重组或交叉个体，以及被选个体将产生多少个子代个体。前面说了，我们希望海拔高的袋鼠存活下来，并尽可能繁衍更多的后代。但我们都知道，在自然界中，适应度高的袋鼠越能繁衍后代，但这也是从概率上说的而已。毕竟有些适应度低的袋鼠也可能逃过我们的眼睛。</p><p><strong>几种常用的选择算子：</strong></p><p><strong>1. 轮盘赌选择（Roulette Wheel Selection）：</strong>是一种回放式随机采样方法。每个个体进入下一代的概率等于它的适应度值与整个种群中个体适应度值和的比例。选择误差较大。</p><p><strong>2. 随机竞争选择（Stochastic Tournament）：</strong>每次按轮盘赌选择一对个体，然后让这两个个体进行竞争，适应度高的被选中，如此反复，直到选满为止。</p><p><strong>3. 最佳保留选择：</strong>首先按轮盘赌选择方法执行遗传算法的选择操作，然后将当前群体中适应度最高的个体结构完整地复制到下一代群体中。</p><p><strong>4. 无回放随机选择（也叫期望值选择Excepted Value Selection）：</strong>根据每个个体在下一代群体中的生存期望来进行随机选择运算。方法如下:</p><p>   （1） 计算群体中每个个体在下一代群体中的生存期望数目N。</p><p>   （2） 若某一个体被选中参与交叉运算，则它在下一代中的生存期望数目减去 0.5，若某一个体未   被选中参与交叉运算，则它在下一代中的生存期望数目减去1.0。</p><p>   （3） 随着选择过程的进行，若某一个体的生存期望数目小于0时，则该个体就不再有机会被选中。</p><p><strong>5. 确定式选择：</strong>按照一种确定的方式来进行选择操作。具体操作过程如下：</p><p>   （1） 计算群体中各个个体在下一代群体中的期望生存数目N。</p><p>   （2） 用N的整数部分确定各个对应个体在下一代群体中的生存数目。</p><p>   （3） 用N的小数部分对个体进行降序排列，顺序取前M个个体加入到下一代群体中。至此可完全确定出下一代群体中Ｍ个个体。</p><p><strong>6. 无回放余数随机选择：</strong>可确保适应度比平均适应度大的一些个体能够被遗传到下一代群体中，因而选择误差比较小。</p><p><strong>7. 均匀排序：</strong>对群体中的所有个体按期适应度大小进行排序，基于这个排序来分配各个个体被选中的概率。</p><p><strong>8. 最佳保存策略：</strong>当前群体中适应度最高的个体不参与交叉运算和变异运算，而是用它来代替掉本代群体中经过交叉、变异等操作后所产生的适应度最低的个体。</p><p><strong>9. 随机联赛选择：</strong>每次选取几个个体中适应度最高的一个个体遗传到下一代群体中。</p><p><strong>10. 排挤选择：</strong>新生成的子代将代替或排挤相似的旧父代个体，提高群体的多样性。</p><p><strong>5.5 遗传–染色体交叉(crossover)</strong></p><p><strong>遗传算法的交叉操作，是指对两个相互配对的染色体按某种方式相互交换其部分基因，从而形成两个新的个体。</strong></p><p>适用于二进制编码个体或浮点数编码个体的交叉算子：</p><p><strong>1. 单点交叉（One-point Crossover）：</strong>指在个体编码串中只随机设置一个交叉点，然后再该点相互交换两个配对个体的部分染色体。</p><p><strong>2. 两点交叉与多点交叉：</strong></p><p>   (1) 两点交叉（Two-point Crossover）：在个体编码串中随机设置了两个交叉点，然后再进行部分基因交换。</p><p>   (2) 多点交叉（Multi-point Crossover）</p><p><strong>3. 均匀交叉（也称一致交叉，Uniform Crossover）：</strong>两个配对个体的每个基因座上的基因都以相同的交叉概率进行交换，从而形成两个新个体。</p><p><strong>4. 算术交叉（Arithmetic Crossover）：</strong>由两个个体的线性组合而产生出两个新的个体。该操作对象一般是由浮点数编码表示的个体。</p><p>咳咳，根据国际惯例。还是抓一个最简单的二进制单点交叉为例来给大家讲解讲解。</p><p>二进制编码的染色体交叉过程非常类似高中生物中所讲的同源染色体的联会过程――随机把其中几个位于同一位置的编码进行交换，产生新的个体。</p><p><img src="https://ask.qcloudimg.com/http-save/yehe-5385635/zbxxm7sthu.jpeg?imageView2/2/w/1620" alt="img"></p><p>对应的二进制交叉：</p><p><img src="https://ask.qcloudimg.com/http-save/yehe-5385635/ohtcsbd1ui.jpeg?imageView2/2/w/1620" alt="img"></p><p><strong>5.6 变异–基因突变(Mutation)</strong></p><p><strong>遗传算法中的变异运算，是指将个体染色体编码串中的某些基因座上的基因值用该基因座上的其它等位基因来替换，从而形成新的个体。</strong></p><p>例如下面这串二进制编码：</p><p><strong>101101001011001</strong></p><p>经过基因突变后，可能变成以下这串新的编码：</p><p><strong>001101011011001</strong></p><p>以下变异算子适用于二进制编码和浮点数编码的个体：</p><p><strong>1. 基本位变异（Simple Mutation）：</strong>对个体编码串中以变异概率、随机指定的某一位或某几位仅因座上的值做变异运算。</p><p><strong>2. 均匀变异（Uniform Mutation）：</strong>分别用符合某一范围内均匀分布的随机数，以某一较小的概率来替换个体编码串中各个基因座上的原有基因值。（特别适用于在算法的初级运行阶段）</p><p><strong>3. 边界变异（Boundary Mutation）：</strong>随机的取基因座上的两个对应边界基因值之一去替代原有基因值。特别适用于最优点位于或接近于可行解的边界时的一类问题。</p><p><strong>4. 非均匀变异：</strong>对原有的基因值做一随机扰动，以扰动后的结果作为变异后的新基因值。对每个基因座都以相同的概率进行变异运算之后，相当于整个解向量在解空间中作了一次轻微的变动。</p><p><strong>5. 高斯近似变异：</strong>进行变异操作时用符号均值为Ｐ的平均值，方差为P**2的正态分布的一个随机数来替换原有的基因值。</p><h3 id="六-应用实例"><a href="#六-应用实例" class="headerlink" title="六.应用实例"></a>六.应用实例</h3><p><strong>问题：寻找下面函数在[0,20]的最大值。</strong></p><p><img src="https://ask.qcloudimg.com/http-save/yehe-4152297/ifjwzg9lrk.png?imageView2/2/w/1620" alt="img"></p><p><strong>6.1实现步骤：</strong></p><p><strong>基因编码</strong>：我们用20位的二进制来表示[0,20]，相邻两个值之间的跳跃值为：</p><p>20&#x2F;（2^20) ≈0.000002</p><p><strong>选择遗传个体</strong>：轮盘赌选择</p><p><strong>6.2 结果</strong></p><p>我们可以看到函数在[0,20]区域内大约在X &#x3D; 19的位置取得最大值，我们用遗传算法来求解。</p><p><img src="https://ask.qcloudimg.com/http-save/yehe-4152297/vph5mnd7rl.png?imageView2/2/w/1620" alt="img"></p><p>可以看到，大约在11代的时候就能找到最优解，可见遗传算法的强大之处。</p><p><img src="https://ask.qcloudimg.com/http-save/yehe-4152297/1v5d5t9iu4.png?imageView2/2/w/1620" alt="img"></p><p><strong>源代码</strong></p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><code class="hljs matlab">clc,clear<br>N = <span class="hljs-number">50</span>;<br>L = <span class="hljs-number">20</span>;<br>pc =<span class="hljs-number">0.8</span>;<br>pm =<span class="hljs-number">0.1</span>;<br>g =<span class="hljs-number">100</span>;<br>xs =<span class="hljs-number">20</span>;<br>xx =<span class="hljs-number">0</span>;<br>f = <span class="hljs-built_in">round</span>(<span class="hljs-built_in">rand</span>(N,L));<br><span class="hljs-keyword">for</span> k =<span class="hljs-number">1</span>:g<br>    <span class="hljs-keyword">for</span> <span class="hljs-built_in">i</span> = <span class="hljs-number">1</span>:N<br>        u =f (<span class="hljs-built_in">i</span>,:);<br>        m = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> <span class="hljs-built_in">j</span> =<span class="hljs-number">1</span>:L<br>            m = u(<span class="hljs-built_in">j</span>)*<span class="hljs-number">2</span>^(<span class="hljs-built_in">j</span><span class="hljs-number">-1</span>)+m;<br>        <span class="hljs-keyword">end</span><br>        x(<span class="hljs-built_in">i</span>) = xx + m*(xs-xx)/(<span class="hljs-number">2</span>^L<span class="hljs-number">-1</span>);<br>        fit(<span class="hljs-built_in">i</span>) = func1(x(<span class="hljs-built_in">i</span>));<br>    <span class="hljs-keyword">end</span><br>    maxfit = <span class="hljs-built_in">max</span>(fit);<br>    minfit = <span class="hljs-built_in">min</span>(fit);<br>    rr = <span class="hljs-built_in">find</span>(fit==maxfit);<br>    fbest = f(rr(<span class="hljs-number">1</span>,<span class="hljs-number">1</span>),:);<br>    xbest = x(rr(<span class="hljs-number">1</span>,<span class="hljs-number">1</span>));<br>    fit = (fit-minfit)/(maxfit-minfit);<br><br>    <span class="hljs-comment">%轮盘赌赋值操作</span><br>    sum_fit = sum(fit);<br>    fitvaule  = fit./sum_fit;<br>    fitvaule = cumsum(fitvaule);<br>    ms = <span class="hljs-built_in">sort</span>(<span class="hljs-built_in">rand</span>(N,<span class="hljs-number">1</span>));<br>    fiti = <span class="hljs-number">1</span>;<br>    newi = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span> newi &lt;= N<br>        <span class="hljs-keyword">if</span> (ms(newi)) &lt; fitvaule(fiti)<br>            nf(newi,:) = f(fiti,:);<br>            newi = newi +<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">else</span><br>            fiti = fiti +<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">end</span><br>    <span class="hljs-keyword">end</span><br><br>    <span class="hljs-comment">%概率交差操作</span><br>    <span class="hljs-keyword">for</span> <span class="hljs-built_in">i</span> = <span class="hljs-number">1</span>:<span class="hljs-number">2</span>:N   <span class="hljs-comment">%选择两个优秀个体</span><br>        p = <span class="hljs-built_in">rand</span>;<br>        <span class="hljs-keyword">if</span> p &lt;pc<br>            q = <span class="hljs-built_in">round</span>(<span class="hljs-built_in">rand</span>(<span class="hljs-number">1</span>,L));<br>            <span class="hljs-keyword">for</span> <span class="hljs-built_in">j</span> =<span class="hljs-number">1</span>:L<br>                <span class="hljs-keyword">if</span> q(<span class="hljs-built_in">j</span>) == <span class="hljs-number">1</span><br>                    temp = nf(<span class="hljs-built_in">i</span>+<span class="hljs-number">1</span>,<span class="hljs-built_in">j</span>);<br>                    nf(<span class="hljs-built_in">i</span>+<span class="hljs-number">1</span>,<span class="hljs-built_in">j</span>) = nf(<span class="hljs-built_in">i</span>,<span class="hljs-built_in">j</span>);<br>                    nf(<span class="hljs-built_in">i</span>,<span class="hljs-built_in">j</span>) = temp;<br>                <span class="hljs-keyword">end</span><br>            <span class="hljs-keyword">end</span><br>        <span class="hljs-keyword">end</span><br>    <span class="hljs-keyword">end</span><br><br>    <span class="hljs-comment">%变异操作</span><br>    <span class="hljs-built_in">i</span> =<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span> <span class="hljs-built_in">i</span> &lt;= <span class="hljs-built_in">round</span>(N*pm)<br>        h = randi(N);<br>        <span class="hljs-keyword">for</span> <span class="hljs-built_in">j</span> = <span class="hljs-number">1</span>:<span class="hljs-built_in">round</span>(L*pm)<br>            g = randi(L);<br>            nf(h,g) = ~nf(h,g);<br>        <span class="hljs-keyword">end</span><br>        <span class="hljs-built_in">i</span> = <span class="hljs-built_in">i</span>+<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">end</span><br><br>    f = nf;<br>    f(<span class="hljs-number">1</span>,:) =fbest;<br>    value(k) = maxfit;<br><span class="hljs-keyword">end</span><br>xbest;<br>xx = <span class="hljs-number">0</span>:<span class="hljs-number">0.1</span>:<span class="hljs-number">20</span>;<br>y =  <span class="hljs-built_in">sin</span>(<span class="hljs-number">2</span>*xx)+<span class="hljs-built_in">cos</span>(<span class="hljs-number">3</span>*xx)+xx;<br><span class="hljs-built_in">figure</span><br><span class="hljs-built_in">plot</span>(xx,y)<br><span class="hljs-built_in">figure</span><br><span class="hljs-built_in">plot</span>(value)<br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">result</span> = <span class="hljs-title">func1</span><span class="hljs-params">(x)</span></span><br>fit = <span class="hljs-built_in">sin</span>(<span class="hljs-number">2</span>*x)+<span class="hljs-built_in">cos</span>(<span class="hljs-number">3</span>*x)+x;<br>result = fit;<br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>数学建模</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数学建模</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>粒子群算法</title>
    <link href="/2022/07/24/%E7%B2%92%E5%AD%90%E7%BE%A4%E7%AE%97%E6%B3%95/"/>
    <url>/2022/07/24/%E7%B2%92%E5%AD%90%E7%BE%A4%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h2 id="粒子群算法-PSO"><a href="#粒子群算法-PSO" class="headerlink" title="粒子群算法(PSO)"></a>粒子群算法(PSO)</h2><h3 id="1-简介"><a href="#1-简介" class="headerlink" title="1.简介"></a>1.简介</h3><p>1995年，美国学者Kennedy和Eberhart共同提出了粒子群算法，其基本思想源于对鸟类群体行为进行建模与仿真的研究结果的启发。</p><p>粒子群优化算法(PSO：Particle swarm optimization) 是一种进化计算技术，源于对鸟群捕食的行为研究。它的核心思想是利用群体中的个体对信息的共享使整个群体的运动在问题求解空间中产生从无序到有序的演化过程，从而获得问题的可行解。</p><p>PSO的优势在于简单容易实现并且没有许多参数的调节。目前已被广泛应用于函数优化、神经网络训练、模糊系统控制以及其他遗传算法的应用领域。</p><p>现在我们赋予鸟儿一些参数：</p><ul><li><img src="https://www.zhihu.com/equation?tex=C_1" alt="[公式]">：个体学习因子，也称为个体加速因子。这个因子越大，鸟儿越倾向于飞往它自己曾去的食物量最多的地方</li><li><img src="https://www.zhihu.com/equation?tex=C_2" alt="[公式]">：社会学系因子，也成为社会加速因子。这个因子越大，鸟儿越倾向于飞往其他鸟儿（同伴们）曾去的食物量最多的地方</li><li><img src="https://www.zhihu.com/equation?tex=r_1,r_2" alt="[公式]">：[0,1]上的随机数。随机代表着鸟儿比较佛系，他也不知道飞哪里</li><li><img src="https://www.zhihu.com/equation?tex=w" alt="[公式]">：惯性权重，也叫惯性系数，这个数越大，代表着它不容易更改之前的运动路线，更倾向于探索未知领域。</li></ul><p>因此图像变成了这样：</p><p><img src="https://pic3.zhimg.com/80/v2-00bc7215612d405a1b4b1d09270eaaee_720w.png" alt="img"></p><p>因此这只鸟第<img src="https://www.zhihu.com/equation?tex=d" alt="[公式]">步所在的位置&#x3D;第<img src="https://www.zhihu.com/equation?tex=d-1" alt="[公式]">步所在的位置+第<img src="https://www.zhihu.com/equation?tex=d-1" alt="[公式]">步所在的位置*运动的时间(每一步运动的时间t一般取1) <img src="https://www.zhihu.com/equation?tex=x%5Cleft(+d+%5Cright)+=x%5Cleft(+d-1+%5Cright)++v%5Cleft(+d-1+%5Cright)+%5Ccdot+t%5C%5C" alt="[公式]"></p><p>这只鸟第<img src="https://www.zhihu.com/equation?tex=d" alt="[公式]">步的速度&#x3D;上一步自身的速度惯性+自我认知部分+社会认知部分</p><p><img src="https://www.zhihu.com/equation?tex=v(d)=w%5Ccdot+v(d-1)+C_1%5Ccdot+r_1%5Ccdot+(pbest(d)-x(d))+C_2%5Ccdot+r_2%5Ccdot+(gbest(d)-x(d))+%5C%5C" alt="[公式]"></p><p>每运动一次，位置P和Q都会不断发生变化，最后会收敛到一个位置，这个位置就是食物最多的一个位置，如下动图所示：</p><p><img src="https://pic3.zhimg.com/v2-aae3067a40396e9c98bf531c606b299e_b.webp" alt="动图"></p><h3 id="2-基本概念"><a href="#2-基本概念" class="headerlink" title="2.基本概念"></a>2.基本概念</h3><p>​        每只鸟在某处位置能够找到食物的可能可以通过适应值来刻画，每只鸟能够记住自己的觅食位置，并且找到其中的最佳位置<strong>（</strong>局部最优，相当于极值点），鸟群中所有个体的最佳位置就可以看做整个鸟群的最佳觅食点（全局最优，相当于最值点）。可以预见的是，整个鸟群的觅食活动总体上一定是往这个全局最优的觅食区域运动的，通过鸟群觅食位置的不断移动即不断地迭代，速度的不断更新，鸟群往该最优位置步步逼近。</p><ul><li>粒子：优化问题的候选解</li><li>位置：候选解所在的位置</li><li>速度：候选解移动的速度</li><li>适应度：评价粒子优劣的值，一般设置为目标函数值</li><li>个体最佳位置：单个粒子迄今为止找到的最佳位置</li><li>群体最佳位置：所有粒子迄今为止找到的最佳位置</li></ul><h3 id="3-算法流程"><a href="#3-算法流程" class="headerlink" title="3.算法流程"></a>3.算法流程</h3><p>流程图如下：</p><p><img src="https://pic2.zhimg.com/80/v2-33c5b580dcf13f4aa9dceffedeb84075_720w.png" alt="img"></p><p>​    1.初始化粒子群。包括粒子的初始位置及速度，惯性因子等参数值</p><p>粒子数M一般选取20~40个，不过对于一些特殊的难题需要更多的粒子，粒子数量越多，搜索范围就越广，越容易找到全局最优解，但是也会带来更大的计算消耗。</p><ol start="2"><li><p>评价各个粒子的初始适应值。</p></li><li><p>将初始的适应值作为各个粒子的局部最优解，保存各粒子的最优位置。并找到其中的最优值，作为全局最优解的初值，并记录其位置</p></li><li><p>更新粒子速度及位置</p></li><li><p>计算更新后粒子的适应值，更新每个粒子的局部最优值以及整个粒子群的全局最优值。</p></li><li><p>重复4~5直至满足迭代结束条件</p></li></ol><p>粒子群算法中的符号说明：</p><ul><li><img src="https://www.zhihu.com/equation?tex=n" alt="[公式]"> ：粒子个数</li><li><img src="https://www.zhihu.com/equation?tex=c_1" alt="[公式]"> ：粒子的个体学习因子，也称为个体加速因子</li><li><img src="https://www.zhihu.com/equation?tex=c_2" alt="[公式]"> ：粒子的社会学习因子，也称为社会加速因子</li><li><img src="https://www.zhihu.com/equation?tex=w" alt="[公式]"> ：速度的惯性权重</li><li><img src="https://www.zhihu.com/equation?tex=v_%7Bi%7D%5E%7Bd%7D" alt="[公式]"> ：第d次迭代时，第i个粒子的速度</li><li><img src="https://www.zhihu.com/equation?tex=x_%7Bi%7D%5E%7Bd%7D" alt="[公式]"> ：第d次迭代时，第i个粒子所在的位置</li><li><img src="https://www.zhihu.com/equation?tex=f%5Cleft(+x+%5Cright)+" alt="[公式]"> ：在位置x时的适应度值(一般取目标函数值)</li><li><img src="https://www.zhihu.com/equation?tex=pbest_%7Bi%7D%5E%7Bd%7D" alt="[公式]"> ：到第d次迭代为止，第i个粒子经过的最好的位置</li><li><img src="https://www.zhihu.com/equation?tex=gbest%5Ed" alt="[公式]"> ：到第d次迭代为止，所有粒子经过的最好的位置</li></ul><h3 id="4-核心公式："><a href="#4-核心公式：" class="headerlink" title="4.核心公式："></a>4.核心公式：</h3><p>粒子群算法最主要是掌握以下公式： 这只鸟第<img src="https://www.zhihu.com/equation?tex=d" alt="[公式]">步的速度&#x3D;上一步自身的速度惯性+自我认知部分+社会认知部分 <img src="https://www.zhihu.com/equation?tex=v_%7Bi%7D%5E%7Bd%7D=wv_%7Bi%7D%5E%7Bd-1%7D+c_1r_1(pbest_%7Bi%7D%5E%7Bd%7D-x_%7Bi%7D%5E%7Bd%7D)+c_2r_2(gbest%5Ed-x_%7Bi%7D%5E%7Bd%7D)%5C%5C" alt="[公式]"></p><p>这只鸟第<img src="https://www.zhihu.com/equation?tex=d+1" alt="[公式]">步所在的位置&#x3D;第<img src="https://www.zhihu.com/equation?tex=d" alt="[公式]">步所在的位置+第<img src="https://www.zhihu.com/equation?tex=d" alt="[公式]">步所在的位置*运动的时间(每一步运动的时间t一般取1) <img src="https://www.zhihu.com/equation?tex=x_%7Bi%7D%5E%7Bd+1%7D=x_%7Bi%7D%5E%7Bd%7D+v_%7Bi%7D%5E%7Bd%7D%5C%5C" alt="[公式]"></p><h3 id="5-重要参数"><a href="#5-重要参数" class="headerlink" title="5.重要参数"></a>5.重要参数</h3><p><strong>5.1学习因子</strong></p><p><img src="https://www.zhihu.com/equation?tex=v_%7Bi%7D%5E%7Bd%7D=wv_%7Bi%7D%5E%7Bd-1%7D+%5Cboldsymbol%7Bc%7D_1r_1(pbest_%7Bi%7D%5E%7Bd%7D-x_%7Bi%7D%5E%7Bd%7D)+%5Cboldsymbol%7Bc%7D_2r_2(gbest%5Ed-x_%7Bi%7D%5E%7Bd%7D)+%5C%5C" alt="[公式]"></p><p>在最初提出粒子群算法的论文中指出，个体学习因子和社会学习因子取2比较合适。</p><p>学习因子也是非负常数，是调整局部最优值和全局最优值权重的参数，如果前者为0说明搜寻过程中没有自身经验只有社会经验，容易陷入局部最优解；若后者为0，即只有社会经验，没有自身经验，常常会陷入局部最优解中，不能飞越该局部最优区域。</p><p><strong>5.2惯性权重</strong></p><p><img src="https://www.zhihu.com/equation?tex=v_%7Bi%7D%5E%7Bd%7D=%5Cboldsymbol%7Bw%7Dv_%7Bi%7D%5E%7Bd-1%7D+c_1r_1(pbest_%7Bi%7D%5E%7Bd%7D-x_%7Bi%7D%5E%7Bd%7D)+c_2r_2(gbest%5Ed-x_%7Bi%7D%5E%7Bd%7D)+%5C%5C" alt="[公式]"></p><p>对算法的收敛起到很大的作用，其值越大，粒子飞跃的范围就越广，更容易找到全局最优，但是也会错失局部搜寻的能力。</p><p>一般来说惯性权重取0.9‐1.2是比较合适的，一般取0.9就行。</p><p><strong>5.3种群数量</strong></p><p>粒子群算法的最大特点就是速度快，因此初始种群取<strong>50-1000</strong>都是可以的，虽然初始种群越大收敛性会更好，不过太大了也会影响速度；</p><p><strong>5.4 迭代次数</strong></p><p>一般取100~4000，太少解不稳定，太多浪费时间。对于复杂问题，进化代数可以相应地提高；</p><p><strong>5.5 空间维数</strong></p><p>粒子搜索的空间维数即为自变量的个数。比如求一元函数的最值就是一维空间，n元函数的最值就是n维空间</p><p><strong>5.6 位置限制</strong></p><p>限制粒子搜索的空间，即自变量的取值范围，对于无约束问题此处可以省略。</p><p><strong>5.7 速度限制</strong></p><p>如果粒子飞行速度过快，很可能直接飞过最优解位置，但是如果飞行速度过慢，会使得收敛速度变慢，因此设置合理的速度限制就很有必要了。</p><h3 id="6-代码实现"><a href="#6-代码实现" class="headerlink" title="6.代码实现"></a>6.代码实现</h3><p><strong>6.1基于numpy</strong></p><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs maxima">import numpy as <span class="hljs-built_in">np</span> <br>import <span class="hljs-built_in">random</span> <br><br># pso  <br>def suit(x):<br>    x1, x2=x<br>    <span class="hljs-built_in">return</span> -(x1-<span class="hljs-number">10</span>) ** <span class="hljs-number">2</span> + -(x2 - <span class="hljs-number">3</span>) ** <span class="hljs-number">2</span>  # + -x3 ** <span class="hljs-number">2</span><br><br>def best_p(current_p,person_best): #  <br>    x = <span class="hljs-built_in">np</span>.zeros_like(current_p) <br>    n,d = current_p.shape<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):# 每个粒子比较一次<br>        a = current_p[i]<br>        b = person_best[i]<br>        <span class="hljs-keyword">if</span> suit(b)&gt;suit(a):<br>            x[i] = b<br>        <span class="hljs-keyword">else</span>: x[i]= a<br>    <span class="hljs-built_in">return</span> x <br>        <br>def global_b(person_best): # n*d <br>    n,d= person_best.shape <br>    s = []<br>    <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):<br>        s.<span class="hljs-built_in">append</span>(suit(person_best[j]))        <br>    i = <span class="hljs-built_in">np</span>.<span class="hljs-built_in">array</span>(s).argmax()<br>    x = <span class="hljs-built_in">np</span>.<span class="hljs-built_in">array</span>(person_best[i])<br>    <span class="hljs-built_in">return</span> x         <br># init  <br>n = <span class="hljs-number">40</span> # 粒子个数<br>d = <span class="hljs-number">2</span><br>current_v =  <span class="hljs-built_in">np</span>.<span class="hljs-built_in">array</span>([[<span class="hljs-built_in">random</span>.randint(<span class="hljs-number">1</span>, <span class="hljs-number">100</span>) <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n)]]).reshape(-<span class="hljs-number">1</span>,d)<br>current_p = <span class="hljs-built_in">np</span>.<span class="hljs-built_in">array</span>([[<span class="hljs-built_in">random</span>.randint(<span class="hljs-number">1</span>, <span class="hljs-number">100</span>) <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n)]]).reshape(-<span class="hljs-number">1</span>,d)<br>person_best = current_p<br>global_best = global_b(person_best)  <br>T = <span class="hljs-number">0</span>   <br>w=<span class="hljs-number">1</span>   <br><span class="hljs-keyword">while</span>  T&lt;<span class="hljs-number">100000</span>:        <br>    # <span class="hljs-keyword">if</span>  all([current_p[i][<span class="hljs-number">0</span>]==current_p[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(len(current_p))]):<br>    #     <span class="hljs-built_in">print</span>(T,current_p)<br>    #     <span class="hljs-built_in">break</span><br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">sum</span>(person_best.<span class="hljs-built_in">std</span>(axis=<span class="hljs-number">0</span>))&lt;.<span class="hljs-number">1</span>:<br>        <span class="hljs-built_in">break</span>        <br>    <span class="hljs-keyword">else</span>:    <br>        w = w*<span class="hljs-number">0.99996</span>;r1 = <span class="hljs-built_in">random</span>.<span class="hljs-built_in">random</span>(); r2 = <span class="hljs-built_in">random</span>.<span class="hljs-built_in">random</span>()<br>        current_v = w*current_v + r1*(person_best-current_p)+ r1*(global_best - current_p)<br>        #  w = w*<span class="hljs-number">0.999</span><br>        # current_v = w*current_v +(person_best-current_p)+(global_best - current_p)<br>        current_p = current_p + current_v<br>        person_best =  best_p(current_p, person_best)<br>        global_best = global_b(person_best) <br>        #current_v = current_v + <span class="hljs-number">2</span>* (person_best- current_p)+<span class="hljs-number">2</span>*(global_best- current_p)<br>        T+=<span class="hljs-number">1</span> <br><span class="hljs-built_in">print</span>(T, person_best)<br></code></pre></td></tr></table></figure><p><strong>6.2 基于sko.pso</strong></p><p>python sko库中包含了常用的启发式算法， 也包含粒子群算法PSO,可以直接调用,非常快捷方便 。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> sko.PSO <span class="hljs-keyword">import</span> PSO<br><span class="hljs-keyword">def</span> <span class="hljs-title function_">demo_func</span>(<span class="hljs-params">x</span>):<br>    x1, x2, x3 = x<br>    <span class="hljs-keyword">return</span> (x1-<span class="hljs-number">5</span>) ** <span class="hljs-number">2</span> + (x2 - <span class="hljs-number">2</span>) ** <span class="hljs-number">2</span> + (x3-<span class="hljs-number">19</span>) ** <span class="hljs-number">2</span><br>pso = PSO(func=demo_func, dim=<span class="hljs-number">3</span>)<br>fitness = pso.fit()<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;best_x is &#x27;</span>, pso.gbest_x, <span class="hljs-string">&#x27;best_y is&#x27;</span>, pso.gbest_y) <br><br>&gt;&gt;&gt;best_x <span class="hljs-keyword">is</span>  [ <span class="hljs-number">4.99981675</span>  <span class="hljs-number">2.00044853</span> <span class="hljs-number">18.99955148</span>] best_y <span class="hljs-keyword">is</span> [<span class="hljs-number">4.35931123e-07</span>]<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>数学建模</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数学建模</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>OS-Lab4-challenge</title>
    <link href="/2022/07/17/OS-Lab4-challenge/"/>
    <url>/2022/07/17/OS-Lab4-challenge/</url>
    
    <content type="html"><![CDATA[<h3 id="实现思路"><a href="#实现思路" class="headerlink" title="实现思路"></a>实现思路</h3><p>实现线程运行与信号量机制的一个基础就是正确定义好线程控制块(TCB)与信号量(sem)结构,然后其他所有的函数都围绕这两个数据结构中的对应内容进行编写。</p><p>下述以部分重点内容为例，结合代码分析所做的工作</p><p><strong>1.include&#x2F;env.h</strong></p><p><strong>（1）定义线程，信号量相关宏</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp">例如：<br><span class="hljs-meta">#<span class="hljs-keyword">define</span> THREAD_MAX8</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> THREAD_CAN_BE_CANCELED 1</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> THREAD_CANNOT_BE_CANCELED0</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> THREAD_CANCEL_IMI0</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> THREAD_CANCEL_POINT1</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> SEM_FREE0</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> SEM_VALID1</span><br></code></pre></td></tr></table></figure><p><strong>（2）定义线程控制块与信号量的结构</strong></p><figure class="highlight d"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs d">线程控制块的编写主要依据是我们要实现的四个线程功能：创建、终止、撤销和阻塞至线程结束，依据这四个要实现的功能定义我们的线程控制块。<br><span class="hljs-keyword">struct</span> Tcb &#123;<br><span class="hljs-comment">// 基础信息</span><br><span class="hljs-keyword">struct</span> Trapframe tcb_tf;<br>u_int thread_id;<br>u_int tcb_status;<br>u_int tcb_pri;<br><br><span class="hljs-comment">// 阻塞相关信息</span><br>LIST_ENTRY(Tcb) tcb_sched_link;<br>LIST_ENTRY(Tcb) tcb_joined_link;<br>LIST_HEAD(Tcb_joined_list,Tcb);<br><span class="hljs-keyword">struct</span> Tcb_joined_list tcb_joined_list;<br><span class="hljs-keyword">void</span> **tcb_join_value_ptr;<br>u_int tcb_detach;<br><br><span class="hljs-comment">// 线程终止</span><br><span class="hljs-keyword">void</span> *tcb_exit_ptr;<br><span class="hljs-keyword">int</span> tcb_exit_value;<br><br><span class="hljs-comment">// 撤销线程</span><br><span class="hljs-keyword">int</span> tcb_cancelstate;<br><span class="hljs-keyword">int</span> tcb_canceltype;<br>u_int tcb_canceled;<br><br><span class="hljs-comment">// 留白</span><br>u_int tcb_nop[<span class="hljs-number">10</span>];<br>&#125;;<br><br>其中需要特别注意的部分就是<span class="hljs-string">`tcb_nop`</span>这个变量。这个变量在实际的线程控制中不起到任何作用，添加这个变量是为了页对齐。在我们的设计中，一个线程最多可以创建<span class="hljs-number">8</span>个线程，设计上我们让一个进程控制块占据一个页表大小(<span class="hljs-number">4</span>KB)，一个线程控制块占据<span class="hljs-number">256</span>B。这样的设计让我们在之后创建线程号以及分配线程栈的时候有很多的方便之处。为了达到这个大小要求，我们在线程控制块和进程控制块中均进行了留白。<br><br>线程中的留白<br><span class="hljs-keyword">struct</span> Env &#123;<br>    ......<br><span class="hljs-comment">// 留白</span><br>u_int env_nop[<span class="hljs-number">496</span>];<br><br><span class="hljs-comment">// 线程控制块</span><br><span class="hljs-keyword">struct</span> Tcb env_threads[<span class="hljs-number">8</span>];<br>&#125;;<br><br>信号量的整个结构体相较线程较为简单，没有特别的难点。使用以下结构体便可以实现信号量的初始化、销毁、阻塞P操作、非阻塞P操作、V操作和取值。这里不过多叙述。<br><span class="hljs-keyword">struct</span> sem &#123;<br>u_int sem_envid;<br>u_int sem_head_index;<br>u_int sem_tail_index;<br><span class="hljs-built_in">char</span> sem_name[<span class="hljs-number">16</span>];<br><span class="hljs-keyword">int</span> sem_value;<br><span class="hljs-keyword">int</span> sem_status;<br><span class="hljs-keyword">int</span> sem_shared;<br><span class="hljs-keyword">int</span> sem_wait_count;<br><span class="hljs-keyword">struct</span> Tcb *sem_wait_list[<span class="hljs-number">10</span>];<br>&#125;;<br></code></pre></td></tr></table></figure><p><strong>（3）定义实现线程与信号量机制的相关函数与数据结构</strong></p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">类似于进程的创建，线程也需要一些全局的变量去控制。<br><span class="hljs-constructor">LIST_HEAD(Tcb_list, Tcb)</span>;<br>extern <span class="hljs-keyword">struct</span> Tcb *curtcb;<br>extern <span class="hljs-keyword">struct</span> Tcb_list tcb_sched_list<span class="hljs-literal">[<span class="hljs-number">2</span>]</span>;<br><span class="hljs-built_in">int</span> thread<span class="hljs-constructor">_alloc(<span class="hljs-params">struct</span> Env <span class="hljs-operator">*</span><span class="hljs-params">e</span>, <span class="hljs-params">struct</span> Tcb <span class="hljs-operator">**</span><span class="hljs-params">t</span>)</span>;<br></code></pre></td></tr></table></figure><p><strong>（4）修改引入线程信号量前体系下的逻辑冲突</strong></p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">在挑战性任务的实现中，任何任务的运行都是以线程为单位的，所以很多如下的函数都要修改：<br><span class="hljs-keyword">struct</span> env的定义<br>void env<span class="hljs-constructor">_run(<span class="hljs-params">struct</span> Tcb <span class="hljs-operator">*</span><span class="hljs-params">e</span>)</span>的定义<br></code></pre></td></tr></table></figure><p><strong>2.include&#x2F;error.h</strong></p><p>定义线程与信号量机制相关的错误</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">define</span> E_THREAD_MAX13</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> E_THREAD_NOTFOUND 14</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> E_THREAD_CANNOTCANCEL 15</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> E_SEM_ERROR16</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> E_SEM_NOTFOUND17</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> E_SEM_EAGAIN18</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAXERROR 18</span><br></code></pre></td></tr></table></figure><p><strong>3.lib&#x2F;env.c</strong></p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-number">1.</span>新函数的实现<br>u_int mktcbid(<span class="hljs-keyword">struct</span> Tcb *t)<br><span class="hljs-built_in">int</span> threadid2tcb(u_int threadid, <span class="hljs-keyword">struct</span> Tcb **ptcb)<br><span class="hljs-built_in">int</span> thread<span class="hljs-constructor">_alloc(<span class="hljs-params">struct</span> Env <span class="hljs-operator">*</span><span class="hljs-params">e</span>, <span class="hljs-params">struct</span> Tcb <span class="hljs-operator">**</span><span class="hljs-params">new</span>)</span><br>void thread<span class="hljs-constructor">_free(<span class="hljs-params">struct</span> Tcb <span class="hljs-operator">*</span><span class="hljs-params">t</span>)</span> <br>void thread<span class="hljs-constructor">_destroy(<span class="hljs-params">struct</span> Tcb <span class="hljs-operator">*</span><span class="hljs-params">t</span>)</span> <br><br><span class="hljs-number">2.</span>修改新体系下的逻辑冲突<br><span class="hljs-built_in">int</span> envid2env(u_int envid, <span class="hljs-keyword">struct</span> Env **penv, <span class="hljs-built_in">int</span> checkperm)<br><span class="hljs-built_in">int</span> env<span class="hljs-constructor">_alloc(<span class="hljs-params">struct</span> Env <span class="hljs-operator">**</span><span class="hljs-params">new</span>, <span class="hljs-params">u_int</span> <span class="hljs-params">parent_id</span>)</span><br>static void load<span class="hljs-constructor">_icode(<span class="hljs-params">struct</span> Env <span class="hljs-operator">*</span><span class="hljs-params">e</span>, <span class="hljs-params">u_char</span> <span class="hljs-operator">*</span><span class="hljs-params">binary</span>, <span class="hljs-params">u_int</span> <span class="hljs-params">size</span>)</span><br>void env<span class="hljs-constructor">_create_priority(<span class="hljs-params">u_char</span> <span class="hljs-operator">*</span><span class="hljs-params">binary</span>, <span class="hljs-params">int</span> <span class="hljs-params">size</span>, <span class="hljs-params">int</span> <span class="hljs-params">priority</span>)</span><br>void env<span class="hljs-constructor">_create(<span class="hljs-params">u_char</span> <span class="hljs-operator">*</span><span class="hljs-params">binary</span>, <span class="hljs-params">int</span> <span class="hljs-params">size</span>)</span><br>void env<span class="hljs-constructor">_free(<span class="hljs-params">struct</span> Env <span class="hljs-operator">*</span><span class="hljs-params">e</span>)</span><br>void env<span class="hljs-constructor">_destroy(<span class="hljs-params">struct</span> Env <span class="hljs-operator">*</span><span class="hljs-params">e</span>)</span><br>void env<span class="hljs-constructor">_run(<span class="hljs-params">struct</span> Tcb <span class="hljs-operator">*</span><span class="hljs-params">t</span>)</span><br></code></pre></td></tr></table></figure><p><strong>重点函数解析：</strong></p><p><strong>（1）创建进程的ID</strong></p><p>如前文所说，一个进程控制块占据一页的大小，可以容纳8个线程控制块，所以这里可以直接根据偏移量来生成线程的控制号。</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs lisp">u_int mktcbid(<span class="hljs-name">struct</span> Tcb *t) &#123;<br>struct Env *e = ROUNDDOWN(<span class="hljs-name">t</span>,BY2PG)<span class="hljs-comment">;</span><br>u_int tcb_no = ((<span class="hljs-name">u_int</span>)<span class="hljs-literal">t</span> - (<span class="hljs-name">u_int</span>)e - BY2PG/2)/(<span class="hljs-name">BY2PG/16</span>)<span class="hljs-comment">;</span><br>return ((<span class="hljs-name">e-&gt;env_id</span> &lt;&lt; <span class="hljs-number">3</span>) | tcb_no)<span class="hljs-comment">;</span><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>（2）创建线程</strong></p><p>这个函数其实就是将之前env_alloc函数初始化的东西移入了线程的创建，因为现在运行的最小单位变成了线程 。下面列出来的部分是线程控制块的选择逻辑。我们会从上一次创建线程的位置开始往下找，直到找到一个可用的空间，这样可以让每一个存储位置都有机会被使用。省略号部分是初始化内容。</p><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs xl">int thread_alloc(struct Env *e, struct Tcb **new) &#123;<br><span class="hljs-function"><span class="hljs-title">if</span> (e-&gt;</span>env_thread_count &gt;= THREAD_MAX) <br>return E_THREAD_MAX;<br><span class="hljs-function"><span class="hljs-title">u_int</span> thread_no = e-&gt;</span>env_thread_count;<br>u_int i = <span class="hljs-number">0</span>;<br><span class="hljs-function"><span class="hljs-title">while</span> (e-&gt;</span>env_threads[thread_no].tcb_status != ENV_FREE) &#123;<br>++thread_no;<br>thread_no = thread_no % THREAD_MAX;<br>++i; <br><span class="hljs-keyword">if</span> (i &gt;= THREAD_MAX)<br>return E_THREAD_MAX;<br>&#125;<br>++(<span class="hljs-function"><span class="hljs-title">e</span>-&gt;</span>env_thread_count);<br><span class="hljs-function"><span class="hljs-title">struct</span> Tcb *t = &amp;e-&gt;</span>env_threads[thread_no];<br><span class="hljs-function"><span class="hljs-title">t</span>-&gt;</span>thread_id = mktcbid(t);<br><span class="hljs-function"><span class="hljs-title">printf</span>(&quot;thread id <span class="hljs-keyword">is</span> 2&#x27;b%b\n&quot;,t-&gt;</span>thread_id);<br><span class="hljs-function"><span class="hljs-title">t</span>-&gt;</span>tcb_status = ENV_RUNNABLE;<br><span class="hljs-function"><span class="hljs-title">t</span>-&gt;</span>tcb_tf.cp0_status = <span class="hljs-number">0</span>x10001004;<br><span class="hljs-function"><span class="hljs-title">t</span>-&gt;</span>tcb_exit_ptr = (void *)<span class="hljs-number">0</span>;<br><span class="hljs-function"><span class="hljs-title">t</span>-&gt;</span><span class="hljs-function"><span class="hljs-title">tcb_tf</span>.regs[29] = USTACKTOP - 4*BY2PG*(t-&gt;</span>thread_id &amp; <span class="hljs-number">0</span>x7);<br><span class="hljs-function"><span class="hljs-title">t</span>-&gt;</span>tcb_cancelstate = THREAD_CANNOT_BE_CANCELED;<br><span class="hljs-function"><span class="hljs-title">t</span>-&gt;</span>tcb_canceltype = THREAD_CANCEL_IMI;<br><span class="hljs-function"><span class="hljs-title">t</span>-&gt;</span>tcb_canceled = <span class="hljs-number">0</span>;<br><span class="hljs-function"><span class="hljs-title">t</span>-&gt;</span>tcb_exit_value = <span class="hljs-number">0</span>;<br><span class="hljs-function"><span class="hljs-title">t</span>-&gt;</span><span class="hljs-function"><span class="hljs-title">tcb_exit_ptr</span> = (void *)&amp;t-&gt;</span>tcb_exit_value;<br><span class="hljs-function"><span class="hljs-title">t</span>-&gt;</span>tcb_detach = <span class="hljs-number">0</span>;<br>LIST_INIT(&amp;<span class="hljs-function"><span class="hljs-title">t</span>-&gt;</span>tcb_joined_list);<br>*new = t;<br>return <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>（3）线程的销毁</strong></p><p>类似于进程的销毁，在进行时钟中断的时候要将当前的 KERNEL_SP 内容拷贝到 TIMESTACK 中，并且当一个进程的所有线程都被销毁后要将这个进程控制块释放。</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">void thread<span class="hljs-constructor">_free(<span class="hljs-params">struct</span> Tcb <span class="hljs-operator">*</span><span class="hljs-params">t</span>)</span> <br>&#123;<br><span class="hljs-keyword">struct</span> Env *e = <span class="hljs-constructor">ROUNDDOWN(<span class="hljs-params">t</span>,BY2PG)</span>;<br>printf(<span class="hljs-string">&quot;[%08x] free tcb %08x\n&quot;</span>, e-&gt;env_id, t-&gt;thread_id);<br>--e-&gt;env_thread_count;<br><span class="hljs-keyword">if</span> (e-&gt;env_thread_count &lt;= <span class="hljs-number">0</span>) &#123;<br>env<span class="hljs-constructor">_free(<span class="hljs-params">e</span>)</span>;<br>&#125;<br>t-&gt;tcb_status = ENV_FREE;<br>&#125;<br><br>void thread<span class="hljs-constructor">_destroy(<span class="hljs-params">struct</span> Tcb <span class="hljs-operator">*</span><span class="hljs-params">t</span>)</span> &#123;<br><span class="hljs-keyword">if</span> (t-&gt;tcb_status<span class="hljs-operator"> == </span>ENV_RUNNABLE)<br><span class="hljs-constructor">LIST_REMOVE(<span class="hljs-params">t</span>,<span class="hljs-params">tcb_sched_link</span>)</span>;<br>thread<span class="hljs-constructor">_free(<span class="hljs-params">t</span>)</span>;<br><span class="hljs-keyword">if</span> (curtcb<span class="hljs-operator"> == </span>t) &#123;<br>curtcb = NULL;<br>bcopy((void *)KERNEL_SP - sizeof(<span class="hljs-keyword">struct</span> Trapframe),<br>(void *)TIMESTACK - sizeof(<span class="hljs-keyword">struct</span> Trapframe),<br>sizeof(<span class="hljs-keyword">struct</span> Trapframe));<br>printf(<span class="hljs-string">&quot;i am thread, i am killed ... \n&quot;</span>);<br>sched<span class="hljs-constructor">_yield()</span>;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>4.lib&#x2F;sched.c</strong></p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">以线程为单位进行调度<br>void sched<span class="hljs-constructor">_yield(<span class="hljs-params">void</span>)</span><br>&#123;<br>static <span class="hljs-built_in">int</span> times = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">struct</span> Env *e = curenv;<br><span class="hljs-keyword">struct</span> Tcb *t = curtcb;<br>static <span class="hljs-built_in">int</span> sched_i = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">if</span> (!t) &#123;<br><span class="hljs-keyword">while</span> (<span class="hljs-constructor">LIST_EMPTY(&amp;<span class="hljs-params">tcb_sched_list</span>[<span class="hljs-params">sched_i</span>])</span>) &#123;<br>sched_i ^= <span class="hljs-number">1</span>;<br>&#125;<br>t = <span class="hljs-constructor">LIST_FIRST(&amp;<span class="hljs-params">tcb_sched_list</span>[<span class="hljs-params">sched_i</span>])</span>;<br>times = t-&gt;tcb_pri;<br>times -= <span class="hljs-number">1</span>;<br>env<span class="hljs-constructor">_run(<span class="hljs-params">t</span>)</span>;<br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (t-&gt;tcb_status != ENV_RUNNABLE) &#123;<br><span class="hljs-keyword">while</span> (<span class="hljs-constructor">LIST_EMPTY(&amp;<span class="hljs-params">tcb_sched_list</span>[<span class="hljs-params">sched_i</span>])</span>) &#123;<br>sched_i ^= <span class="hljs-number">1</span>;<br>&#125;<br>t = <span class="hljs-constructor">LIST_FIRST(&amp;<span class="hljs-params">tcb_sched_list</span>[<span class="hljs-params">sched_i</span>])</span>;<br>times = t-&gt;tcb_pri;<br>times -= <span class="hljs-number">1</span>;<br>env<span class="hljs-constructor">_run(<span class="hljs-params">t</span>)</span>;<br>&#125;<br><span class="hljs-keyword">if</span> (times &lt;= <span class="hljs-number">0</span>) &#123;<br><span class="hljs-constructor">LIST_REMOVE(<span class="hljs-params">t</span>,<span class="hljs-params">tcb_sched_link</span>)</span>;<br><span class="hljs-constructor">LIST_INSERT_HEAD(&amp;<span class="hljs-params">tcb_sched_list</span>[<span class="hljs-params">sched_i</span>^1],<span class="hljs-params">t</span>,<span class="hljs-params">tcb_sched_link</span>)</span>;<br><span class="hljs-keyword">while</span> (<span class="hljs-constructor">LIST_EMPTY(&amp;<span class="hljs-params">tcb_sched_list</span>[<span class="hljs-params">sched_i</span>])</span>) &#123;<br>sched_i ^= <span class="hljs-number">1</span>;<br>&#125;<br>t = <span class="hljs-constructor">LIST_FIRST(&amp;<span class="hljs-params">tcb_sched_list</span>[<span class="hljs-params">sched_i</span>])</span>;<br>times = t-&gt;tcb_pri;<br>times -= <span class="hljs-number">1</span>;<br>env<span class="hljs-constructor">_run(<span class="hljs-params">t</span>)</span>;<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>times -= <span class="hljs-number">1</span>;<br>env<span class="hljs-constructor">_run(<span class="hljs-params">t</span>)</span>;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>5.系统调用的新增与修改</strong></p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-number">1.</span>新增的系统调用<br>u_int sys<span class="hljs-constructor">_getthreadid(<span class="hljs-params">void</span>)</span><br><span class="hljs-built_in">int</span> sys<span class="hljs-constructor">_thread_destroy(<span class="hljs-params">int</span> <span class="hljs-params">sysno</span>, <span class="hljs-params">u_int</span> <span class="hljs-params">threadid</span>)</span><br><span class="hljs-built_in">int</span> sys<span class="hljs-constructor">_thread_alloc(<span class="hljs-params">void</span>)</span><br><span class="hljs-built_in">int</span> sys<span class="hljs-constructor">_set_thread_status(<span class="hljs-params">int</span> <span class="hljs-params">sysno</span>, <span class="hljs-params">u_int</span> <span class="hljs-params">threadid</span>, <span class="hljs-params">u_int</span> <span class="hljs-params">status</span>)</span><br><span class="hljs-built_in">int</span> sys<span class="hljs-constructor">_thread_join(<span class="hljs-params">int</span> <span class="hljs-params">sysno</span>, <span class="hljs-params">u_int</span> <span class="hljs-params">threadid</span>, <span class="hljs-params">void</span> <span class="hljs-operator">**</span><span class="hljs-params">value_ptr</span>)</span><br><br><span class="hljs-built_in">int</span> sys<span class="hljs-constructor">_sem_destroy(<span class="hljs-params">int</span> <span class="hljs-params">sysno</span>,<span class="hljs-params">sem_t</span> <span class="hljs-operator">*</span><span class="hljs-params">sem</span>)</span><br><span class="hljs-built_in">int</span> sys<span class="hljs-constructor">_sem_wait(<span class="hljs-params">int</span> <span class="hljs-params">sysno</span>,<span class="hljs-params">sem_t</span> <span class="hljs-operator">*</span><span class="hljs-params">sem</span>)</span><br><span class="hljs-built_in">int</span> sys<span class="hljs-constructor">_sem_trywait(<span class="hljs-params">int</span> <span class="hljs-params">sysno</span>, <span class="hljs-params">sem_t</span> <span class="hljs-operator">*</span><span class="hljs-params">sem</span>)</span><br><span class="hljs-built_in">int</span> sys<span class="hljs-constructor">_sem_post(<span class="hljs-params">int</span> <span class="hljs-params">sysno</span>, <span class="hljs-params">sem_t</span> <span class="hljs-operator">*</span><span class="hljs-params">sem</span>)</span><br><span class="hljs-built_in">int</span> sys<span class="hljs-constructor">_sem_getvalue(<span class="hljs-params">int</span> <span class="hljs-params">sysno</span>, <span class="hljs-params">sem_t</span> <span class="hljs-operator">*</span><span class="hljs-params">sem</span>, <span class="hljs-params">int</span> <span class="hljs-operator">*</span><span class="hljs-params">valp</span>)</span><br><br><span class="hljs-number">2.</span>修改的系统调用<br><span class="hljs-built_in">int</span> sys<span class="hljs-constructor">_env_alloc(<span class="hljs-params">void</span>)</span><br><span class="hljs-built_in">int</span> sys<span class="hljs-constructor">_set_env_status(<span class="hljs-params">int</span> <span class="hljs-params">sysno</span>, <span class="hljs-params">u_int</span> <span class="hljs-params">envid</span>, <span class="hljs-params">u_int</span> <span class="hljs-params">status</span>)</span><br>void sys<span class="hljs-constructor">_ipc_recv(<span class="hljs-params">int</span> <span class="hljs-params">sysno</span>, <span class="hljs-params">u_int</span> <span class="hljs-params">dstva</span>)</span><br><span class="hljs-built_in">int</span> sys<span class="hljs-constructor">_ipc_can_send(<span class="hljs-params">int</span> <span class="hljs-params">sysno</span>, <span class="hljs-params">u_int</span> <span class="hljs-params">envid</span>, <span class="hljs-params">u_int</span> <span class="hljs-params">value</span>, <span class="hljs-params">u_int</span> <span class="hljs-params">srcva</span>, <span class="hljs-params">u_int</span> <span class="hljs-params">perm</span>)</span><br></code></pre></td></tr></table></figure><p><strong>重点函数解析：</strong></p><p><strong>（1）设置线程的状态</strong></p><p>进行这个系统调用可以改变线程的状态，这在线程的阻塞和调度中起到了十分重要的作用。</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-built_in">int</span> sys<span class="hljs-constructor">_set_env_status(<span class="hljs-params">int</span> <span class="hljs-params">sysno</span>, <span class="hljs-params">u_int</span> <span class="hljs-params">envid</span>, <span class="hljs-params">u_int</span> <span class="hljs-params">status</span>)</span><br>&#123;<br><span class="hljs-comment">// Your code here.</span><br><span class="hljs-keyword">struct</span> Env *env;<br><span class="hljs-keyword">struct</span> Tcb *tcb;<br><span class="hljs-built_in">int</span> ret;<br><br><span class="hljs-keyword">if</span> ((status != ENV_RUNNABLE)&amp;&amp;(status != ENV_NOT_RUNNABLE)&amp;&amp;(status != ENV_FREE))<br>return -E_INVAL;<br>ret = envid2env(envid,&amp;env,<span class="hljs-number">0</span>);<br>tcb = &amp;env-&gt;env_threads<span class="hljs-literal">[<span class="hljs-number">0</span>]</span>;<br><span class="hljs-keyword">if</span> (ret &lt; <span class="hljs-number">0</span>)<br>return ret;<br><span class="hljs-keyword">if</span> ((status<span class="hljs-operator"> == </span>ENV_RUNNABLE)&amp;&amp;(tcb-&gt;tcb_status != ENV_RUNNABLE)) &#123;<br><span class="hljs-constructor">LIST_INSERT_HEAD(<span class="hljs-params">tcb_sched_list</span>,<span class="hljs-params">tcb</span>,<span class="hljs-params">tcb_sched_link</span>)</span>;<br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>((tcb-&gt;tcb_status<span class="hljs-operator"> == </span>ENV_RUNNABLE)&amp;&amp;(status != ENV_RUNNABLE)) &#123;<br><span class="hljs-constructor">LIST_REMOVE(<span class="hljs-params">tcb</span>,<span class="hljs-params">tcb_sched_link</span>)</span>;<br>&#125;<br>env-&gt;env_threads<span class="hljs-literal">[<span class="hljs-number">0</span>]</span>.tcb_status = status;<br>return <span class="hljs-number">0</span>;<br><span class="hljs-comment">//panic(&quot;sys_env_set_status not implemented&quot;);</span><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>（2）线程的阻塞等待</strong></p><p>一个进程可以主动等待一个指定的线程完成后才继续往下执行。这个系统调用可以保证一些执行的顺序。</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-built_in">int</span> sys<span class="hljs-constructor">_thread_join(<span class="hljs-params">int</span> <span class="hljs-params">sysno</span>, <span class="hljs-params">u_int</span> <span class="hljs-params">threadid</span>, <span class="hljs-params">void</span> <span class="hljs-operator">**</span><span class="hljs-params">value_ptr</span>)</span><br>&#123;<br><span class="hljs-keyword">struct</span> Tcb *t;<br><span class="hljs-built_in">int</span> r;<br><span class="hljs-comment">//printf(&quot;here id is 0x%x\n&quot;,threadid);</span><br>r = threadid2tcb(threadid,&amp;t);<br><span class="hljs-comment">//printf(&quot;find id is 0x%x\n&quot;,t-&gt;thread_id);</span><br><span class="hljs-keyword">if</span> (r &lt; <span class="hljs-number">0</span>)<br>return r;<br><span class="hljs-keyword">if</span> (t-&gt;tcb_detach) &#123;<br>return -E_THREAD_JOIN_FAIL;<br>&#125;<br><span class="hljs-keyword">if</span> (t-&gt;tcb_status<span class="hljs-operator"> == </span>ENV_FREE) &#123;<br><span class="hljs-keyword">if</span> (value_ptr != <span class="hljs-number">0</span>) &#123;<br>*value_ptr = t-&gt;tcb_exit_ptr;<br>&#125;<br>return <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-comment">//printf(&quot;father id is 0x%x\n&quot;,t-&gt;thread_id);</span><br><span class="hljs-constructor">LIST_INSERT_HEAD(&amp;<span class="hljs-params">t</span>-&gt;<span class="hljs-params">tcb_joined_list</span>,<span class="hljs-params">curtcb</span>,<span class="hljs-params">tcb_joined_link</span>)</span>;<br>curtcb-&gt;tcb_join_value_ptr = value_ptr;<br>sys<span class="hljs-constructor">_set_thread_status(0,<span class="hljs-params">curtcb</span>-&gt;<span class="hljs-params">thread_id</span>,ENV_NOT_RUNNABLE)</span>;<br><span class="hljs-keyword">struct</span> Trapframe *trap = (<span class="hljs-keyword">struct</span> Trapframe *)(KERNEL_SP - sizeof(<span class="hljs-keyword">struct</span> Trapframe));<br>trap-&gt;regs<span class="hljs-literal">[<span class="hljs-number">2</span>]</span> = <span class="hljs-number">0</span>;<br>trap-&gt;pc = trap-&gt;cp0_epc;<br>sys<span class="hljs-constructor">_yield()</span>;<br>return <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>（3）信号量的P操作(阻塞和非阻塞)</strong></p><p>当一个线程想要申请一个信号量的时候就会调用一下两个函数之一。如果是进行的阻塞申请，并且当前没有可用的信号量，那么信号量结构体就会将当前申请的进程加入到等待队列中。等待队列的实现逻辑本质上是一个循环列表，当超过最大等待上线的时候便会报错。</p><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs xl"><span class="hljs-comment">//阻塞</span><br>int sys_sem_wait(int sysno,sem_t *sem)<br>&#123;<br><span class="hljs-function"><span class="hljs-title">if</span> (sem-&gt;</span>sem_status == SEM_FREE) &#123;<br>return -E_SEM_ERROR;<br>&#125;<br>int i;<br><span class="hljs-function"><span class="hljs-title">if</span> (sem-&gt;</span>sem_value &gt; <span class="hljs-number">0</span>) &#123;<br>--<span class="hljs-function"><span class="hljs-title">sem</span>-&gt;</span>sem_value;<br>return <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-title">if</span> (sem-&gt;</span>sem_wait_count &gt;= <span class="hljs-number">10</span>) &#123;<br>return -E_SEM_ERROR;<br>&#125;<br><span class="hljs-function"><span class="hljs-title">sem</span>-&gt;</span><span class="hljs-function"><span class="hljs-title">sem_wait_list</span>[sem-&gt;</span>sem_head_index] = curtcb;<br><span class="hljs-function"><span class="hljs-title">sem</span>-&gt;</span><span class="hljs-function"><span class="hljs-title">sem_head_index</span> = (sem-&gt;</span>sem_head_index + <span class="hljs-number">1</span>) % <span class="hljs-number">10</span>;<br>++<span class="hljs-function"><span class="hljs-title">sem</span>-&gt;</span>sem_wait_count;<br>sys_set_thread_status(<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,ENV_NOT_RUNNABLE);<br>struct Trapframe *trap = (struct Trapframe *)(KERNEL_SP - sizeof(struct Trapframe));<br><span class="hljs-function"><span class="hljs-title">trap</span>-&gt;</span>regs[<span class="hljs-number">2</span>] = <span class="hljs-number">0</span>;<br><span class="hljs-function"><span class="hljs-title">trap</span>-&gt;</span><span class="hljs-function"><span class="hljs-title">pc</span> = trap-&gt;</span>cp0_epc;<br><span class="hljs-comment">//printf(&quot;wait thread is 0x%x\n&quot;,curtcb-&gt;thread_id);</span><br>sys_yield();<br>return -E_SEM_ERROR;<br>&#125;<br><br><span class="hljs-comment">//非阻塞</span><br>int sys_sem_trywait(int sysno, sem_t *sem)<br>&#123;<br><span class="hljs-function"><span class="hljs-title">if</span> (sem-&gt;</span>sem_status == SEM_FREE) &#123;<br>return -E_SEM_ERROR;<br>&#125;<br><span class="hljs-function"><span class="hljs-title">if</span> (sem-&gt;</span>sem_value &gt; <span class="hljs-number">0</span>) &#123;<br>--<span class="hljs-function"><span class="hljs-title">sem</span>-&gt;</span>sem_value;<br>return <span class="hljs-number">0</span>;<br>&#125;<br>return -E_SEM_EAGAIN;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>（4）信号量的V操作</strong></p><p>实现了基本的V操作，对当前有无等待进行了分别的处理。</p><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs xl">int sys_sem_post(int sysno, sem_t *sem)<br>&#123;<br><span class="hljs-function"><span class="hljs-title">if</span> (sem-&gt;</span>sem_status == SEM_FREE) &#123;<br>return -E_SEM_ERROR;<br>&#125;<br><span class="hljs-function"><span class="hljs-title">if</span> (sem-&gt;</span>sem_value &gt; <span class="hljs-number">0</span>) &#123;<br>++<span class="hljs-function"><span class="hljs-title">sem</span>-&gt;</span>sem_value;<br>&#125; <span class="hljs-keyword">else</span> &#123;<br><span class="hljs-function"><span class="hljs-title">if</span> (sem-&gt;</span>sem_wait_count == <span class="hljs-number">0</span>) &#123;<br>++<span class="hljs-function"><span class="hljs-title">sem</span>-&gt;</span>sem_value;<br>&#125;<br><span class="hljs-keyword">else</span> &#123;<br>struct Tcb *t;<br>--<span class="hljs-function"><span class="hljs-title">sem</span>-&gt;</span>sem_wait_count;<br><span class="hljs-function"><span class="hljs-title">t</span> = sem-&gt;</span><span class="hljs-function"><span class="hljs-title">sem_wait_list</span>[sem-&gt;</span>sem_tail_index];<br><span class="hljs-function"><span class="hljs-title">sem</span>-&gt;</span><span class="hljs-function"><span class="hljs-title">sem_wait_list</span>[sem-&gt;</span>sem_tail_index] = <span class="hljs-number">0</span>;<br><span class="hljs-function"><span class="hljs-title">sem</span>-&gt;</span><span class="hljs-function"><span class="hljs-title">sem_tail_index</span> = (sem-&gt;</span>sem_tail_index + <span class="hljs-number">1</span>) % <span class="hljs-number">10</span>;<br><span class="hljs-function"><span class="hljs-title">sys_set_thread_status</span>(0,t-&gt;</span>thread_id,ENV_RUNNABLE);<br>&#125;<br>&#125;<br>return <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>6.用户态函数的实现</strong></p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-number">1.</span>user/pthread.c<br><span class="hljs-built_in">int</span> pthread<span class="hljs-constructor">_create(<span class="hljs-params">pthread_t</span> <span class="hljs-operator">*</span><span class="hljs-params">thread</span>, <span class="hljs-params">const</span> <span class="hljs-params">pthread_attr_t</span> <span class="hljs-operator">*</span><span class="hljs-params">attr</span>, <span class="hljs-params">void</span> <span class="hljs-operator">*</span> (<span class="hljs-operator">*</span><span class="hljs-params">start_rountine</span>)</span>(void *), void *arg)<br>void pthread<span class="hljs-constructor">_exit(<span class="hljs-params">void</span> <span class="hljs-operator">*</span><span class="hljs-params">value_ptr</span>)</span><br><span class="hljs-built_in">int</span> pthread<span class="hljs-constructor">_setcancelstate(<span class="hljs-params">int</span> <span class="hljs-params">state</span>, <span class="hljs-params">int</span> <span class="hljs-operator">*</span><span class="hljs-params">oldvalue</span>)</span> <br><span class="hljs-built_in">int</span> pthread<span class="hljs-constructor">_setcanceltype(<span class="hljs-params">int</span> <span class="hljs-params">type</span>, <span class="hljs-params">int</span> <span class="hljs-operator">*</span><span class="hljs-params">oldvalue</span>)</span> <br>void pthread<span class="hljs-constructor">_testcancel()</span> <br><span class="hljs-built_in">int</span> pthread<span class="hljs-constructor">_cancel(<span class="hljs-params">pthread_t</span> <span class="hljs-params">thread</span>)</span><br><span class="hljs-built_in">int</span> pthread<span class="hljs-constructor">_detach(<span class="hljs-params">pthread_t</span> <span class="hljs-params">thread</span>)</span><br><span class="hljs-built_in">int</span> pthread<span class="hljs-constructor">_join(<span class="hljs-params">pthread_t</span> <span class="hljs-params">thread</span>, <span class="hljs-params">void</span> <span class="hljs-operator">**</span><span class="hljs-params">value_ptr</span>)</span><br><br><span class="hljs-number">2.</span>user/sem.c<br><span class="hljs-built_in">int</span> sem<span class="hljs-constructor">_init(<span class="hljs-params">sem_t</span> <span class="hljs-operator">*</span><span class="hljs-params">sem</span>,<span class="hljs-params">int</span> <span class="hljs-params">shared</span>,<span class="hljs-params">unsigned</span> <span class="hljs-params">int</span> <span class="hljs-params">value</span>)</span><br><span class="hljs-built_in">int</span> sem<span class="hljs-constructor">_destroy(<span class="hljs-params">sem_t</span> <span class="hljs-operator">*</span><span class="hljs-params">sem</span>)</span><br><span class="hljs-built_in">int</span> sem<span class="hljs-constructor">_wait(<span class="hljs-params">sem_t</span> <span class="hljs-operator">*</span><span class="hljs-params">sem</span>)</span> <br><span class="hljs-built_in">int</span> sem<span class="hljs-constructor">_trywait(<span class="hljs-params">sem_t</span> <span class="hljs-operator">*</span><span class="hljs-params">sem</span>)</span><br><span class="hljs-built_in">int</span> sem<span class="hljs-constructor">_post(<span class="hljs-params">sem_t</span> <span class="hljs-operator">*</span><span class="hljs-params">sem</span>)</span><br><span class="hljs-built_in">int</span> sem<span class="hljs-constructor">_getvalue(<span class="hljs-params">sem_t</span> <span class="hljs-operator">*</span><span class="hljs-params">sem</span>,<span class="hljs-params">int</span> <span class="hljs-operator">*</span><span class="hljs-params">valp</span>)</span><br></code></pre></td></tr></table></figure><h3 id="遇到的困难及解决方案"><a href="#遇到的困难及解决方案" class="headerlink" title="遇到的困难及解决方案"></a>遇到的困难及解决方案</h3><p><strong>1.线程控制块的位置及查找</strong></p><p>我们采用了填充对齐的方法去布局线程和进程。这样实现简单，其次创建进程、线程的时候可以很快的生产ID，快速查找，并且空余的空间还可以添加未来可能的功能。这种结构比较适合OS课程这种小型操作系统，但是其缺点也很明显：空间浪费。如果还想要节约空间的话可能就需要使用链表之类的结构，但是那样实现繁琐，并且链表等操作速度肯定是慢于直接查找，所以没有采用链表的实现方式。</p><p><strong>2.join阻塞的实现</strong></p><p>join阻塞机制的实现利用了TCB结构体中的 Tcb_joined_list 的链表结构，利用链表储存被阻塞的线程ID，从而在线程结束时可以定位到被阻塞的进程，进行进程状态的恢复。</p><p><strong>3.线程栈的实现</strong></p><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xl"><span class="hljs-function"><span class="hljs-title">t</span>-&gt;</span><span class="hljs-function"><span class="hljs-title">tcb_tf</span>.regs[29] = USTACKTOP - 4*BY2PG*(t-&gt;</span>thread_id &amp; <span class="hljs-number">0</span>x7);<br></code></pre></td></tr></table></figure><p>在上述语句中为每一个线程分配了不同的栈区，从而保证了不同线程中运行栈的地址不能重合，实现了同一进程的不同线程可以相互访问栈内数据。</p>]]></content>
    
    
    <categories>
      
      <category>OS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>OS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>OS-Lab5</title>
    <link href="/2022/07/17/OS-Lab5/"/>
    <url>/2022/07/17/OS-Lab5/</url>
    
    <content type="html"><![CDATA[<h2 id="一-全局变量名词解释"><a href="#一-全局变量名词解释" class="headerlink" title="一.全局变量名词解释"></a>一.全局变量名词解释</h2><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs gauss"><span class="hljs-meta">#<span class="hljs-keyword">define</span> NBLOCK 1024 <span class="hljs-comment">//一块磁盘里面的block数目</span></span><br>uint32_t nbitblock; <span class="hljs-comment">// 用于存储bitmap的block数目</span><br>uint32_t nextbno;   <span class="hljs-comment">// 下一块可用的block编号</span><br><br><span class="hljs-keyword">struct</span> <span class="hljs-type">Super</span> super; <span class="hljs-comment">// 超级块</span><br><span class="hljs-keyword">struct</span> <span class="hljs-type">Block</span> &#123;<br>    uint8_t data[BY2BLK];<br>    uint32_t <span class="hljs-built_in">type</span>;<br>&#125; disk[NBLOCK];<br><br><span class="hljs-comment">///////////////////下面的内容在include里面的fs.h里面</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> BY2BLKBY2PG<span class="hljs-comment">//一个block对应的字节，也就是说，一个block正好等于一页大小</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> BIT2BLK(BY2BLK*8)<span class="hljs-comment">//一个block对应的*位数*，一字节等于8位，所以要乘8</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAXNAMELEN128<span class="hljs-comment">//用于存文件名的char数组大小，由于最后一个必定为&#x27;\0&#x27;,所以只能存127个字符</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAXPATHLEN1024<span class="hljs-comment">//和上面的类似，只不过是用来存路径的</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> NDIRECT10<span class="hljs-comment">//直接引用的个数，可以认为是10个指针，这里用int存block的下标来代替了指针的作用</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> NINDIRECT(BY2BLK/4)<span class="hljs-comment">//间接引用块的指针个数，由于一个int是32位，也就是4byte，所以是除4</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAXFILESIZE(NINDIRECT*BY2BLK)<span class="hljs-comment">//最大文件大小，那么就是引用指针的个数*一块大小</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> BY2FILE     256<span class="hljs-comment">//定义了一个FIle结构体（文件索引结构体）所占用的大小，实际上比FILE结构体实际占用大小要大，是为了保持扩展性？</span></span><br><br><span class="hljs-keyword">struct</span> <span class="hljs-type">File</span> &#123;<span class="hljs-comment">//文件索引结构体</span><br>u_char f_name[MAXNAMELEN];<span class="hljs-comment">// 文件名</span><br>u_int f_size;<span class="hljs-comment">// 文件大小（字节），其实就是引用块所占的总大小</span><br>u_int f_type;<span class="hljs-comment">// 文件类型，有两种，一种是普通文件，一种是目录</span><br>u_int f_direct[NDIRECT];<span class="hljs-comment">//直接引用指针</span><br>u_int f_indirect;<span class="hljs-comment">//指向间接引用块</span><br><br><span class="hljs-keyword">struct</span> <span class="hljs-type">File</span> *f_dir;<span class="hljs-comment">// 指向包含这个文件的目录，只在内存中存在着（真正写入文件之后没有这部分）</span><br>u_char f_pad[BY2FILE - MAXNAMELEN - <span class="hljs-number">4</span> - <span class="hljs-number">4</span> - NDIRECT * <span class="hljs-number">4</span> - <span class="hljs-number">4</span> - <span class="hljs-number">4</span>];<span class="hljs-comment">//为了填满by2file，而开了这部分内容</span><br>&#125;;<br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> FILE2BLK(BY2BLK/sizeof(struct File))<span class="hljs-comment">//就是一个block能容纳多少个file索引</span></span><br><br><span class="hljs-comment">// File types</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> FTYPE_REG0<span class="hljs-comment">// 普通文件</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> FTYPE_DIR1<span class="hljs-comment">// 目录</span></span><br><br><br><span class="hljs-comment">// File system super-block (both in-memory and on-disk)</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> FS_MAGIC0x68286097<span class="hljs-comment">// 神秘代码，用来表示这是个合法的文件</span></span><br><br><span class="hljs-keyword">struct</span> <span class="hljs-type">Super</span> &#123;<br>u_int s_magic;<span class="hljs-comment">// Magic number: FS_MAGIC</span><br>u_int s_nblocks;<span class="hljs-comment">// Total number of blocks on disk</span><br><span class="hljs-keyword">struct</span> <span class="hljs-type">File</span> s_root;<span class="hljs-comment">// Root directory node</span><br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="二-实验难点图示"><a href="#二-实验难点图示" class="headerlink" title="二.实验难点图示"></a>二.实验难点图示</h2><h4 id="1-文件系统层次关系梳理"><a href="#1-文件系统层次关系梳理" class="headerlink" title="1.文件系统层次关系梳理"></a>1.文件系统层次关系梳理</h4><p>文件系统可以分成四个层次：</p><p>文件系统用户接口、文件系统抽象层、文件系统具体实现、文件系统设备接口。</p><p>文件系统的逐级调用关系可以用下图表示：<br><img src="https://img-blog.csdnimg.cn/f7f227bf88e4455da700e8128de850d6.png" alt="在这里插入图片描述"></p><h4 id="2-多级目录与多级索引"><a href="#2-多级目录与多级索引" class="headerlink" title="2.多级目录与多级索引"></a>2.多级目录与多级索引</h4><p>多级目录用来管理文件间的层次关系，多级索引用来管理单个文件的数据。两者并不是一个概念。</p><p>在我们的实验中，目录文件的内容是文件控制块<code>struct File</code>，目录文件的每一个数据块由16个文件目录项组成，找到相应的文件名，找到对应文件的FCB，进而找到该文件的数据块。</p><p>多级索引用来管理文件的数据块，我们的实验中使用二级索引机制。在FCB中可以有一级索引数组<code>f_direct[NDIRECT]</code>，和一个二级索引<code>f_indirect</code>，二级索引找到的磁盘块为索引块，这个磁盘块可以存储1024的FCB。</p><p>目录文件综合体现了这一点，以下图来说明：</p><p><img src="https://img-blog.csdnimg.cn/e8249302ff204ed898d588a14ce80be7.png" alt="在这里插入图片描述"></p><h2 id="三-代码梳理"><a href="#三-代码梳理" class="headerlink" title="三.代码梳理"></a>三.代码梳理</h2><h4 id="1-磁盘管理"><a href="#1-磁盘管理" class="headerlink" title="1.磁盘管理"></a>1.磁盘管理</h4><p>完成文件系统的第一步就是要能够处理磁盘等外设的信息。</p><ul><li><p>lib&#x2F;syscall_all.c</p><p>处理磁盘的信息，最基本的就是对磁盘进行读写操作。<br><code>sys_write_dev</code>函数用于对外设进行写操作。首先是检查地址的合法性，写入的这段地址需要在规定地址范围之内，接着使用<code>bcopy</code>把数据复制过去即可。<br><code>sys_read_dev</code>函数用于读操作。过程与写类似。</p></li><li><p>fs&#x2F;ide.c</p><p>在实现了对外设基本的读写后，对于磁盘，为了方便上层用户操作，还需要一个封装好的磁盘驱动程序，也就是这里的<code>ide_read</code>和<code>ide_write</code>函数。<br><code>ide_read</code>函数用于从特定的磁盘块读取一定量的数据。首先需要做的就是根据起始扇区和扇区数计算首尾地址，接着是循环读取数据，具体来说首先是向控制磁盘的几个地址写入对应的信息，接着检查磁盘状态，如果正常则读取一个扇区。<br><code>ide_write</code>函数和<code>ide_read</code>函数类似，不同在于，读取磁盘状态是在写操作结束后读取检查。</p><p><img src="https://img-blog.csdnimg.cn/img_convert/ed0411419922866ca7bcedf87744bcc5.png" alt="img"></p></li><li><p>fs&#x2F;fs.c</p><p>完成了磁盘读写后，我们需要对磁盘的信息进行管理，也就是对磁盘块的使用状态进行管理。</p><p><img src="https://img-blog.csdnimg.cn/img_convert/c43836eefb38ebf058bcfb560575bf57.png" alt="img"></p><p>磁盘最开始的一个扇区被当成是启动扇区和分区表使用；接着是一个超级块，这个超级块结构体定义在include&#x2F;fs.h中，里面定义了魔数、磁盘块数量和根目录的文件控制块。接下来存储的是位图信息，用来记录磁盘块的使用信息，每一个二进制位到代表了一个磁盘块。剩余的内容都是存储数据的数据块。</p><p><code>diskaddr</code>函数用于求出某一个磁盘块的地址。首先需要判断磁盘块号的合法性，接着计算偏移加上基地址即可。块大小为<code>BY2BLK</code>。<br><code>block_is_mapped</code>函数用于检查这个块是否已经映射到了页表中。也就是通过<code>diskaddr</code>计算出地址后使用<code>va_is_mapped</code>检查是否存在于页表。<br><code>block_is_dirty</code>函数用于确定这个块的数据是否已经被修改。具体做法类似，检查页表项的<code>PTE_D</code>标志位即可。<br><code>map_block</code>函数用于分配一页内存映射到一个数据块。首先检查这个数据块是否已经映射，没被映射再使用<code>syscall_mem_alloc</code>完成映射。<br><code>unmap_block</code>函数用于移除数据块的映射关系。首先检查这个数据块是否被映射了；然后检查这个数据块是否被修改过，如果被修改了则需要把数据写入到磁盘块中；接着使用<code>syscall_mem_unmap</code>移除映射关系。<br><code>read_block</code>函数用于读入数据块的数据到内存中。首先需要判断数据块号合法性和数据块是否被使用；然后取得数据块地址；检查这个数据块是否在内存中，如果不在则需要分配一页映射到数据块，然后调用<code>ide_read</code>读入数据；检查<code>blk</code>是否为NULL，如果不是则把虚拟地址赋值。<br><code>write_block</code>函数用于把内存数据块的信息写入到磁盘中。首先判断数据块是否被映射；取得地址后调用<code>ide_write</code>写磁盘块，最后移除这个映射。<br><code>block_is_free</code>函数用于判断数据块是否被释放。具体来说就是检查位图对应的信息是否为1。<br><code>free_block</code>函数用于释放一个数据块，更新位图。也就是将位图的信息置0。<br><code>alloc_block_num</code>函数用于查找分配一个空闲的数据块。也就是从3号开始，搜索位图检查是否有空闲的数据块，并返回空闲数据块号。<br><code>alloc_block</code>函数用于获得一个空闲数据块并映射到内存中。首先通过<code>alloc_block_num</code>获得一个空闲的磁盘块号，然后将对应的磁盘用<code>map_block</code>映射到内存中。<br><code>read_super</code>用于读取和检验超级块。首先使用<code>read_block</code>将超级块信息读入内存；然后检查魔数；最后检查磁盘大小信息是否吻合。<br><code>read_bitmap</code>用于读取和检查位图。类似的，首先是读入位图，然后检查前两个磁盘块是否在使用，最后检查位图块全部在使用。<br><code>check_write_block</code>用于检查<code>wrtie_block</code>函数功能正常。</p><p>到这里，磁盘块的管理操作就完成了。</p></li></ul><h4 id="2-文件系统"><a href="#2-文件系统" class="headerlink" title="2.文件系统"></a>2.文件系统</h4><p>磁盘管理完成后，就可以在这个基础上完成文件系统的搭建了。</p><p>首先是管理文件的文件控制块<code>File</code>。这个结构体定义在include&#x2F;fs.h中，定义了文件名、文件大小、文件类型、文件数据块索引、文件上级目录，为了保证每个文件控制块大小固定，还设置了<code>f_pad</code>，用填充0的方法，保证了文件控制块大小为256字节。</p><p><img src="https://img-blog.csdnimg.cn/img_convert/755aa2dda57d2a42cc867357012fc24b.png" alt="img"></p><ul><li><p>fs&#x2F;fsformat.c</p><p>这个文件中定义了实验的文件系统的形式。里面定义了初始化磁盘、大端转换为小端、刷新位图等操作。</p><p><code>reverse</code>函数用于将大端存储的数据转换为小端格式。<br><code>reverse_block</code>函数用于将磁盘块的数据格式都转换过来。<br><code>init_disk</code>函数用于初始化磁盘。<br><code>flush_bitmap</code>函数用于刷新位图。<br><code>finish_fs</code>函数用于将设置好的磁盘写入到镜像文件中。<br><code>save_block_link</code>函数用于将被引用的磁盘块存进文件的索引中。<br><code>make_link_block</code>用于建立一个新的数据块引用。<br><code>create_file</code>用于在给定的目录中创建一个新的文件控制块指针。简单来说就是找到一个数据块中的空闲的文件索引，也就是没有存储信息的文件控制块，返回这个地址；如果没有数据块或者没找到空闲索引则使用<code>make_link_block</code>加入一个新的数据块。<br><code>write_file</code>用于在给定的目录下的一个文件写入到磁盘中。</p><p>通过了解这个文件，我们大概了解了文件和磁盘的关系。</p></li><li><p>fs&#x2F;fs.c</p><p>接下来我们就来完成具体的文件和磁盘交互的函数。</p><p><code>fs_init</code>函数完成了文件系统的初始化，也就是检查了超级块等信息是否正常。<br><code>file_block_walk</code>函数用于查找一个文件中某个文件块所在的磁盘块，并返回磁盘块的虚拟地址，这里所指的文件块就是文件控制块中索引的数据块。对于在直接索引中的文件块，直接返回那个块的地址即可；对于间接索引，如果没有间接索引且需要分配一个数据块，则使用<code>alloc_block</code>分配一个数据块，否则就报错，然后用<code>read_block</code>把这个块读入内存中，获得这个块的虚拟地址，加上文件块号的偏移；最后返回磁盘块的虚拟地址。<br><code>file_map_block</code>函数用于设置<code>*diskbno</code>为指定的文件块，也就是用一个。首先通过<code>file_block_walk</code>找到需要的文件块，如果没有且<code>alloc</code>被置位，则需要新建一个索引块，最后将这个块的编号赋给<code>*diskbno</code>。<br><code>file_clear_block</code>函数用于用于把一个文件块从文件中移除。先找到这个块，然后使用<code>free_block</code>释放这个块。<br><code>file_get_block</code>函数用于将文件块的数据读入<code>blk</code>中，也就是将<code>*blk</code>指向这个文件块。首先是用<code>file_map_block</code>找到磁盘块号，接着用<code>read_block</code>将这个块的地址赋给<code>blk</code>。<br><code>file_dirty</code>函数用于标记某个块为dirty。<code>*(volatile char *)blk = *(volatile char *)blk;</code>，这个倒是很神奇的一条语句，我也不知道怎么就能标记为dirty。<br><code>dir_lookup</code>函数用于查找目录下指定文件名的文件。做法也很简单，就是遍历目录文件的所有文件块，通过<code>file_get_block</code>读取数据，再检查这个块内所有文件控制块的文件名是否符合。<br><code>dir_alloc_file</code>函数用于在特定的目录下建立一个新的文件控制块。过程与<code>dir_lookup</code>类似，找到一个空白的文件控制块返回地址即可，而如果没找到，则需要建立新的文件块存放。<br><code>walk_path</code>函数用于给定一个路径，查找这个路径指向的文件。简单来说就是每一级目录查找下一级目录是否存在，直到找到目标文件。<br><code>file_open</code>函数利用<code>walk_path</code>函数实现打开一个给定路径的文件，也就是返回这个文件控制块的地址。<br><code>file_create</code>函数根据给出的路径创建对应的文件。做法就是通过<code>walk_path</code>找到文件地址，然后使用<code>dir_alloc_file</code>建立一个文件控制块，最后把文件名复制到对应的变量。<br><code>file_truncate</code>函数用于把一个文件截断到一个新的大小。做法也很容易，计算出前后两个文件块的数量，然后使用<code>file_clear_block</code>删除文件块即可，最后设置新的文件大小。<br><code>file_set_size</code>函数完成了将一个文件设置为新的大小。对于大于这个大小的文件，使用<code>file_truncate</code>截断文件，然后需要利用<code>file_flush</code>刷新文件所在的目录。<br><code>file_flush</code>函数用于更新磁盘的内容，具体做法就是遍历文件的所有文件块，检查每个文件块是否为dirty，然后写入磁盘。<br><code>fs_sync</code>函数则是刷新整个文件系统所有文件。<br><code>file_close</code>函数则是为关闭文件做准备，也就是将文件和所在目录刷新。<br><code>file_remove</code>函数则是删除一个文件。首先是通过<code>walk_path</code>找到文件，接着通过<code>file_truncate</code>将文件大小减到0，也就是删掉了文件内容，接着把文件名删除，最后更新这个文件和所在的目录。</p><p>到这里，我们已经能够进行查找文件、删除文件、更新文件(或许保存更贴切？)等宏观的操作，完成了文件系统与磁盘的接口。但对于用户来说，具体打开一个文件，对一个文件进行细致的读写操作我们还没有实现。</p></li></ul><h4 id="3-用户接口"><a href="#3-用户接口" class="headerlink" title="3.用户接口"></a>3.用户接口</h4><p>接下来我们需要设计文件系统与用户的交互接口，对于用户来说，对文件的操作无外乎打开、读写、关闭等操作，而并不太关心文件索引块的信息，因此就有了一个新的结构体：文件描述符<code>Fd</code>。但在此之前，先来看另一个结构体<code>Dev</code>。<br><code>Dev</code>结构体定义了一个外设的信息，如外设的编号、外设名、外设的读写等函数指针。在这个操作系统中，对外设的读写在用户层面来看可以认为就是读写一个文件，而每一种外设都有自己的特定读写函数，我猜测这些信息都存放在了设备控制表中。<br>接下来来看文件描述符<code>Fd</code>。这个结构体首先定义了<code>fd_dev_id</code>，这个指的是文件所在的设备编号，与<code>Dev</code>应该是对应的，接着是<code>fd_offset</code>，这个变量存放着文件读写头的位置，也就是当前读写文件的指针相对于文件头的偏移，最后是<code>fd_omode</code>，这个指的是文件打开的类型，比如只读、只写、读写。</p><ul><li><p>在这个文件中定义了一系列与<code>Fd</code>有关的函数。在文件的开头定义了全局变量<code>devtab</code>，也就是这个操作系统中支持的三种设备：文件<code>devfile</code>、终端<code>devcons</code>、管道<code>devpipe</code>。</p><p><code>dev_lookup</code>函数用于根据设备编号查找设备，也就是在<code>devtab</code>中查找设备。<br><code>fd_alloc</code>函数用于分配一个空闲的描述符。具体做法就是找到没有被使用的页面返回其地址。<br><code>fd_close</code>函数用于关闭一个文件描述符。具体做法就是移除所在页面的映射关系。<br><code>fd_lookup</code>函数用于根据一个文件描述符的编号得到对应的文件描述符。先检查编号的合法性，接着通过<code>INDEX2FD</code>获得描述符的地址，检查对应描述符的页表项有效后返回地址即可。<br><code>fd2data</code>函数通过给定的文件描述符返回文件起始数据地址。<br><code>fd2num</code>函数通过给定的描述符返回其编号。<br><code>num2fd</code>函数通过编号得到描述符。<br><code>close</code>函数通过给定的编号关闭对应的描述符。首先是获得文件描述符和设备；接着关闭设备和文件描述符。<br><code>close_all</code>是关闭所有的文件描述符。<br><code>dup</code>函数用于将一个文件复制到一个新的文件中。首先是找到旧的文件描述符，接着关闭新的描述符，获得新的描述符(这个操作到lab6就清楚了)；接着把旧的描述符映射到新的描述符处；最后把相关的页面都映射过去。<br><code>read</code>函数用于从<code>fd_offset</code>处读取n字节到<code>buf</code>中。同样，先找到描述符和设备；接着检查打开模式<code>fd_omode</code>是否有权限；然后调用<code>*dev_read</code>读取内容，更新<code>fd_offset</code>后返回。这个函数不一定最终会读取n字节。<br><code>readn</code>函数与<code>read</code>函数类似，不过这个函数只有在读取n字节后才会结束。具体来说就是不断调用<code>read</code>使得最后读取的字节数达到n。<br><code>write</code>函数与<code>read</code>类似，操作也基本一致，将读换成写即可。<br><code>seek</code>函数用于调整文件的读写头到指定位置，具体来说就是修改<code>fd_offset</code>。</p><p>到这里，我们就能够通过操作文件描述符来进行对文件内容的读写操作了。但是具体到每一个设备，我们还需要补全具体设备的相关函数即<code>*dev_read</code>等才能实现在用户界面对外设的读写。对于文件类的外设，具体的函数定义在了user&#x2F;file.c中。</p></li></ul><p>在具体实现文件类外设的读写时，实际上并不是直接操作<code>File</code>，而是通过文件系统来完成，为了方便与文件系统交互又设计了一种结构体<code>Filefd</code>，简单来说就是结合了<code>Fd</code>和<code>File</code>的结构体。这样即能够获取文件与用户的交互信息<code>Fd</code>，又能够知道文件与磁盘的交互信息<code>File</code>。而更精巧的是，得到<code>Filefd</code>并不困难，可以直接通过结构体的强制转换，从<code>Fd</code>转到<code>Filefd</code>，原因就在于<code>Filefd</code>利用<code>Fd</code>占位，这样就保证了后面的变量<code>f_fileid</code>和<code>f_file</code>访问地址正确。</p><ul><li><p>user&#x2F;file.c</p><p>文件的开头完善了<code>devfile</code>的信息。具体实现在下面。</p><p><code>open</code>函数实现了根据路径和模式打开一个文件。首先需要通过<code>fd_alloc</code>获得一个文件描述符；接着通过<code>fsipc_open</code>请求文件系统打开文件；接下来通过强制转换得到<code>Filefd</code>，设置相关的变量；最后请求文件系统分配内存将文件载入到内存中，返回描述符编号。<br><code>file_close</code>函数则是关闭一个文件。首先是获得<code>Filefd</code>的信息，接着得到文件数据的起始地址；遍历整个文件，请求文件系统处理dirty信息；请求文件系统关闭文件；如果这时的<code>size</code>还不为0，则需要手动通过<code>syscall_mem_unmap</code>移除文件的映射关系。<br><code>file_read</code>函数用于读取n字节信息。首先是得到文件的大小，检查能不能读n字节；如果可以，则使用<code>user_bcopy</code>将文件的信息复制到<code>buf</code>中。<br><code>read_map</code>函数用于找到文件内容所在的文件块。首先找到描述符，判断设备编号是否吻合，接着利用<code>fd2data</code>找到地址，判断这个地址是否有效，最后返回这个地址。<br><code>file_write</code>函数用于向当前读写的位置写入n字节数据。首先是利用<code>ftruncate</code>将文件扩大，接着把内容写到指定的位置。<br><code>ftruncate</code>函数用于截断或增长文件。首先找到文件描述符转成<code>Filefd</code>；接着请求文件系统申请更多的页面来存储信息或者使用系统调用移除多余的映射。<br><code>remove</code>函数用于删除文件或目录。<br><code>sync</code>函数用于更新磁盘。</p><p>到这里我们就完成了对于文件类设备的各种常用操作。但在开头我也提到，这些操作都需要请求文件系统才能完成。因此我们还缺少处理这些请求的函数。这些函数主要在user&#x2F;fsipc.c和fs&#x2F;serv.c中。</p></li></ul><h4 id="4-文件服务"><a href="#4-文件服务" class="headerlink" title="4.文件服务"></a>4.文件服务</h4><p>服务分为两部分，一边是用户程序将各种请求分类，统一成<code>fsipc</code>和请求类型发送给文件系统，一边是文件系统通过传入的请求类型进入相应的处理函数进行处理。</p><ul><li><p>user&#x2F;fsipc.c</p><p>这个文件就定义了一系列发送请求的函数，最终都统一成<code>fsipc</code>函数发送。</p><p><code>fsipc</code>函数就是最终发送请求的函数，通过进程间通信完成，也就是利用<code>ipc_send</code>向文件系统进程发送信息，然后利用<code>ipc_recv</code>返回处理结果。<br>而剩下的函数则大同小异，都是预处理一些信息，然后调用<code>fsipc</code>完成。</p></li><li><p>fs&#x2F;serv.c</p><p>这个文件定义了文件系统处理一系列请求的函数。主体函数是<code>serve</code>函数，这个函数是一个死循环，不断通过<code>ipc_recv</code>接收请求，申请一页临时处理内存，根据请求类型调用对应的处理函数完成处理，最后释放这块内存。</p><p>在文件开头定义了一个结构体<code>Open</code>，这个结构体就是文件系统内部处理文件时描述文件的结构体，包含了文件控制块、文件编号、打开方式、<code>Filefd</code>。从这里我们会发现，对于同一个文件，不同的视角来看，就会有不同的信息，比如底层看到的是文件控制块<code>File</code>，用户看到的是描述符<code>Fd</code>和<code>Filefd</code>，文件服务系统看到的是<code>Open</code>。</p><p><code>serve_init</code>函数用于初始化文件服务进程。<br><code>open_alloc</code>函数用于分配一个<code>Open</code>，也就是找到一个空闲的<code>Open</code>结构体。<br><code>open_lookup</code>函数用于查找一个进程打开的文件。</p><p><code>serve_open</code>函数用于处理打开文件的请求。首先得到文件路径，然后分配一个<code>Open</code>结构体，接着调用<code>file_open</code>打开文件，最后天写相关的信息，再通过<code>ipc_send</code>发回给用户进程即可。<br><code>serve_map</code>函数用于获得一个数据块。首先用<code>open_lookup</code>查找文件的<code>Open</code>结构体，接着计算需要查找的文件块，并通过<code>file_get_block</code>获得，把结果发送给用户。<br>剩下的函数基本是一个写法，通过<code>open_lookup</code>查找文件信息，调用fs.c中的函数完成具体处理，再通过<code>ipc_send</code>返回信息给用户进程。</p></li></ul><p>到这里，用户进程与文件服务系统进程的交互也完成了，现在一个用户进程就能够完成从磁盘读取一个文件、加载到内存中、打开这个文件对文件进行读写操作、并写回磁盘关闭文件的完整操作。文件系统就算是搭建完成了。</p>]]></content>
    
    
    <categories>
      
      <category>OS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>OS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>OS-Lab4</title>
    <link href="/2022/07/17/OS-Lab4/"/>
    <url>/2022/07/17/OS-Lab4/</url>
    
    <content type="html"><![CDATA[<h3 id="一-预备知识"><a href="#一-预备知识" class="headerlink" title="一.预备知识"></a>一.预备知识</h3><p>在前面三个Lab的实验中，我们成功的搭建起了操作系统的内核，建立了内存管理机制和进程调度机制。一般来说，进程是给用户使用的，而用户无法直接对系统内核进行存取。另一方面，进程与进程之间的虚拟地址互相独立，这使得两个进程之间的互相通信变得困难。但是，用户会在有些情况下需要使用只有内核才能进行的操作。为了解决这个问题，操作系统设计了系统调用。</p><p><img src="https://img-blog.csdnimg.cn/img_convert/116723916b3da0dd4df9601f4d69f3e9.png" alt="img"></p><p>指导书上已有的知识，我在此不再赘述。在进行实验之前，我们需要稍微补习一点知识，主要是关于汇编函数方面的东西。这些知识，指导书或者其他地方都有，只不过比较零碎。我稍微聚集了一下这些知识，如果想要了解的更详细，可以深入了解。</p><h4 id="1-汇编函数构造宏-include-x2F-asm-x2F-asm-h"><a href="#1-汇编函数构造宏-include-x2F-asm-x2F-asm-h" class="headerlink" title="1. 汇编函数构造宏(include&#x2F;asm&#x2F;asm.h)"></a>1. 汇编函数构造宏(include&#x2F;asm&#x2F;asm.h)</h4><p>为了方便的像C语言一样构造函数，我们的操作系统事先为我们提供了函数的宏，我们可以直接使用。这个宏的代码并非由本校人员开发，应当是较为通用的定义方式。文件中为我们提供了两种函数的宏，即叶函数（LEAF）和嵌套函数(NESTED)。</p><blockquote><p>我们把函数体中没有函数调用语句的函数称为叶函数，自然如果有函数调用语句的函数称为非叶函数。在MIPS 的调用规范中，进入函数体时会通过对栈指针做减法的方式为自身的局部变量、返回地址、调用函数的参数分配存储空间（叶函数没有后两者），在函数调用结束之后会对栈指针做加法来释放这部分空间，我们把这部分空间称为栈帧（Stack Frame）。</p><p>——OS指导书</p></blockquote><p>下面是宏的具体实现定义。可以看到，函数定义无非是声明一个全局符号，给定一个标签用于跳转和返回。</p><p>下面是文件中部分代码的引用。有些代码后面我没有写注释，是因为我自己也弄不太清楚，不敢乱讲，怕引起误会。如果有同学明白，希望可以给我讲讲。</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm"><span class="hljs-comment">#define LEAF(symbol)                            \</span><br>        .globl  symbol<span class="hljs-comment">;                         \声明&quot;symbol&quot;为全局变量</span><br>        <span class="hljs-meta">.align</span>  <span class="hljs-number">2</span><span class="hljs-comment">;                              \下一个数据的地址空间按字对齐</span><br>        .type   symbol,@function<span class="hljs-comment">;               \</span><br>        .ent    symbol,<span class="hljs-number">0</span><span class="hljs-comment">;                       \告诉汇编器&quot;symbol&quot;函数的起始点，用于调试</span><br><span class="hljs-symbol">        symbol:</span>         .frame  <span class="hljs-built_in">sp</span>,<span class="hljs-number">0</span>,<span class="hljs-built_in">ra</span>          提供一个名为<span class="hljs-string">&quot;symbol&quot;</span>的标签，将跳转到此处<br><br><span class="hljs-comment">#define NESTED(symbol, framesize, rpc)          \</span><br>        .globl  symbol<span class="hljs-comment">;                         \</span><br>        <span class="hljs-meta">.align</span>  <span class="hljs-number">2</span><span class="hljs-comment">;                              \</span><br>        .type   symbol,@function<span class="hljs-comment">;               \</span><br>        .ent    symbol,<span class="hljs-number">0</span><span class="hljs-comment">;                       \</span><br><span class="hljs-symbol">        symbol:</span>         .frame  <span class="hljs-built_in">sp</span>, framesize, rpc   确定栈帧大小以及结束时的返回地址<br><br><span class="hljs-comment">#define END(function)                           \</span><br>        <span class="hljs-meta">.end</span>    function<span class="hljs-comment">;                       \指出函数结尾，用于调试</span><br>        .size   function,.-function              在符号表中列出函数名和函数指令字节数<br></code></pre></td></tr></table></figure><h4 id="2-C函数和汇编函数的参数、返回值传递"><a href="#2-C函数和汇编函数的参数、返回值传递" class="headerlink" title="2.C函数和汇编函数的参数、返回值传递"></a>2.C函数和汇编函数的参数、返回值传递</h4><p>有时候，我们会不可避免的在C语言中调用汇编函数，也会在汇编语言中调用C函数。根据MIPS软件标准(ABI)的定义，函数的参数传递按照如下原则：</p><ul><li>如果函数参数个数≤4，则将参数依次存入a0-a3寄存器中，并在栈帧底部保留16字节的空间（即sp的值减去16），但并不一定使用这些空间。</li><li>如果函数参数个数&gt;4，则前4个参数依次存入a0-a3寄存器中，从第5个参数开始，依次在前4个参数预留空间之外的空间内存储，即没有寄存器去保存这些值。</li><li>举例，如果一个C函数有6个参数，在汇编语言中需要调用的时候，应当将前4个参数存在a0-a3寄存器中，第5个参数存在16(sp)的位置，第6个参数存在20(sp)的位置。区间0-15的空间保留但不使用。</li></ul><p><img src="https://img-blog.csdnimg.cn/img_convert/b77fb78ef5ddbb6e32bd214d6d53c340.png" alt="img"></p><p>而关于函数的返回值，MIPS ABI规定，返回值存在v0寄存器中。某些特殊的情况下也会用到v0寄存器中。某些特殊的情况下也会用到v1寄存器，但不常见。想了解更多关于返回值的知识，请查阅书籍<em>See MIPS Run Linux</em>。</p><h4 id="3-栈帧方法宏-include-x2F-stackframe-h"><a href="#3-栈帧方法宏-include-x2F-stackframe-h" class="headerlink" title="3.栈帧方法宏(include&#x2F;stackframe.h)"></a>3.栈帧方法宏(include&#x2F;stackframe.h)</h4><p>我们在进行用户态和内核态之间的切换，或者进程之间的切换时，需要保存现场。所谓现场，就是include&#x2F;trap.h中所定义的trap结构体，其中包含的信息有：</p><ul><li>32个寄存器的值</li><li>CP0部分寄存器的值</li><li>HI、LO两个乘除法寄存器的值</li><li>程序的指令计数器PC</li></ul><p>但是这个文件中只有结构体的定义，没有将数据存入结构体的操作。将寄存器中的值存入内存，显然要用汇编语言去完成。stackframe.h中定义了一些汇编函数的宏，方便我们对现场进行存取操作。下面摘录了其中的宏，并作出相应的解释。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs assembly">//TF_SIZE是Trapframe寄存器的字节大小<br>.macro STI//Set Interrupt，打开全局中断使能（允许中断）<br>.macro CLI//Close Interrupt，关闭全局中断使能（屏蔽中断）<br>.macro SAVE_ALL             //保存所有现场，将数据以Trapframe结构体形式存在sp为开头的空间中<br>.macro RESTORE_SOME         //恢复部分现场，此处的“部分”仅不包括sp的值<br>.macro RESTORE_ALL          //恢复所有现场，包括栈顶的位置<br>.macro RESTORE_ALL_AND_RET  //恢复现场并从内核态中返回<br>.macro get_sp               //获取栈顶位置，此函数会判断当前的状态是异常还是中断，<br>                            //从而决定栈顶是TIMESTACK还是KERNEL_SP。<br>                            //系统调用是编号为8的异常，进程切换是时钟中断信号。<br></code></pre></td></tr></table></figure><h3 id="二-系统调用"><a href="#二-系统调用" class="headerlink" title="二.系统调用"></a>二.系统调用</h3><h4 id="1-什么是系统调用"><a href="#1-什么是系统调用" class="headerlink" title="1.什么是系统调用"></a>1.什么是系统调用</h4><p>在硬件实现上，用户态的进程无法访问内核的地址空间，这意味着：</p><ul><li>无法存取内核内存数据</li><li>无法调用内核函数</li></ul><p>而所有对硬件的操作都是内核函数，因此用户需要使用系统调用来调用内核的函数。</p><h4 id="2-进入系统调用"><a href="#2-进入系统调用" class="headerlink" title="2.进入系统调用"></a>2.进入系统调用</h4><p>一件事情在脑海中浮现，在MIPS编程中我们是这样进行输入输出——向特定寄存器存放特殊值并调用syscall。而MOS中我们也是这样做的，系统调用的关键就在于用户态和内核态的切换，而这个切换就是在我们调用syscall指令时产生的。</p><p>而就在syscall指令调用后，CPU在硬件层面陷入内核态，其将触发异常分发机制，并最终调用到<code>handle_sys()</code>函数。该函数相当于系统调用的分发，其根据某特定寄存器的值从而找到需要调用的内核函数。</p><blockquote><p>你将见到这几种函数：</p><ul><li><p>syscall_……：用户空间内的函数，与sys_……成对存在</p></li><li><p>msyscall：设置系统调用号并让系统陷入内核态的函数</p></li><li><p>sys_……：内核函数</p><p>有趣的是，在这里我们会发现msyscall需要6个参数，这引起了我们的一个新知识点：大量的参数是如何进行传递的？<br>对于nn个参数的传递，栈帧sp会保留n∗4n∗4个字节的空间，而前4个参数会被放在a0到a3这四个寄存器中，但是栈帧中对应空间还是会被预留，其余参数存储在前四个参数的预留空间之上的区域。</p></li></ul></blockquote><p>注意到一个问题，多于四个的参数会被放到内存中，而这个空间是存在于用户态的，因此我们需要在内核中将这些参数转移到内核空间内，这步工作需要在<code>handle_sys()</code>函数的汇编代码实现了。</p><p>我们先来整理一下在MOS中进行系统调用的流程：</p><ol><li>调用一个封装好的用户空间的库函数（如writef）</li><li>调用用户空间的syscall_* 函数</li><li>调用msyscall，用于陷入内核态</li><li>陷入内核，内核取得信息，执行对应的内核空间的系统调用函数（sys_*）</li><li>执行系统调用，并返回用户态，同时将返回值“传递”回用户态</li><li>从库函数返回，回到用户程序调用处</li></ol><p><strong>msyscall</strong></p><p>msyscall执行的职能只是陷入内核态，并不涉及系统调用的分发。</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm"><span class="hljs-keyword">syscall</span><br><span class="hljs-keyword"></span><span class="hljs-keyword">jr </span><span class="hljs-built_in">ra</span><br><span class="hljs-keyword">nop</span><br></code></pre></td></tr></table></figure><p><strong>handle_sys</strong></p><p>syscall发生后，OS根据中断向量发现是调用了系统调用，从而通过中断分发到<code>handle_sys</code>函数。</p><p><code>handle_sys</code>函数通过分析传入的参数来找到具体的系统调用目标函数，并将传入的参数放到寄存器中，然后进入目标函数。</p><h3 id="三-进程通信-IPC"><a href="#三-进程通信-IPC" class="headerlink" title="三.进程通信 IPC"></a>三.进程通信 IPC</h3><p>进程间通信机制是基于系统调用来实现的。通信的本质就是交换数据，而交换数据的最大问题在于：在进程间，用户地址空间相互独立。</p><p>因此，我们需要通过以内核的2g空间来作为传递信息的媒介，同时我们可以发现，进程控制块是存储在内核空间内的，因此我们完全可以将需要传递的数据放在目标的进程控制块内，然后目标进程在从中读取。</p><p><a href="https://img2020.cnblogs.com/blog/2028226/202105/2028226-20210510193425197-1567369399.png"><img src="https://img-blog.csdnimg.cn/img_convert/4ead8de0f9fcfe0ec44a66ced90d877e.png" alt="image"></a></p><blockquote><p><em>值得一提的是，由于在我们的用户程序中，会大量使用srcva 为0 的调用来表示不需要传递物理页面，因此在编写相关函数时也需要注意此种情况。</em></p></blockquote><p>这两个过程是通过系统调用中的<code>sys_ipc_recv</code>与<code>sys_ipc_can_send</code>来实现。</p><p>前者需要将当前接收者的进程控制块的相应域设置好，并使用<code>sys_yield</code>使得当前进程放弃CPU。</p><p>后者需要检查目标是否准备好接受，并修改目标进程的进程控制块，将需要的信息放到他们的进程控制块内。</p><blockquote><p>需要注意，<em>如果需要传递物理页面信息，需要调用sys_mem_map函数将当前进程srcva对应位置的页面映射到目标进程的dstva处</em>。</p></blockquote><h3 id="四-Fork函数"><a href="#四-Fork函数" class="headerlink" title="四.Fork函数"></a>四.Fork函数</h3><p>fork函数能够从一个进程生成另一个进程，使得子进程拥有和旧进程绝大部分相同的信息。同时，fork会在父子进程中拥有不同的返回值。</p><ul><li>在fork 之前的代码段只有父进程会执行。</li><li>在fork 之后的代码段父子进程都会执行。</li><li>fork 在不同的进程中返回值不一样，在父进程中返回值不为0，在子进程中返回值为0。</li><li>父进程和子进程虽然很多信息相同，但他们的env_id 是不同的。</li></ul><p><a href="https://img2020.cnblogs.com/blog/2028226/202105/2028226-20210510193827711-1922362404.png"><img src="https://img-blog.csdnimg.cn/img_convert/6362b59d3b50d7331309cd0b8f0b5b1e.png" alt="image"></a></p><h5 id="写时复制机制"><a href="#写时复制机制" class="headerlink" title="写时复制机制"></a>写时复制机制</h5><p>父进程会为子进程设置虚拟空间，但是我们通过上图能够发现，实际的分配过程其实是通过duppage复制页表，并设置PTE_COW。COW就是写时复制的意思（Copy On Write）。</p><p>只有当父子进程中有修改内存的举动时，内核会根据PTE_COW捕获中断（一般指缺页中断，Page Fault），并单独为修改内存的进程分配物理页面，然后将该页面复制过去后再实行修改。</p><h5 id="区分父子进程的理论基础"><a href="#区分父子进程的理论基础" class="headerlink" title="区分父子进程的理论基础"></a>区分父子进程的理论基础</h5><p>fork()能够通过返回值来区别当前进程是否是子进程，若返回值为0则为子进程，否则为父进程。</p><p>而实现返回值差异性的函数是<code>syscall_env_alloc</code>函数，其属于用户函数，其触发系统调用后进行<code>sys_env_alloc</code>来创建和初始化一个新进程块。</p><p><strong>sys_env_alloc</strong></p><p>这个函数需要利用当前进程为模板来填写一个新的子进程块。其工作包括复制一份当前的运行现场<strong>、</strong>复制一下当前的PC值<strong>、</strong>修改子进程状态为阻塞、以及初始化其他进程控制块信息。</p><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs xl">int sys_env_alloc(void)<br>&#123;<br>int r;<br>struct Env *e;<br><span class="hljs-function"><span class="hljs-title">r</span> = env_alloc(&amp;e, curenv-&gt;</span>env_id);<br><span class="hljs-keyword">if</span> (r &lt; <span class="hljs-number">0</span>) return r;<br><span class="hljs-function"><span class="hljs-title">e</span>-&gt;</span>env_status = ENV_NOT_RUNNABLE;<br><span class="hljs-function"><span class="hljs-title">e</span>-&gt;</span><span class="hljs-function"><span class="hljs-title">env_pri</span> = curenv-&gt;</span>env_pri;<br><span class="hljs-function"><span class="hljs-title">bcopy</span>((void *)KERNEL_SP - sizeof(struct Trapframe), (void *)&amp;(e-&gt;</span>env_tf), sizeof(struct Trapframe));<br><span class="hljs-function"><span class="hljs-title">e</span>-&gt;</span><span class="hljs-function"><span class="hljs-title">env_tf</span>.pc = e-&gt;</span>env_tf.cp0_epc;<br><span class="hljs-function"><span class="hljs-title">e</span>-&gt;</span>env_tf.regs[<span class="hljs-number">2</span>] = <span class="hljs-number">0</span>;<br><br><span class="hljs-function"><span class="hljs-title">return</span> e-&gt;</span>env_id; <span class="hljs-comment">// 注意这个返回值是返回到父进程的</span><br>&#125;<br></code></pre></td></tr></table></figure><h5 id="在分道扬镳后，父子各自的工作"><a href="#在分道扬镳后，父子各自的工作" class="headerlink" title="在分道扬镳后，父子各自的工作"></a>在分道扬镳后，父子各自的工作</h5><p><strong>子进程</strong></p><p>子进程当前虽然拥有了一个进程控制块，但是仍然存在着几个问题：</p><ul><li>子进程被第一次调度时，其处在fork函数中（准确来说，是syscall_env_alloc返回后），此时函数中的各个变量仍然指向父进程中对应数据结构，子进程如何替换掉这些变量？</li><li>子进程的用户空间没有初始化，如何实现COW的设想？</li></ul><p>我们将在子进程中解决第一个问题，而第二个问题交由父进程解决</p><p><strong>设置进程控制块</strong></p><p>当从<code>syscall_env_alloc</code>返回后，子进程需要将当前函数内的进程控制块指针改为自己的。这一步通过调用<code>syscall_getenvid</code>这一系统调用实现。这一步后，子进程就能够从fork函数退出了（虽然当前处于阻塞状态）。</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs haxe"><span class="hljs-keyword">new</span><span class="hljs-type">envid</span> = syscall_env_alloc();<br><span class="hljs-keyword">if</span>(<span class="hljs-keyword">new</span><span class="hljs-type">envid</span>==<span class="hljs-number">0</span>) &#123;env = envs + ENVX(syscall_getenvid());<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;<br></code></pre></td></tr></table></figure><p><strong>父进程</strong></p><p>父进程需要为子进程进行很多初始化工作，包括遍历进程空间并合理设置空间权限，实现空间共享<strong>、</strong>实现写时复制的缺页中断机制</p><p><strong>进程映射</strong></p><p>通过遍历当前页目录，将页面按以下规则进行设置：</p><ul><li><strong>只读页面</strong> 按照相同权限（只读）映射给子进程即可</li><li><strong>共享页面</strong> 即具有PTE_LIBRARY 标记的页面，这类页面需要保持共享的可写的状态</li><li><strong>写时复制页面</strong> 即具有PTE_COW 标记的页面，这类页面是上一次的fork 的duppage的结果</li><li><strong>可写页面</strong> 需要给父进程和子进程的页表项都加上PTE_COW 标记</li></ul><p>这个功能由<code>duppage</code>函数实现。</p><p><strong>缺页中断</strong></p><p>MIPS下存在两种缺页中断。一种是TLB缺失导致的缺页中断，其会触发trap并分发到<code>handle_tlb</code>下，然后按照正常逻辑进行查表、重填等，此处按下不表。</p><p>另一种是写时复制触发的缺页中断，其会触发trap分发到另一个处理函数<code>handle_mod</code>下。这个函数会跳转到<code>page_fault_handler</code>下，处理当前写时复制异常。</p><p>注意！MOS系统在此处应用了微内核的思想，将处理异常的方式交由用户进程自身，即在进程控制块内定义了一个域<code>env_pgfault_handler</code>用于指定异常处理的函数，使得用户能够自定义处理过程。</p><p>处理写时复制异常的流程为：</p><ol><li><code>page_fault_handler</code>将当前现场保存在异常处理栈中，设置epc的值，以使得中断退出后跳转到指定用户进程指定的异常处理函数中。</li><li>退出中断，此时根据epc地址跳转到指定函数（注意这个函数是fork.c中的<code>pgfault</code>函数，这意味着它是用户态下执行的）中，处理缺页，然后恢复现场和sp寄存器，令进程恢复执行。</li></ol><h3 id="五-实验难点图解"><a href="#五-实验难点图解" class="headerlink" title="五.实验难点图解"></a>五.实验难点图解</h3><h4 id="1-MIPS调用规范（ABI）"><a href="#1-MIPS调用规范（ABI）" class="headerlink" title="1.MIPS调用规范（ABI）"></a>1.MIPS调用规范（ABI）</h4><p>MIPS ABI规定寄存器传参不需要复制到堆栈内<br><img src="https://img-blog.csdnimg.cn/d0adbe28df014c20bd4c8d7a04171beb.png" alt="在这里插入图片描述"></p><h4 id="2-进程间通信机制"><a href="#2-进程间通信机制" class="headerlink" title="2.进程间通信机制"></a>2.进程间通信机制</h4><p>进程间通信机制是基于系统调用来实现的。通信的本质就是交换数据。</p><p>这是通过系统调用中的<code>sys_ipc_recv</code>与<code>sys_ipc_can_send</code>来实现的。</p><p>前者需要将当前接收者的进程控制块的相应域设置好，并使用<code>sys_yield</code>使得当前进程放弃CPU。</p><p>后者需要检查目标是否准备好接受，并修改目标进程的进程控制块，将需要的信息放到他们的进程控制块内。<br><img src="https://img-blog.csdnimg.cn/681ed3bca76340449ab034513b02563a.png" alt="在这里插入图片描述"></p><h4 id="3-缺页中断的处理流程"><a href="#3-缺页中断的处理流程" class="headerlink" title="3.缺页中断的处理流程"></a>3.缺页中断的处理流程</h4><p><img src="https://img-blog.csdnimg.cn/e3bd09c97ec54b94b5e6c380f0fdfc82.png" alt="在这里插入图片描述"></p>]]></content>
    
    
    <categories>
      
      <category>OS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>OS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>OS-Lab3</title>
    <link href="/2022/07/17/OS-Lab3/"/>
    <url>/2022/07/17/OS-Lab3/</url>
    
    <content type="html"><![CDATA[<h3 id="一、进程相关函数"><a href="#一、进程相关函数" class="headerlink" title="一、进程相关函数"></a>一、进程相关函数</h3><p>在做lab3的实验时，发现函数嵌套的情况很多，首先整理这一块的逻辑。</p><p><img src="https://img-blog.csdnimg.cn/img_convert/9f6abdf31070433526fb37a1dbc9fed5.png" alt="img"></p><p>箭头表示函数调用</p><h4 id="1-初始化："><a href="#1-初始化：" class="headerlink" title="1.初始化："></a>1.初始化：</h4><ul><li>申请envs[]的空间；初始化env_free_list（把空闲进程env_status设置为ENV_FREE）</li></ul><h4 id="2-创立进程：设置env-pri"><a href="#2-创立进程：设置env-pri" class="headerlink" title="2.创立进程：设置env_pri"></a>2.创立进程：设置env_pri</h4><ul><li><p>env_alloc（）：</p><ul><li><p>从env_free_list取出一块空闲进程；</p></li><li><p>设置env_id，env_status，env_parent_id，env_tf.cp0_status，env_tf.regs[29]</p></li><li><p>env_setup_vm（）：</p></li><li><ul><li>为进程创建一页页目录，并建立好自映射</li><li>设置env_pgdir，env_cr3</li></ul></li></ul></li><li><p>load_icode（）：</p><ul><li>为进程申请一页作为栈，并建立好映射</li><li>设置env_tf.pc（为load_elf返回的binary的入口）</li><li>load_elf（）&#x2F;load_icode_mapper（）：<ul><li>以一个段（segment）为单位，把binary（进程的内容的二进制镜像）的内容复制到所在内存的虚拟地址</li><li>（load_elf负责找入口，mapper负责copy）</li></ul></li></ul></li></ul><h4 id="3-切换进程"><a href="#3-切换进程" class="headerlink" title="3.切换进程"></a>3.切换进程</h4><ul><li>保存当前进程的上下文，设置env_tf，env_tf.pc</li><li>恢复要启动的进程上下文，并启动新进程，设置env_status，env_pgdir，操作了env_tf，env_id</li></ul><h3 id="二、进程控制块-PCB"><a href="#二、进程控制块-PCB" class="headerlink" title="二、进程控制块(PCB)"></a>二、进程控制块(PCB)</h3><p>进程控制块(PCB) 是系统为了管理进程设置的一个专门的数据结构，用它来记录进程的外部特征，描述进程的运动变化过程。系统利用PCB 来控制和管理进程，所以 PCB 是系统感知进程存在的唯一标志 。</p><p>首先贴出PCB的构成。</p><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs gauss"> <span class="hljs-number">1</span> <span class="hljs-keyword">struct</span> <span class="hljs-type">Env</span> &#123;<br> <span class="hljs-number">2</span> <span class="hljs-comment">/* Trapframe 结构体的定义在include/trap.h 中，</span><br><span class="hljs-comment"> 3  * env_tf 的作用就是在进程因为时间片用光不再运行时，</span><br><span class="hljs-comment"> 4  * 将其当时的进程上下文环境保存在env_tf 变量中。</span><br><span class="hljs-comment"> 5  * 当从用户模式切换到内核模式时，内核也会保存进程上下文，</span><br><span class="hljs-comment"> 6  * 因此进程返回时上下文可以从中恢复。</span><br><span class="hljs-comment"> 7  */</span><br> <span class="hljs-number">8</span> <span class="hljs-keyword">struct</span> <span class="hljs-type">Trapframe</span> env_tf; <span class="hljs-comment">// Saved registers</span><br> <span class="hljs-number">9</span> <br><span class="hljs-number">10</span> <span class="hljs-built_in">LIST_ENTRY</span>(Env) env_link; <span class="hljs-comment">// Free LIST_ENTRY 构造空闲进程链表。</span><br><span class="hljs-number">11</span> <br><span class="hljs-number">12</span> u_int env_id; <span class="hljs-comment">// Unique environment identifier</span><br><span class="hljs-number">13</span> <br><span class="hljs-number">14</span> <span class="hljs-comment">/*该变量存储了创建本进程的进程id。</span><br><span class="hljs-comment">15  *这样进程之间通过父子进程之间的关联可以形成一颗进程树。</span><br><span class="hljs-comment">16  */</span><br><span class="hljs-number">17</span> u_int env_parent_id; <span class="hljs-comment">// env_id of this env&#x27;s parent</span><br><span class="hljs-number">18</span> <span class="hljs-comment">/*env_status : 该变量只能在以下三个值中进行取值：</span><br><span class="hljs-comment">19   – ENV_FREE : 表明该进程是不活动的，即该进程控制块处于进程空闲链表中。</span><br><span class="hljs-comment">20 </span><br><span class="hljs-comment">21   – ENV_NOT_RUNNABLE : 表明该进程处于阻塞状态，处于该状态的进程往往在</span><br><span class="hljs-comment">22     等待一定的条件才可以变为就绪状态从而被CPU 调度。</span><br><span class="hljs-comment">23 </span><br><span class="hljs-comment">24   – ENV_RUNNABLE : 表明该进程处于就绪状态，正在等待被调度，但处于RUNNABLE </span><br><span class="hljs-comment">25     状态的进程可以是正在运行的，也可能不在运行中。*/</span><br><span class="hljs-number">26</span> u_int env_status; <span class="hljs-comment">// Status of the environment</span><br><span class="hljs-number">27</span> <br><span class="hljs-number">28</span> Pde *env_pgdir; <span class="hljs-comment">// Kernel virtual address of page dir 这个变量保存了该进程页目录的虚拟地址。</span><br><span class="hljs-number">29</span> <br><span class="hljs-number">30</span> u_int env_cr3;<span class="hljs-comment">// 这个变量保存了该进程页目录的物理地址。</span><br><span class="hljs-number">31</span> <br><span class="hljs-number">32</span> <span class="hljs-built_in">LIST_ENTRY</span>(Env) env_sched_link;<span class="hljs-comment">//这个变量来构造就绪状态进程链表。</span><br><span class="hljs-number">33</span> <br><span class="hljs-number">34</span> u_int env_pri;<span class="hljs-comment">//这个变量保存了该进程的优先级。</span><br><span class="hljs-number">35</span> <br><span class="hljs-number">36</span> &#125;;<br></code></pre></td></tr></table></figure><h4 id="1-env-tf"><a href="#1-env-tf" class="headerlink" title="1.env_tf"></a>1.env_tf</h4><p>env_tf的类型是struct Trapframe，定义在trap.h中。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"> <span class="hljs-number">1</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">Trapframe</span> &#123; <span class="hljs-comment">//lr:need to be modified(reference to linux pt_regs) TODO</span><br> <span class="hljs-number">2</span>         <span class="hljs-comment">/* Saved main processor registers. */</span><br> <span class="hljs-number">3</span>         <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> regs[<span class="hljs-number">32</span>];<br> <span class="hljs-number">4</span> <br> <span class="hljs-number">5</span>         <span class="hljs-comment">/* Saved special registers. */</span><br> <span class="hljs-number">6</span>         <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> cp0_status;<br> <span class="hljs-number">7</span>         <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> hi;<br> <span class="hljs-number">8</span>         <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> lo;<br> <span class="hljs-number">9</span>         <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> cp0_badvaddr;<br><span class="hljs-number">10</span>         <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> cp0_cause;<br><span class="hljs-number">11</span>         <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> cp0_epc;<br><span class="hljs-number">12</span>         <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> pc;<br><span class="hljs-number">13</span> &#125;;<br></code></pre></td></tr></table></figure><p>①<strong>regs[29]：</strong>通用寄存器中的29号是栈寄存器，在env_alloc（）的时候设置为USTACKTOP（是用户栈，内核栈在0x8040 0000）</p><p><img src="https://img-blog.csdnimg.cn/img_convert/83cc2fb8904288d29efaa67497242d82.png" alt="img"></p><p>我们回忆起在load_icode（）也申请了一页作为栈映射到了USTACKTOP-BY2PG。刚好是regs[29]所在起始位置的下一页。</p><p>所以在env_alloc（）的时候调整了栈指针的位置为USTACKTOP，在env_icode（）时为栈专门申请了一页的空间[USTACKTOP-BY2PG，USTACKTOP]。</p><p>②<strong>pc：程序计数器，用于存放下一条指令的地址</strong></p><p>上面的函数我们一共有两个地方用到了pc。</p><p>第一处在env_alloc（）</p><p>e-&gt;env_tf.pc &#x3D; entry_point;</p><p>即将进程的起始地址移动到了binary的e_entry，可执行程序入口点地址。</p><p>第二处在env_run（）</p><p>curenv-&gt;env_tf.pc &#x3D; curenv-&gt;env_tf.cp0_epc;</p><p>env_tf.cp0_epc存的是下一条指令的地址，则将下一个pc的地址保存了，回复这个进程的时候可以直接跳转到那个位置。</p><p>③<strong>cp0_status</strong></p><p>在env_alloc（）中进行了这样的设置：</p><p>e-&gt;env_tf.cp0_status &#x3D; 0x10001004;</p><p>指导书中提到“MIPSR3000 里的SR(status register) 寄存器就是我们在env_tf里的cp0_ status，R3000 的SR 寄存器的低六位是一个二重栈的结构。”</p><p>二重栈在这个地方应该是指以大小2为单位的栈。所以实际上在中断发生和中断恢复时，会经历这样的倒腾。</p><blockquote><p>KUo 和IEo 是一组，每当中断发生的时候，硬件自动会将KUp 和IEp 的数值拷贝到这里；KUp 和IEp 是一组，当中断发生的时候，硬件会把KUc 和IEc 的数值拷贝到这里。其中KU 表示是否位于内核模式下，为1 表示位于内核模式下；IE 表示中断是否开启，为1 表示开启，否则不开启2。</p><p>而每当rfe 指令调用的时候，就会进行上面操作的逆操作。—《指导书》</p></blockquote><p>我后来发现PPT里有，请跳过这部分。</p><p>这一段没有关于KUo、IEo、KUp、IEp、KUc、IEc的解释，我估计是这样的，画图说明。</p><p><img src="https://img-blog.csdnimg.cn/img_convert/fcdb44a46b5fb9f3c5ff5d8abdd4a978.png" alt="img"></p><blockquote><p>下面这一段代码在运行第一个进程前是一定要执行的，所以就一定会执行rfe这条指令。</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm"><span class="hljs-keyword">lw </span><span class="hljs-built_in">k0</span>,TF_STATUS(<span class="hljs-built_in">k0</span>) <span class="hljs-comment"># 恢复CP0_STATUS 寄存器</span><br><span class="hljs-keyword">mtc0 </span><span class="hljs-built_in">k0</span>,CP0_STATUS<br><span class="hljs-keyword">j </span><span class="hljs-built_in">k1</span><br>rfe<br></code></pre></td></tr></table></figure></blockquote><p>KU：1–内核态，0–用户态；IE：1–开启中断，0–关闭中断。（这里应该是看KUc，IEc）</p><p>rfe会发生类似于中断恢复的操作，往右移动。我们为了设置初始状态为000001b（进入用户态，开启中断），所以我们先设置为000100b，再触发ref指令，使之变成000001b。</p><p>我们之前的设置是e-&gt;env_tf.cp0_status &#x3D; 0x10001004;其中还设置了“第28bit 设置为1，表示处于用户模式下。第12bit 设置为1，表示4 号中断可以被响应。”</p><h4 id="2-lcontext-curenv-gt-env-pgdir"><a href="#2-lcontext-curenv-gt-env-pgdir" class="headerlink" title="2.lcontext(curenv-&gt;env_pgdir)"></a>2.lcontext(curenv-&gt;env_pgdir)</h4><p>curenv-&gt;env_pgdir是页目录的内核虚拟地址<br>lontext 中有一句指令sw a0,mCONTEXT （a0是第一个参数即新进程的内核虚拟地址）</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">LEAF</span><span class="hljs-params">(lcontext)</span></span><br><span class="hljs-selector-class">.extern</span>mCONTEXT<br>swa0,mCONTEXT<br>jrra<br>nop<br><span class="hljs-function"><span class="hljs-title">END</span><span class="hljs-params">(lcontext)</span></span><br></code></pre></td></tr></table></figure><p>在pmap.c中有这样一句mCONTEXT &#x3D; (int)pgdir;是把全新的页目录kva存到mCONTEXT<br>这里就是把curenv的页目录kva存到mCONTEXT,mCONTEXT除了第一次创建页目录的使用,还会在do_refill里使用，这里暂不了解。这里大概是为了开启一个全新的进程时需要创建进程的页目录，需要mCONTEXT。</p><h3 id="三、关键函数理解"><a href="#三、关键函数理解" class="headerlink" title="三、关键函数理解"></a>三、关键函数理解</h3><p>首先第一部分我觉得比较关键的是对于一些非常关键的函数的理解与把握，这些函数是我们本次实验的精华所在，虽然好几个实验都不需要我们自己实现。首先是从第一个我们要填的函数说起吧：</p><h4 id="1-env-init"><a href="#1-env-init" class="headerlink" title="1.env_init"></a>1.env_init</h4><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">void<br>env<span class="hljs-constructor">_init(<span class="hljs-params">void</span>)</span><br>&#123;<br>       <span class="hljs-built_in">int</span> i;<br><br><span class="hljs-comment">/*precondition: envs pointer has been initialized at mips_vm_init, called by mips_init*/</span><br>       <span class="hljs-comment">/*1. initial env_free_list*/</span><br>       <span class="hljs-constructor">LIST_INIT(&amp;<span class="hljs-params">env_free_list</span>)</span>;<br>       <span class="hljs-comment">//step 1;</span><br>       <span class="hljs-comment">/*2. travel the elements in &#x27;envs&#x27;, initial every element(mainly initial its status, mark it as free) and inserts them into</span><br><span class="hljs-comment">       the env_free_list. attention :Insert in reverse order */</span><br>       <span class="hljs-keyword">for</span>(i=NENV-<span class="hljs-number">1</span>;i&gt;=<span class="hljs-number">0</span>;i--)&#123;<br>             envs<span class="hljs-literal">[<span class="hljs-identifier">i</span>]</span>.env_status = ENV_FREE;<br>             <span class="hljs-constructor">LIST_INSERT_HEAD(&amp;<span class="hljs-params">env_free_list</span>,<span class="hljs-params">envs</span>+<span class="hljs-params">i</span>,<span class="hljs-params">env_link</span>)</span>;<br>       &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>　　以上是env_init的实现。就是初始化env_free_list，然后按逆序插入envs[i]。</p><p>　　这里唯一值得并需要引起警惕的是逆序，因为我们使用的是LIST_INSERT_HEAD这个宏，任何一个对齐有所了解的人应该都知道，这个宏每次都会将一个结点插入，变成链表的第一个可用结点，而我们在取用的时候是使用LIST_FIRST宏来取的，所以如果这里写错了的话，可能在调度算法里就要有所更改。</p><p>　　可能会有同学问为什么NENV是envs的长度，这个实际上在pmap.c里面的mips_vm_init里可以找到我们的证据，证明envs数组确实给它分配了NENV个结构体的空间，所以它也就有NENV个元素了。</p><h4 id="2-env-setup-vm"><a href="#2-env-setup-vm" class="headerlink" title="2.env_setup_vm"></a>2.env_setup_vm</h4><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs xl">static int<br>env_setup_vm(struct Env *e)<br>&#123;<br>       <span class="hljs-comment">// Hint:</span><br><br>       int i, r;<br>       struct Page *p = NULL;<br><br>       Pde *pgdir;<br>       <span class="hljs-keyword">if</span> ((r = page_alloc(&amp;p)) &lt; <span class="hljs-number">0</span>)<br>       &#123;<br>               panic(<span class="hljs-string">&quot;env_setup_vm - page_alloc error\n&quot;</span>);<br>                       return r;<br>       &#125;<br>       <span class="hljs-function"><span class="hljs-title">p</span>-&gt;</span>pp_ref++;<br>       <span class="hljs-function"><span class="hljs-title">e</span>-&gt;</span>env_pgdir = (void *)page2kva(p);<br>       <span class="hljs-function"><span class="hljs-title">e</span>-&gt;</span>env_cr3 = page2pa(p);<br><br>       static_assert(UTOP % PDMAP == <span class="hljs-number">0</span>);<br>       <span class="hljs-keyword">for</span> (i = PDX(UTOP); i &lt;= PDX(~<span class="hljs-number">0</span>); i++)<br>         <span class="hljs-function"><span class="hljs-title">e</span>-&gt;</span>env_pgdir[i] = boot_pgdir[i];<br>       <span class="hljs-function"><span class="hljs-title">e</span>-&gt;</span><span class="hljs-function"><span class="hljs-title">env_pgdir</span>[PDX(VPT)]   = e-&gt;</span>env_cr3 ;<br>       <span class="hljs-function"><span class="hljs-title">e</span>-&gt;</span><span class="hljs-function"><span class="hljs-title">env_pgdir</span>[PDX(UVPT)]  = e-&gt;</span>env_cr3 ;<br><br>       return <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>　　其实这个函数并不需要我们实现，但是我还是想讲一讲这个函数的一些有意思的地方。</p><p>　　我们知道，每一个进程都有4G的逻辑地址可以访问，我们所熟知的系统不管是Linux还是Windows系统，都可以支持3G&#x2F;1G模式或者2G&#x2F;2G模式。3G&#x2F;1G模式即满32位的进程地址空间中，用户态占3G，内核态占1G。这些情况在进入内核态的时候叫做陷入内核，因为即使进入了内核态，还处在同一个地址空间中，并不切换CR3寄存器。但是！还有一种模式是4G&#x2F;4G模式，内核单独占有一个4G的地址空间，所有的用户进程独享自己的4G地址空间，这种模式下，在进入内核态的时候，叫做切换到内核，因为需要切换CR3寄存器，所以进入了不同的地址空间！</p><p>　　而我们这次实验，根据.&#x2F;include&#x2F;mmu.h里面的布局来说，我们其实就是2G&#x2F;2G模式，用户态占用2G，内核态占用2G。所以记住，我们在用户进程开启后，访问内核地址不需要切换CR3寄存器！其实这个布局模式也很好地解释了为什么我们需要把boot_pgdir里的内容拷到我们的e-&gt;env_pgdir中，在我们的实验中，对于不同的进程而言，其虚拟地址ULIM以上的地方，映射关系都是一样的！这是因为这2G虚拟地址与物理地址的对应，不是由进程管理的，是由内核管理的。</p><p>　　另外一点有意思的地方不知大家注意到没有，UTOP~ULIM明明是属于User的区域，却还是把内核这部分映射到了User区，而且我们看mmu.h的布局。我们仔细地来分析一下：</p><p>[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-aYxIgE0y-1653797805142)(C:\Users\夏伟\AppData\Roaming\Typora\typora-user-images\image-20220529102258920.png)]</p><p>　　 可以看到UTOP是0x7f40 0000，既然有映射，一定就有分配映射的过程，我们使用grep指令搜索一下 UENVS，发现它在这里有pmap.c里的mips_vm_init有所迹象：</p> <figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">envs = (<span class="hljs-keyword">struct</span> Env*)alloc(NENV*sizeof(<span class="hljs-keyword">struct</span> Env),BY2PG,<span class="hljs-number">1</span>);<br>   boot<span class="hljs-constructor">_map_segment(<span class="hljs-params">pgdir</span>,UENVS,NENV<span class="hljs-operator">*</span><span class="hljs-params">sizeof</span>(<span class="hljs-params">struct</span> Env)</span>,<span class="hljs-constructor">PADDR(<span class="hljs-params">envs</span>)</span>,PTE_R);<br></code></pre></td></tr></table></figure><p>　　可以发现什么呢？其实我们发现，UENVS和envs实际上都映射到了envs对应的物理地址。</p><p>　　其实足以看出来，内核在映射的时候已经为用户留下了一条路径，一条获取其他进程信息的路途。而且我们其实可以知道，这一部分对于进程而言应当是只能读不可以写的。开启中断后我们在进程中再访问内核就会产生异常来陷入内核了，所以应该是为了方便读一些进程信息，内核专门开辟了这4M的用户进程虚拟区。用户读这4M空间的内容是不需要产生异常的。</p><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs xl"><span class="hljs-function"><span class="hljs-title">e</span>-&gt;</span><span class="hljs-function"><span class="hljs-title">env_pgdir</span>[PDX(VPT)]  = e-&gt;</span>env_cr3 ;<br><span class="hljs-function"><span class="hljs-title">e</span>-&gt;</span><span class="hljs-function"><span class="hljs-title">env_pgdir</span>[PDX(UVPT)] = e-&gt;</span>env_cr3 ;<br></code></pre></td></tr></table></figure><h4 id="3-env-alloc"><a href="#3-env-alloc" class="headerlink" title="3.env_alloc"></a>3.env_alloc</h4><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-built_in">int</span><br>env<span class="hljs-constructor">_alloc(<span class="hljs-params">struct</span> Env <span class="hljs-operator">**</span><span class="hljs-params">new</span>, <span class="hljs-params">u_int</span> <span class="hljs-params">parent_id</span>)</span><br>&#123;<br>    <span class="hljs-built_in">int</span> r;<br>    <span class="hljs-keyword">struct</span> Env *e;<br><br>    <span class="hljs-comment">/* Step 1: Get a new Env from env_free_list*/</span><br>e=<span class="hljs-constructor">LIST_FIRST(&amp;<span class="hljs-params">env_free_list</span>)</span>;<br><span class="hljs-keyword">if</span>(e==NULL) return -E_NO_FREE_ENV;<br><br>    <span class="hljs-comment">/* Step 2: Call a certain function (has been completed just now) to init kernel memory layout for this new Env.</span><br><span class="hljs-comment">     *The function mainly maps the kernel address to this new Env address. */</span><br>env<span class="hljs-constructor">_setup_vm(<span class="hljs-params">e</span>)</span>;<br><br>    <span class="hljs-comment">/* Step 3: Initialize every field of new Env with appropriate values.*/</span><br>e-&gt;env_id=mkenvid(e);<br>e-&gt;env_parent_id=parent_id;<br>e-&gt;env_status=ENV_RUNNABLE;<br><br>    <span class="hljs-comment">/* Step 4: Focus on initializing the sp register and cp0_status of env_tf field, located at this new Env. */</span><br>    e-&gt;env_tf.regs<span class="hljs-literal">[<span class="hljs-number">29</span>]</span>=USTACKTOP; <br>    e-&gt;env_tf.cp0_status = <span class="hljs-number">0x10001004</span>;<br><br><br>    <span class="hljs-comment">/* Step 5: Remove the new Env from env_free_list. */</span><br><span class="hljs-constructor">LIST_REMOVE(<span class="hljs-params">e</span>,<span class="hljs-params">env_link</span>)</span>;<br>*<span class="hljs-keyword">new</span>=e;<br>return <span class="hljs-number">0</span>;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>这一部分呢，是单个进程控制块要被分配资源的时候做的一些初始化的工作，其中有几个比较有意思的点很值得深究：</p><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs xl"><span class="hljs-function"><span class="hljs-title">currentE</span>-&gt;</span>env_tf.pc = UTEXT + <span class="hljs-number">0</span>xb0;<br><span class="hljs-function"><span class="hljs-title">currentE</span>-&gt;</span>env_tf.cp0_status = <span class="hljs-number">0</span>x10001004;<br></code></pre></td></tr></table></figure><p>　　第一条可能会有比较大的疑问，为什么进程的二进制码分配到UTEXT对应的地址那里去了，而且也建立好映射关系了，怎么还要加个偏移量作为pc初始值呢？</p><p>　　我们知道pc初始值实际上是进程开始运行的地方，而这里为什么是UTEXT+0xb0，这0xb0是什么东西？我们需要去探究一下code_a.c或者code_b.c文件了，实际上经过一定的了解，这个文件应当是一个elf文件。看其前四个字节就能看出：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">0x7f</span> <span class="hljs-number">0</span>x46 <span class="hljs-number">0</span>x4c <span class="hljs-number">0</span>x46<br></code></pre></td></tr></table></figure><p>　　这是elf的标准头，而实际上像这样的标准头的长度是有0xb0的长度，这个实际上我们可以把code_a.c里的数组搞出来，然后变成一个elf文件，最后使用readelf来读取出地址，这样就能明白原理了。所以UTEXT+0xb0这个虚拟地址对应物理地址里面放着的，才是真正可执行代码的第一条。</p><p>　　再来就是这个0x10001004这个问题，这个问题很好玩。因为R3000自身的SR寄存器与mips其他版本的SR寄存器略有不同，它的最后六位记载了是一组深度为二的二重栈，不过笔者在这里还残留着一些不大不小的问题。《see mips run》中只是提到了关于这些寄存器的作用，而没有提到中断的时候这些寄存器应当是什么状态。如果有兴趣的同学可以grep一下 “CP0_STATUS” 和”cp0_status” 说不定能发现个中玄机。                   </p><h4 id="4-load-icode"><a href="#4-load-icode" class="headerlink" title="4.load_icode"></a>4.load_icode</h4><p>　　这个堪称是本次实验中为数不多的坑函数之一，所以我也就重点讲一下几个要点好了。</p><p>　　首先要解释的就是这个page_insert函数，这个函数看起来平淡无奇，但是如果层层深入，就能发现里面的一些奥妙之处。</p><p>　　我们首先来看page_insert：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-built_in">int</span> page<span class="hljs-constructor">_insert(Pde <span class="hljs-operator">*</span><span class="hljs-params">pgdir</span>, <span class="hljs-params">struct</span> Page <span class="hljs-operator">*</span><span class="hljs-params">pp</span>, <span class="hljs-params">u_long</span> <span class="hljs-params">va</span>, <span class="hljs-params">u_int</span> <span class="hljs-params">perm</span>)</span><br>&#123;<br>u_int PERM;<br>Pte *pgtable_entry;<br>PERM = perm <span class="hljs-pattern-match">| <span class="hljs-constructor">PTE_V</span>;</span><br><span class="hljs-pattern-match"></span><br><span class="hljs-pattern-match"><span class="hljs-operator">/</span><span class="hljs-operator">*</span> <span class="hljs-constructor">Step</span> 1: <span class="hljs-constructor">Get</span> corresponding page table entry. <span class="hljs-operator">*</span><span class="hljs-operator">/</span></span><br><span class="hljs-pattern-match">pgdir<span class="hljs-constructor">_walk(<span class="hljs-params">pgdir</span>, <span class="hljs-params">va</span>, 0, &amp;<span class="hljs-params">pgtable_entry</span>)</span>;</span><br><span class="hljs-pattern-match"></span><br><span class="hljs-pattern-match"><span class="hljs-keyword">if</span> (pgtable<span class="hljs-constructor">_entry</span> != 0 <span class="hljs-operator">&amp;&amp;</span> (<span class="hljs-operator">*</span>pgtable<span class="hljs-constructor">_entry</span> &amp; <span class="hljs-constructor">PTE_V</span>) != 0) &#123;</span><br><span class="hljs-pattern-match"><span class="hljs-keyword">if</span> (pa2page(<span class="hljs-operator">*</span>pgtable<span class="hljs-constructor">_entry</span>) != pp) &#123;</span><br><span class="hljs-pattern-match">page<span class="hljs-constructor">_remove(<span class="hljs-params">pgdir</span>, <span class="hljs-params">va</span>)</span>;</span><br><span class="hljs-pattern-match">&#125; <span class="hljs-keyword">else</span>&#123;</span><br><span class="hljs-pattern-match">tlb<span class="hljs-constructor">_invalidate(<span class="hljs-params">pgdir</span>, <span class="hljs-params">va</span>)</span>;</span><br><span class="hljs-pattern-match"><span class="hljs-operator">*</span>pgtable<span class="hljs-constructor">_entry</span> = (page2pa(pp) | <span class="hljs-constructor">PERM</span>);</span><br><span class="hljs-pattern-match">return 0;</span><br><span class="hljs-pattern-match">&#125;</span><br><span class="hljs-pattern-match">&#125;</span><br><span class="hljs-pattern-match"></span><br><span class="hljs-pattern-match"><span class="hljs-operator">/</span><span class="hljs-operator">*</span> <span class="hljs-constructor">Step</span> 2: <span class="hljs-constructor">Update</span> <span class="hljs-constructor">TLB</span>. <span class="hljs-operator">*</span><span class="hljs-operator">/</span></span><br><span class="hljs-pattern-match"></span><br><span class="hljs-pattern-match"><span class="hljs-operator">/</span><span class="hljs-operator">*</span> hint: use tlb<span class="hljs-constructor">_invalidate</span> <span class="hljs-keyword">function</span> <span class="hljs-operator">*</span><span class="hljs-operator">/</span></span><br><span class="hljs-pattern-match"></span><br><span class="hljs-pattern-match">tlb<span class="hljs-constructor">_invalidate(<span class="hljs-params">pgdir</span>,<span class="hljs-params">va</span>)</span>;</span><br><span class="hljs-pattern-match"><span class="hljs-operator">/</span><span class="hljs-operator">*</span> <span class="hljs-constructor">Step</span> 3: <span class="hljs-constructor">Do</span> check, re-get page table entry <span class="hljs-keyword">to</span> validate the insertion. <span class="hljs-operator">*</span><span class="hljs-operator">/</span></span><br><span class="hljs-pattern-match"></span><br><span class="hljs-pattern-match"><span class="hljs-operator">/</span><span class="hljs-operator">*</span> <span class="hljs-constructor">Step</span> 3.1 <span class="hljs-constructor">Check</span> <span class="hljs-keyword">if</span> the page can be insert, <span class="hljs-keyword">if</span> can’t return -<span class="hljs-constructor">E_NO_MEM</span> <span class="hljs-operator">*</span><span class="hljs-operator">/</span></span><br><span class="hljs-pattern-match"><span class="hljs-keyword">if</span>(pgdir<span class="hljs-constructor">_walk(<span class="hljs-params">pgdir</span>,<span class="hljs-params">va</span>,1,&amp;<span class="hljs-params">pgtable_entry</span>)</span>!=0)</span><br><span class="hljs-pattern-match">&#123;</span><br><span class="hljs-pattern-match">return -<span class="hljs-constructor">E_NO_MEM</span>;</span><br><span class="hljs-pattern-match">&#125;</span><br><span class="hljs-pattern-match"><span class="hljs-operator">/</span><span class="hljs-operator">*</span> <span class="hljs-constructor">Step</span> 3.2 <span class="hljs-constructor">Insert</span> page <span class="hljs-keyword">and</span> increment the pp<span class="hljs-constructor">_ref</span> <span class="hljs-operator">*</span><span class="hljs-operator">/</span></span><br><span class="hljs-pattern-match"><span class="hljs-operator">*</span>pgtable<span class="hljs-constructor">_entry</span>=page2pa(pp)|<span class="hljs-constructor">PERM</span>;</span><br><span class="hljs-pattern-match">pp-&gt;pp<span class="hljs-constructor">_ref</span><span class="hljs-operator">++</span>;</span><br><span class="hljs-pattern-match">return 0;</span><br><span class="hljs-pattern-match">&#125;</span><br></code></pre></td></tr></table></figure><p>　　实际上这个函数是这样一个流程：</p><p>　　先判断va是否有对应的页表项，如果页表项有效。或者叫va是否已经有了映射的物理地址。如果有的话，则去判断这个物理地址是不是我们要插入的那个物理地址，如果不是，那么就把该物理地址移除掉；如果是的话，则修改权限，放到tlb里去。</p><p>　　关于page_inert以下两点一定要注意：</p><ul><li>page_insert处理将同一虚拟地址映射到同一个物理页面上不会将当前已有的物理页面移除掉，但是需要修改掉permission；</li><li>只要对页表有修改，都必须tlb_invalidate一下，否则后面紧接着对内存的访问很有可能出错。这就是为什么有一些同学直接使用了pgdir_walk而没有page_insert产生错误的原因。</li></ul><p>　　既然提到了tlb_invalidate函数，那么我们来仔细分析一下这个函数，这个函数代码如下：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">void<br>tlb<span class="hljs-constructor">_invalidate(Pde <span class="hljs-operator">*</span><span class="hljs-params">pgdir</span>, <span class="hljs-params">u_long</span> <span class="hljs-params">va</span>)</span><br>&#123;<br>        <span class="hljs-keyword">if</span> (curenv)<br>                tlb<span class="hljs-constructor">_out(PTE_ADDR(<span class="hljs-params">va</span>)</span><span class="hljs-pattern-match">|<span class="hljs-constructor">GET_ENV_ASID(<span class="hljs-params">curenv</span>-&gt;<span class="hljs-params">env_id</span>)</span>);</span><br><span class="hljs-pattern-match">        <span class="hljs-keyword">else</span></span><br><span class="hljs-pattern-match">                tlb<span class="hljs-constructor">_out(PTE_ADDR(<span class="hljs-params">va</span>)</span>);</span><br><span class="hljs-pattern-match">&#125;</span><br></code></pre></td></tr></table></figure><p>　　关于为什么要使用GET_ENV_ASID宏，助教老师给的指导书里其实没有讲太清楚，tlb的ASID区域只有20位，而我们mkenvid函数调用后得到的id值是可以超出20位的，大家可以在env_init初始化的时候打印env_id的值，然后在init.c里面create 1024个进程即可看到实际上envid最大可达1ffbfe，而使用GET宏之后最大可达ffc0，而且都可以为tlb用于区分进程，所以肯定是位数越少越好啦。而且还有一个比较有意思的地方，GET宏里实际上是让env_id先 &gt;&gt;11 然后 &lt;&lt;6 达到最后效果的，这样和&gt;&gt;5有什么区别呢？区别就在于 如果先&gt;&gt;11再 &lt;&lt;6，后6位一定是0！（2进制位），所以我猜后六位一定是有其独特用处的，否则在这里也不会强调清零，不过我们这次实验里还没有看到特殊用处。</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs x86asm">LEAF(tlb_out)<br>//<span class="hljs-number">1</span>: j <span class="hljs-number">1b</span><br><span class="hljs-keyword">nop</span><br>mfc0<span class="hljs-built_in">k1</span>,CP0_ENTRYHI<br>mtc0a0,CP0_ENTRYHI<br><span class="hljs-keyword">nop</span><br>// insert tlbp <span class="hljs-keyword">or</span> tlbwi<br>tlbp<br><span class="hljs-keyword">nop</span><br><span class="hljs-keyword">nop</span><br><span class="hljs-keyword">nop</span><br><span class="hljs-keyword">nop</span><br>mfc0<span class="hljs-built_in">k0</span>,CP0_INDEX<br>bltz<span class="hljs-built_in">k0</span>,NOFOUND<br><span class="hljs-keyword">nop</span><br>mtc0<span class="hljs-meta">zero</span>,CP0_ENTRYHI<br>mtc0<span class="hljs-meta">zero</span>,CP0_ENTRYLO0<br><span class="hljs-keyword">nop</span><br>// insert tlbp <span class="hljs-keyword">or</span> tlbwi<br>tlbwi<br><span class="hljs-symbol">NOFOUND:</span><br><br>mtc0<span class="hljs-built_in">k1</span>,CP0_ENTRYHI<br><br>jra<br><span class="hljs-keyword">nop</span><br>END(tlb_out)<br><br></code></pre></td></tr></table></figure><p> 　这段汇编是tlb_invalidate函数的精华所在，CP0_ENTRYHI实际上就是用来给tlb倒腾数据的，不用太在意其本身的作用。</p><p> 　前两句是指把之前的CP0_ENTRYHI存在k1里面暂存一下。然后我们就有一条很关键的汇编指令 tlbp ，很关键。</p><p>　　通过查mips手册可以知道tlbp的功能如下：<br><img src="https://img-blog.csdnimg.cn/05a8460c52bb4747b81352ef5bdc8d98.png" alt="在这里插入图片描述"><br>　　之后的几个nop应该是为tlb指令设置的流水缓冲，因为tlbp执行的周期要比一般指令长。其实这条汇编的目的就是：</p><p>　　To find a matching entry in the TLB.所以说实际上是把va及其对应的物理地址存在tlb里了，而且tlbp应该是依托于CP0_INDEX和CP0_EnrtyHI寄存器的。那么后面的那些读CP0_INDEX实际上是对tlbp执行是否成功的一个判断而已。注意，这里的tlbp就是在内核态下进行的，所以不会产生异常。如果在用户态下修改CP0的寄存器，或者使用tlbp汇编等，那就说明是tlb缺失或page_fault了！</p><p>　　那么再返回我们的page_insert来看看下一句，下一句是建立一个va与pa之间的桥梁，一个页表的建立，pgdir_walk(pgdir, va, 1, &amp;pgtable_entry)，所以说我们其实在最开始load_icode的时候，实际上是建立了不止size大小的页，还需要建立一个能够映射到该页的页表！那么在最后，为页表项的内容设置权限位PTE_R。恩，那么page_insert函数就此结束了。</p><p>　　page_insert函数结束了，不代表我们这个load_icode结束。下一步则是bcopy。</p><p>　　bcopy这个函数本身不坑，坑的是用法。首先对比原文中的这句我们来粗浅地看一下bcopy：</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-built_in">bzero</span>(page2kva(page),BY2PG);<br><span class="hljs-built_in">bcopy</span>((void *)binary,<span class="hljs-built_in">page2kva</span>(page),BY2PG);<br></code></pre></td></tr></table></figure><p>　　我个人以为这里bzero清零比较好，因为不能保证lab2哪里有问题还会影响到这里来。我倾向于一页一页地清除目标页，分配原始页，当然实验证明这样写也是没有任何问题的。那么下面来解释一下为什么这里用的是page2kva(page)，而不是用与UTEXT有关的数值？</p><p>　　首先我们解释过了，UTEXT+0xb0是程序的入口，何谓入口？比如我们现在启动了一个进程，我们如何能从哪里开始，该怎样跑呢？这取决于我们run一个进程前的准备工作，当然这个工作在进程切换时也需要做，其中很重要的一点就是保存pc。这一点很重要，极其重要。如果是第一次run一个进程的时候，我们的pc是务必要被设置为UTEXT+0xb0的，这也是在env_alloc里面所做的工作。之后有一些我们没有关注过的汇编程序就会默默地根据我们设置的pc去找我们的程序入口，默默地执行，遇到中断默默地保存，切换。于是就这样完成了进程的运行与切换大计。</p><p>　　那么我们这里bcopy不能用UTEXT来copy是因为，我们这里还没开始一个进程，没有其页目录来作为基址，所以你现在copy到的地方也只是内核的UTEXT处。我们都知道在env_run时要切换页目录，切换为进程的页目录后，我们就再也找不到这部分copy的东西了（因为env_setup_vm只复制内核页目录ULIM以上的部分）。所以我们要copy到的地方一定是要内核和每个进程均可以访问的，显而易见要copy到ULIM以上的部分。即page2kva(page)这个地方。当然，你可以选择先切换到进程的页目录，然后copy，然后在结束的时候切换回内核的页目录，</p><p>　　再次强调一点，bcopy也好，bzero也好，在我们编写的程序中，只要是作为访问地址来使用的（什么叫作为地址来使用，就是可以取其内容的 *address)，全部都使用的是虚拟地址！　　</p><p>　　如果你还有更多的探索之心的话，我们可以这么来玩一下load_icode，你看我们之前bcopy不能copy到UTEXT的理由也知道了，那何不先切换到进程的页目录，复制完了以后再切换回来呢？事实上这种做法理论上是完全正确的，但是我在我们的实验里试验过发现不对！后来发现即使切换了页目录，也可以照常访问内核区的地址，完全没有问题！为什么？后来我才猛然想到，我们这次实验的lcontext切换页目录，完全是为tlb中断和page_fault服务的，所以指望lcontext来自动帮我们找到物理地址并且往里添加内容的话，是不可以的。</p><p>　　最后呢，实际上就是建个进程里的用户栈而已，这里区别开用户栈 和内存栈的区别。</p><p>　　多个进程运行时，实际上在内存中有一个栈型结构来存放进程的代码，数据，常量等，而在用户栈里放的则是运行过程中所定义的变量等，这点需要正确把握。当然最后要设置权限，PTE_R，这是写的权限，要设置给用户栈，否则后面进程没有办法写自己的栈了 。　　</p><h4 id="5-env-create"><a href="#5-env-create" class="headerlink" title="5.env_create"></a>5.env_create</h4><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">void<br>env<span class="hljs-constructor">_create(<span class="hljs-params">u_char</span> <span class="hljs-operator">*</span><span class="hljs-params">binary</span>, <span class="hljs-params">int</span> <span class="hljs-params">size</span>)</span><br>&#123;<br>     <span class="hljs-comment">/* Step 1: Use env_create_priority to alloc a new env with priority 1 */</span><br>env<span class="hljs-constructor">_create_priority(<span class="hljs-params">binary</span>,<span class="hljs-params">size</span>,1)</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>实际上这里env_create就很简单了，就是alloc一个进程控制块，然后加载其代码。</p><h4 id="6-env-run"><a href="#6-env-run" class="headerlink" title="6.env_run"></a>6.env_run</h4><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs xl">void<br>env_run(struct Env *e)<br>&#123;<br>struct Trapframe *old;<br>old=(struct Trapframe *)(TIMESTACK-sizeof(struct Trapframe));<br>    <span class="hljs-comment">/* Step 1: save register state of curenv. */</span><br>    <span class="hljs-comment">/* Hint: if there is an environment running, </span><br><span class="hljs-comment">     *   you should switch the context and save the registers. </span><br><span class="hljs-comment">     *   You can imitate env_destroy() &#x27;s behaviors.*/</span><br>     <span class="hljs-keyword">if</span>(curenv!=NULL)<br>&#123;<br><span class="hljs-function"><span class="hljs-title">curenv</span>-&gt;</span>env_tf=*old;<br><span class="hljs-function"><span class="hljs-title">curenv</span>-&gt;</span><span class="hljs-function"><span class="hljs-title">env_tf</span>.pc=old-&gt;</span>cp0_epc;<br>&#125;<br><br>    <span class="hljs-comment">/* Step 2: Set &#x27;curenv&#x27; to the new environment. */</span><br>curenv=e;<br><span class="hljs-function"><span class="hljs-title">curenv</span>-&gt;</span>env_status=ENV_RUNNABLE;<br><br>    <span class="hljs-comment">/* Step 3: Use lcontext() to switch to its address space. */</span><br><span class="hljs-function"><span class="hljs-title">lcontext</span>(curenv-&gt;</span>env_pgdir);<br><br>    <span class="hljs-comment">/* Step 4: Use env_pop_tf() to restore the environment&#x27;s</span><br><span class="hljs-comment">     *   environment   registers and return to user mode.</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * Hint: You should use GET_ENV_ASID there. Think why?</span><br><span class="hljs-comment">     *   (read &lt;see mips run linux&gt;, page 135-144)</span><br><span class="hljs-comment">     */</span><br><span class="hljs-function"><span class="hljs-title">env_pop_tf</span>(&amp;curenv-&gt;</span><span class="hljs-function"><span class="hljs-title">env_tf</span>,GET_ENV_ASID(curenv-&gt;</span>env_id));<br>&#125;<br></code></pre></td></tr></table></figure><p>   刚刚说到的load_icode是为数不多的坑函数之一，env_run也是，而且其实按程度来讲可能更甚一筹。</p><p>　　那我们来一步一步分析一下这个函数的坑处。</p><p>　　首先是要理解进程切换，需要做些什么？实际上进程切换的时候，为了保证下一次进入这个进程的时候我们不会再“从头来过”，我们要保存一些信息，那么，需要保存什么信息呢？保存的应该是以下几方面：</p><p>　　[1]进程本身的状态</p><p>　　[2]进程周围的环境的状态，环境就是指此时的CPU的状态</p><p>　　那么我们可能会产生疑问，进程本身的状态怎么记录呢？</p><p>　　进程本身的状态无非就是进程块里面那几个东西，包括id,parent_id,pc,tf…</p><p>　    Trapframe里面有 cp0_badvaddr,cp0_cause,cp0_epc,regs[32]…</p><p>　　这些东西不是进程自己的。这些都是CPU的状态。所以说实际上一个进程控制块中的tf，就是来记录它的环境的状态的。进程本身的状态在进程切换的时候是不会变的。会变的也是需要我们保存的实际上是进程的环境信息。</p><p>　　谨记这一点，或许你就能开始明白run代码中的第一句:</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">1 </span> <span class="hljs-keyword">if</span>(curenv)&#123;<br><span class="hljs-symbol">2 </span>              tf = TIMESTACK - sizeof(struct Trapframe);<br><span class="hljs-symbol">3 </span>              bcopy(tf,&amp;curenv-&gt;env_tf,sizeof(struct Trapframe));<br><span class="hljs-symbol">4 </span>              curenv-&gt;env_tf.pc = tf-&gt;cp0_epc;<br><span class="hljs-symbol">5 </span>        &#125;<br></code></pre></td></tr></table></figure><p>　　很多同学在这里可能遇到了他们在lab3中的最大困惑：</p><p>　　　　为什么这里不能从KERNEL_SP取东西，而是非要从TIMESTACK取。KERNEL_SP是用来干啥的？</p><p>　　为了搞清楚这一点，我们需要知道：什么时候我们把东西往TIMESTACK放，又是什么时候取出来的？</p><p>　　笔者在 .&#x2F;include&#x2F;stackframe.h 找到了一点端倪：</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm"> <span class="hljs-number">1</span> <span class="hljs-meta">.macro</span> get_sp<br> <span class="hljs-number">2</span>         <span class="hljs-keyword">mfc0 </span>   <span class="hljs-built_in">k1</span>, CP0_CAUSE<br> <span class="hljs-number">3</span>         <span class="hljs-keyword">andi </span>   <span class="hljs-built_in">k1</span>, <span class="hljs-number">0x107C</span><br> <span class="hljs-number">4</span>         <span class="hljs-keyword">xori </span>   <span class="hljs-built_in">k1</span>, <span class="hljs-number">0x1000</span><br> <span class="hljs-number">5</span>         <span class="hljs-keyword">bnez </span>   <span class="hljs-built_in">k1</span>, <span class="hljs-number">1</span>f<br> <span class="hljs-number">6</span>         <span class="hljs-keyword">nop</span><br><span class="hljs-keyword"></span> <span class="hljs-number">7</span>         li      <span class="hljs-built_in">sp</span>, <span class="hljs-number">0x82000000</span><br> <span class="hljs-number">8</span>         <span class="hljs-keyword">j </span>      <span class="hljs-number">2</span>f<br> <span class="hljs-number">9</span>         <span class="hljs-keyword">nop</span><br><span class="hljs-keyword"></span><span class="hljs-number">10</span> <span class="hljs-number">1</span>:<br><span class="hljs-number">11</span>         <span class="hljs-keyword">bltz </span>   <span class="hljs-built_in">sp</span>, <span class="hljs-number">2</span>f<br><span class="hljs-number">12</span>         <span class="hljs-keyword">nop</span><br><span class="hljs-keyword"></span><span class="hljs-number">13</span>         <span class="hljs-keyword">lw </span>     <span class="hljs-built_in">sp</span>, KERNEL_SP<br><span class="hljs-number">14</span>         <span class="hljs-keyword">nop</span><br><span class="hljs-keyword"></span><span class="hljs-number">15</span> <br><span class="hljs-number">16</span> <span class="hljs-number">2</span>:      <span class="hljs-keyword">nop</span><br><span class="hljs-keyword"></span><span class="hljs-number">17</span> <br><span class="hljs-number">18</span> <span class="hljs-meta">.endm</span><br></code></pre></td></tr></table></figure><p>　　实际上我们的TIMSTACK就是0x82000000，因为我们本次都是时钟中断，所以sp是TIMSTACK区。</p><p>　　而我们再仔细地观察这个头文件，发现其实里面的宏汇编 RESTORE_SOME 和env_pop_tf 几乎一模一样。TIMESTACK是时钟中断后的存储区，而KERNEL_SP应当是系统调用后的存储区。我们可以把run里面的TIMSTACK改成 KERNEL_SP试试，发现其实KERNEL_SP在第一个进程执行完之后就没更新过，这是显而易见的，因为我们第一个进程启动后，就再也没有给过内核进程控制权啊！不过我们的猜想估计要到后面的实验才能认证。</p><p>　  那么实际上我们在往某个寄存器比如$1里放东西的时候，应该是放到了sp为起始虚拟地址对应的物理地址处，那么就是</p><ul><li>　　env_pop_tf 负责放东西到sp(这里是TIMESTACK)中去；</li><li>　　而这开头的一段负责从sp里取出东西来(这里是TIMSTACK)。</li></ul><p>　　所以我们一开始没有正在运行的进程块的时候，是不需要取的，但是一旦一个进程块运行到末尾的话，就会向TIMSTACK中存入东西。</p><p>　　比如我们进程1开始运行，运行到env_run的末尾，我们把当时的环境保存了下来。运行一段时间后，时钟中断导致切换，发现要到进程2了，在切换之前，我们把进程1的离开时的状态保存在其tf内，离开的状态其实就在TIMESTACK中。因为我理解的这个TIMESTACK就是当前访问CPU的寄存器所用虚拟地址，所以其所对应的值就是CPU的各个寄存器的值，所以就会在进程运行时改变，所以要更新。</p><p>　　注意还有一个小坑的地方在于 如果要env_pop_tf的时候，千万记得要先lcontext切换了页目录，否则是会出错的。env_pop_tf 的字面意思估计大家也明白了，就是把env里的tf 压到 寄存器里去。　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　</p><h3 id="四、实验难点图示"><a href="#四、实验难点图示" class="headerlink" title="四、实验难点图示"></a>四、实验难点图示</h3><h4 id="1-加载二进制镜像"><a href="#1-加载二进制镜像" class="headerlink" title="1.加载二进制镜像"></a>1.加载二进制镜像</h4><p>这一部分的内容较多且难度较大，由三个函数共同完成，即：</p><ul><li>env.c中的<code>load_icode</code></li><li>kernal_elfloader.c中的<code>load_elf</code></li><li>env.c中的<code>load_icode_mapper</code></li></ul><p>其中<code>load_icode</code>为实现这个功能的代码，它的功能在于：</p><ol><li>分配内存</li><li>将二进制代码装入分配好的内存中</li></ol><p>其中，第二步，即装入内存的操作交给了函数<code>load_elf</code>来完成，而<code>load_elf</code>的工作又被分为：</p><ol><li>解析<code>ELF</code>结构</li><li>将<code>ELF</code>的内容复制到内存中</li></ol><p>其中，第二步，即将内容复制到内存中的操作又交给了<code>load_icode_mapper</code>函数去进行，所以三段代码的协作方式如下图：<br><img src="https://img-blog.csdnimg.cn/460c00d903ef4eeeab68eb0b58856b7e.png#pic_center" alt="在这里插入图片描述"><br>在函数<code>load_elf</code>中，我们不难发现，我们在<code>load_icode_mapper</code>中用到的许多参量在这里都有了很明确的实例对应，具体映射如下：<br><img src="https://img-blog.csdnimg.cn/b669a709f75843dba015820f2468f188.png#pic_center" alt="在这里插入图片描述"></p><p>因此我们只要将给定的ELF文件进行正确解析，就能利用<code>load_icode_mapper</code>对其进行内容复制</p><p>函数<code>load_icode</code>重点在于设置<code>PC</code>值，即从<code>load_elf</code>中返回的<code>entry_point</code></p><h4 id="2-env-setup-vm函数的填写，初始化新进程地址空间"><a href="#2-env-setup-vm函数的填写，初始化新进程地址空间" class="headerlink" title="2.env_setup_vm函数的填写，初始化新进程地址空间"></a>2.<code>env_setup_vm</code>函数的填写，初始化新进程地址空间</h4><p>在这个函数中，内存空间被分成了如下的两个部分，即<code>UTOP</code>以上和<code>UTOP</code>以下，在<code>UTOP</code>以下的部分，我们需要将页目录的这一块区域清零，而在<code>UTOP</code>以上的部分，用户不能操作，属于内核态，因此我们可以将<code>boot_pgdir</code>的内容直接复制到进程的页目录中。</p><p>在<code>UTOP</code>之上有一块被称为<code>UVPT</code>的地址，这一块区域作为用户进程页目录，需要用自映射机制进行单独处理。<br>地址空间的结构图如下：<br><img src="https://img-blog.csdnimg.cn/b00a9539795f449c9a8ac6d1d733e146.png#pic_center" alt="在这里插入图片描述"></p><h4 id="3-sched-yield-进程切换的调度算法"><a href="#3-sched-yield-进程切换的调度算法" class="headerlink" title="3.sched_yield() 进程切换的调度算法"></a>3.sched_yield() 进程切换的调度算法</h4><p>进程的调度也是基于这个时间片来进行，主要的步骤为如下几步：</p><ol><li>设置两个队列，其中一个为目前的进程调度队列<code>q0</code>，另一个为一个空队列<code>q1</code>。</li><li>首先判断当前队列指针指向的队首进程的<code>env_status</code><ul><li>如果为<code>ENV_FREE</code>，则要将该进程从队列中移除</li><li>如果为<code>ENV_NOT_RUNNABLE</code>，则直接将其插入另一个队列的尾部</li><li>如果为<code>ENV_RUNNABLE</code>，则判断这个进程的时间片是否用完，若用完则复原其时间片并将其插入到另一个队列尾部</li><li>当一个队列为空时，将指针转移到另一个队列队首<br><img src="https://img-blog.csdnimg.cn/49f861a6d63047a0a906b3b617325ca9.png#pic_center" alt="在这里插入图片描述"></li></ul></li></ol>]]></content>
    
    
    <categories>
      
      <category>OS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>OS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>OS-Lab2</title>
    <link href="/2022/07/17/OS-Lab2/"/>
    <url>/2022/07/17/OS-Lab2/</url>
    
    <content type="html"><![CDATA[<h4 id="一-TLB访存机制"><a href="#一-TLB访存机制" class="headerlink" title="一.TLB访存机制"></a>一.TLB访存机制</h4><p>当一个虚拟地址被送到MMU中进行翻译的时候，硬件首先在TLB中寻找包含这个地址的页面，如果它的虚页号在TLB中，并且没有违反保护位，那么就可以直接从TLB中得到相应的物理页号，而不去访问页表；如果发现虚页号在TLB中不存在，那么MMU将进行常规的页表查找，同时通过一定的策略来将这一页的页表项替换到TLB中，之后再次访问这一页的时候就可以直接在TLB中找到。</p><p>拿到了物理地址后，可以直接访问内存拿数据，不过会慢，所以，Cache就是部分物理地址到数据的映射。是内存的一部分copy。<br><img src="https://img-blog.csdnimg.cn/fa249c54c01849e5a595009ceb03cd18.jpeg#pic_center" alt="在这里插入图片描述"></p><h4 id="二-二级页表"><a href="#二-二级页表" class="headerlink" title="二.二级页表"></a>二.二级页表</h4><p>首先，c语言可以操作任何空间的地址，这个就是虚拟地址。</p><p>我们要做的就是模拟二级页表机制，往虚拟地址里面填写物理地址，再通过f(va)−&gt;pa和f(pa)→va转换取到地址里面的东西。</p><p>简单来说，把放着很多很多页的虚拟地址，按照虚拟地址的索引，把它对应的物理地址放到另一个虚拟地址pgidr里。</p><p>这样就“假装”建立起了二级页表，物理地址从未使用过，要访问时永远要加上ULIM。</p><p><code>Page</code>结构体其实是物理地址的一个“象征”。因为它减去pages拿到ppn以后，shift12位再加上ULIM，就是虚拟地址，减去ULM又变回物理地址。建立起来虚拟页和物理页之间的桥梁。尽管自己不是真正的4KB页，但是是桥梁。</p><h4 id="三-Page存储结构"><a href="#三-Page存储结构" class="headerlink" title="三.Page存储结构"></a>三.Page存储结构</h4><p><img src="https://img-blog.csdnimg.cn/6789262634cc4ac3b67edfab1d3ab7f5.jpeg#pic_center" alt="在这里插入图片描述"></p><h4 id="四-自映射机制图示"><a href="#四-自映射机制图示" class="headerlink" title="四.自映射机制图示"></a>四.自映射机制图示</h4><p><img src="https://img-blog.csdnimg.cn/82fdc306b4ae46bbaded906cc289a783.jpeg#pic_center" alt="在这里插入图片描述"></p><h4 id="五-页面与地址的转化"><a href="#五-页面与地址的转化" class="headerlink" title="五.页面与地址的转化"></a>五.页面与地址的转化</h4><p> 在本次实验中涉及到许多的页面与地址的转化，其中用到许多已经定义的函数，现整理如下：</p><p> <strong>page2pa：得到某个page结构体的物理地址</strong></p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-comment">/* Get the physical address of Page &#x27;pp&#x27;.</span><br><span class="hljs-comment"> */</span><br>static inline u_long<br><span class="hljs-built_in">page2pa</span>(struct Page *pp)<br>&#123;<br>return <span class="hljs-built_in">page2ppn</span>(pp) &lt;&lt; PGSHIFT;<br>&#125;<br></code></pre></td></tr></table></figure><p> <strong>pa2page：得到某个物理地址所对应的Page结构体</strong></p><figure class="highlight sas"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs sas"><span class="hljs-comment">/* Get the Page struct whose physical address is &#x27;pa&#x27;.</span><br><span class="hljs-comment"> */</span><br>static inline struct <span class="hljs-keyword">Page</span> <span class="hljs-comment">*</span><br><span class="hljs-comment">pa2page(u_long pa)</span><br><span class="hljs-comment">&#123;</span><br><span class="hljs-comment">if (PPN(pa) &gt;= npage) &#123;</span><br><span class="hljs-comment">panic(&quot;pa2page called with invalid pa: %x&quot;, pa);</span><br>&#125;<br><br><span class="hljs-keyword">return</span> <span class="hljs-variable">&amp;pages</span>[PP<span class="hljs-meta">N</span>(pa)];<br>&#125;<br></code></pre></td></tr></table></figure><p> <strong>page2kva：得到某个Page结构体的内核虚拟地址</strong></p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-comment">/* Get the kernel virtual address of Page &#x27;pp&#x27;.</span><br><span class="hljs-comment"> */</span><br>static inline u_long<br><span class="hljs-built_in">page2kva</span>(struct Page *pp)<br>&#123;<br>return <span class="hljs-built_in">KADDR</span>(page2pa(pp));<br>&#125;<br></code></pre></td></tr></table></figure><p> <strong>PPN：得到某个虚拟地址的页号</strong></p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs lisp">#define PPN(<span class="hljs-name">va</span>)(((<span class="hljs-name">u_long</span>)(<span class="hljs-name">va</span>))&gt;&gt;12)<br></code></pre></td></tr></table></figure><p> <strong>PADDR：将某个内核虚拟地址转化为物理地址</strong></p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-comment">// translates from kernel virtual address to physical address.</span><br><span class="hljs-selector-id">#define</span> <span class="hljs-built_in">PADDR</span>(kva)\<br>(&#123;\<br>u_long a = (u_long) (kva);\<br>if (a &lt; ULIM)\<br><span class="hljs-built_in">panic</span>(&quot;PADDR called with invalid kva %<span class="hljs-number">08</span>lx&quot;, a);\<br><span class="hljs-selector-tag">a</span> - ULIM;\<br>&#125;)<br></code></pre></td></tr></table></figure><p> <strong>KADDR：将某个物理地址转化为内核虚拟地址</strong></p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-comment">// translates from physical address to kernel virtual address.</span><br><span class="hljs-selector-id">#define</span> <span class="hljs-built_in">KADDR</span>(pa)\<br>(&#123;\<br>u_long ppn = PPN(pa);\<br>if (ppn &gt;= npage)\<br><span class="hljs-built_in">panic</span>(&quot;KADDR called with invalid pa %<span class="hljs-number">08</span>lx&quot;, (u_long)pa);\<br>(pa) + ULIM;\<br>&#125;)<br></code></pre></td></tr></table></figure><p> 本次实验的前半部分涉及了许多对这类函数的应用，熟练掌握这类函数实现各类地址查询是本次实验的一大难点。</p><h4 id="六-部分实验代码详解"><a href="#六-部分实验代码详解" class="headerlink" title="六.部分实验代码详解"></a>六.部分实验代码详解</h4><p>部分代码含义解释如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs cpp"> <span class="hljs-number">1</span> <span class="hljs-meta">#<span class="hljs-keyword">define</span> BY2PG        4096             <span class="hljs-comment">// 页面大小的Byte数，一个页面大小为4kb</span></span><br> <span class="hljs-number">2</span> <span class="hljs-meta">#<span class="hljs-keyword">define</span> PDMAP        (4*1024*1024)    <span class="hljs-comment">// 一个页表管理1024个页面，大小总共4*1024*1024Byte</span></span><br> <span class="hljs-number">3</span> <span class="hljs-meta">#<span class="hljs-keyword">define</span> PGSHIFT        12             <span class="hljs-comment">// 页面的偏移位数，4kb对应12位</span></span><br> <span class="hljs-number">4</span> <span class="hljs-meta">#<span class="hljs-keyword">define</span> PDSHIFT        22        <span class="hljs-comment">// 页表的偏移位数，同上，即log2(PDMAP)</span></span><br> <span class="hljs-number">5</span> <span class="hljs-meta">#<span class="hljs-keyword">define</span> PDX(va)        ((((u_long)(va))&gt;&gt;22) &amp; 0x03FF) <span class="hljs-comment">// 取虚拟地址高10位，为页目录号</span></span><br> <span class="hljs-number">6</span> <span class="hljs-meta">#<span class="hljs-keyword">define</span> PTX(va)        ((((u_long)(va))&gt;&gt;12) &amp; 0x03FF) <span class="hljs-comment">// 取虚拟地址高11~20位，为页表号</span></span><br> <span class="hljs-number">7</span> <span class="hljs-meta">#<span class="hljs-keyword">define</span> PTE_ADDR(pte)    ((u_long)(pte)&amp;~0xFFF) <span class="hljs-comment">// 页表项取低12位，为页内偏移</span></span><br> <span class="hljs-number">8</span> <br> <span class="hljs-number">9</span> <span class="hljs-comment">// page number field of address</span><br><span class="hljs-number">10</span> <span class="hljs-meta">#<span class="hljs-keyword">define</span> PPN(va)        (((u_long)(va))&gt;&gt;12) <span class="hljs-comment">// 物理页号，为虚拟地址偏移12位</span></span><br><span class="hljs-number">11</span> <span class="hljs-meta">#<span class="hljs-keyword">define</span> VPN(va)        PPN(va) <span class="hljs-comment">// 虚页号</span></span><br><span class="hljs-number">12</span> <br><span class="hljs-number">13</span> <span class="hljs-meta">#<span class="hljs-keyword">define</span> VA2PFN(va)        (((u_long)(va)) &amp; 0xFFFFF000 )</span><br><span class="hljs-number">14</span> <span class="hljs-meta">#<span class="hljs-keyword">define</span> PTE2PT        1024</span><br><span class="hljs-number">15</span> <span class="hljs-comment">//$#define VA2PDE(va)        (((u_long)(va)) &amp; 0xFFC00000 )</span><br><span class="hljs-number">16</span> <br><span class="hljs-number">17</span> <span class="hljs-comment">/* Page Table/Directory Entry flags</span><br><span class="hljs-comment">18  *   these are defined by the hardware</span><br><span class="hljs-comment">19  */</span><br><span class="hljs-number">20</span> <span class="hljs-meta">#<span class="hljs-keyword">define</span> PTE_G        0x0100    <span class="hljs-comment">// 全局位</span></span><br><span class="hljs-number">21</span> <span class="hljs-meta">#<span class="hljs-keyword">define</span> PTE_V        0x0200    <span class="hljs-comment">// 有效位</span></span><br><span class="hljs-number">22</span> <span class="hljs-meta">#<span class="hljs-keyword">define</span> PTE_R        0x0400    <span class="hljs-comment">// 修改位，如果是0表示只对该页面进行过读操作，否则进行过写操作，要引发中断将内容写回内存</span></span><br><span class="hljs-number">23</span> <span class="hljs-meta">#<span class="hljs-keyword">define</span> PTE_D        0x0002    <span class="hljs-comment">// 文件缓存的修改位dirty</span></span><br><span class="hljs-number">24</span> <span class="hljs-meta">#<span class="hljs-keyword">define</span> PTE_COW        0x0001    <span class="hljs-comment">// 写时复制copy on write</span></span><br><span class="hljs-number">25</span> <span class="hljs-meta">#<span class="hljs-keyword">define</span> PTE_UC        0x0800    <span class="hljs-comment">// 未缓存uncached</span></span><br><span class="hljs-number">26</span> <span class="hljs-meta">#<span class="hljs-keyword">define</span> PTE_LIBRARY        0x0004    <span class="hljs-comment">// 共享内存</span></span><br></code></pre></td></tr></table></figure><p>其余的一些定义（异常码的解释略去）：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"> <span class="hljs-number">1</span> <span class="hljs-meta">#<span class="hljs-keyword">define</span> KERNBASE 0x80010000 <span class="hljs-comment">// 内核基地址</span></span><br> <span class="hljs-number">2</span> <br> <span class="hljs-number">3</span> <span class="hljs-meta">#<span class="hljs-keyword">define</span> VPT (ULIM + PDMAP ) <span class="hljs-comment">//</span></span><br> <span class="hljs-number">4</span> <span class="hljs-meta">#<span class="hljs-keyword">define</span> KSTACKTOP (VPT-0x100) <span class="hljs-comment">// 内核栈顶</span></span><br> <span class="hljs-number">5</span> <span class="hljs-meta">#<span class="hljs-keyword">define</span> KSTKSIZE (8*BY2PG) <span class="hljs-comment">// 内核栈大小</span></span><br> <span class="hljs-number">6</span> <span class="hljs-meta">#<span class="hljs-keyword">define</span> ULIM 0x80000000 <span class="hljs-comment">// 用户态地址上限</span></span><br> <span class="hljs-number">7</span> <br> <span class="hljs-number">8</span> <span class="hljs-meta">#<span class="hljs-keyword">define</span> UVPT (ULIM - PDMAP) <span class="hljs-comment">// </span></span><br> <span class="hljs-number">9</span> <span class="hljs-meta">#<span class="hljs-keyword">define</span> UPAGES (UVPT - PDMAP) <span class="hljs-comment">// 用户页表</span></span><br><span class="hljs-number">10</span> <span class="hljs-meta">#<span class="hljs-keyword">define</span> UENVS (UPAGES - PDMAP) <span class="hljs-comment">// 用户进程控制块</span></span><br><span class="hljs-number">11</span> <br><span class="hljs-number">12</span> <span class="hljs-meta">#<span class="hljs-keyword">define</span> UTOP UENVS <span class="hljs-comment">// 用户态高地址</span></span><br><span class="hljs-number">13</span> <span class="hljs-meta">#<span class="hljs-keyword">define</span> UXSTACKTOP (UTOP) <span class="hljs-comment">// 用户态异常栈</span></span><br><span class="hljs-number">14</span> <span class="hljs-meta">#<span class="hljs-keyword">define</span> TIMESTACK 0x82000000 <span class="hljs-comment">// 上下文保存栈</span></span><br><span class="hljs-number">15</span> <br><span class="hljs-number">16</span> <span class="hljs-meta">#<span class="hljs-keyword">define</span> USTACKTOP (UTOP - 2*BY2PG) <span class="hljs-comment">// 用户栈</span></span><br><span class="hljs-number">17</span> <span class="hljs-meta">#<span class="hljs-keyword">define</span> UTEXT 0x00400000 <span class="hljs-comment">// 用户代码段</span></span><br></code></pre></td></tr></table></figure><p>最后是一些函数与函数宏：</p><ul><li><code>void bcopy(const void *, void *, size_t)</code>：内存拷贝</li><li><code>void bzero(void *, size_t)</code>：内存清空</li><li><code>assert(x)</code>：支持断言机制。</li><li><code>TRUP(_p)</code>：相当于<code>min(_p, ULIM)</code>，似乎是为了防止用户读写内核段内存。</li></ul><p>在进行内存初始化时，<code>mips_detect_memory()</code>、<code>mips_vm_init()</code>与<code>page_init()</code>被依次调用。<code>mips_detect_memory()</code>用来初始化一些全局变量（此处将物理内存大小设置为64MB，在实际中，内存大小是由硬件得到的，这里只是模拟了检测物理内存大小这个过程）。其余的函数的功能为：</p><ul><li><code>static void *alloc(u_int n, u_int align, int clear)</code>：申请一块内存，返回首地址。</li><li><code>static Pte *boot_pgdir_walk(Pde *pgdir, u_long va, int create)</code>：从页目录项中找出虚拟地址<code>va</code>对应的页表项，若<code>create</code>置位，则不存在时创建。</li><li><code>void boot_map_segment(Pde *pgdir, u_long va, u_long size, u_long pa, int perm)</code>：将虚拟地址<code>va</code>映射到物理地址<code>pa</code>。</li><li><code>void mips_vm_init()</code>：创建一个二级页表。</li><li><code>void page_init(void)</code>：将内存分页并初始化空闲页表。</li><li><code>int page_alloc(struct Page **pp)</code>：分配一页内存并把值赋给pp。</li><li><code>void page_free(struct Page *pp)</code>：释放一页内存。</li><li><code>int pgdir_walk(Pde *pgdir, u_long va, int create, Pte **ppte)</code>：建立起二级页表结构后从页目录中找到va对应页表项的函数。</li><li><code>int page_insert(Pde *pgdir, struct Page *pp, u_long va, u_int perm)</code>：将物理页pp映射到va。</li><li><code>struct Page * page_lookup(Pde *pgdir, u_long va, Pte **ppte)</code>：找到虚拟地址va对应的物理页面。</li><li><code>void page_decref(struct Page *pp)</code>：降低物理页面的引用次数，降到0后释放页面。</li><li><code>void page_remove(Pde *pgdir, u_long va)</code>：释放虚拟地址va对应的页面。</li><li><code>void tlb_invalidate(Pde *pgdir, u_long va)</code>：更新TLB。</li></ul>]]></content>
    
    
    <categories>
      
      <category>OS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>OS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>OS-Lab1</title>
    <link href="/2022/07/17/OS-Lab1/"/>
    <url>/2022/07/17/OS-Lab1/</url>
    
    <content type="html"><![CDATA[<h4 id="一-内核的物理位置"><a href="#一-内核的物理位置" class="headerlink" title="一.内核的物理位置"></a>一.内核的物理位置</h4><p>操作系统最重要的部分是操作系统内核，因为内核需要直接与硬件交互管理各个硬件，从而利用硬件的功能为用户进程提供服务。</p><p>启动操作系统，我们就需要将内核代码在计算机结构上运行起来，一个程序要能够运行，其代码必须能够被 CPU 直接访问，所以不能在磁盘上，因为 CPU 无法直接访问磁盘。</p><blockquote><p>CPU可以直接从硬盘里调用数据，然而这样太慢了，而内存则比硬盘快得多，把用有的东西先放入内存里面，CPU调用起来就快得。</p></blockquote><p>所以不可能将内核代码保存在内存中。所以直观上可以认识到：</p><p>(1) 磁盘不能直接访问</p><p>(2) 内存掉电易失，内核文件有可能放置的位置只能是 CPU 能够直接访问的非易失性存储器——ROM 或 FLASH 中。</p><p>将硬件初始化的相关工作从操作系统中抽出放在bootloader中实现，意味着通过这种方式实现了硬件启动和软件启动的分离。 因此需要存储在非易失性存储器中的硬件启动相关指令不需要很多，能够很容易地保存在ROM或FLASH中。</p><p>bootloader在硬件初始化完后，需要为软件启动（即操作系统内核的功能）做相应的准备， 比如需要将内核镜像文件从存放它的存储器（比如磁盘）中读到RAM中。既然bootloader需要将内核镜像文件加载到内存中， 那么它就能选择使用哪一个内核镜像进行加载，即实现多重开机的功能。使用bootloader后，我们就能够在一个硬件上运行多个操作系统了</p><h4 id="二-Bootloader"><a href="#二-Bootloader" class="headerlink" title="二.Bootloader"></a>二.Bootloader</h4><p>而当内存被初始化，bootloader将后续代码载入到内存中后，位于内存中的代码便能完整地使用C语言的各类功能了。 所以说，内存中的代码拥有了一个正常的C环境。</p><p>在 stage 1 时，需要初始化硬件设备，包括watchdog timer、中断、时钟、内存等。需要注意的一个细节是，此时内存 RAM 尚未初始化完成， 因而 stage 1 直接运行在存放 bootloader 的存储设备上（比如FLASH）。由于当前阶段不能在内存 RAM 中运行，其自身运行会受诸多限制， 比如有些 flash 程序不可写，即使程序可写的 flash 也有存储空间限制。这就是为什么需要stage 2的原因。 stage 1除了初始化基本的硬件设备以外，会为加载stage 2准备RAM空间，然后将stage 2的代码复制到RAM空间，并且设置堆栈，最后跳转到stage 2的入口函数。</p><p>stage 2运行在RAM中，此时有足够的运行环境，所以可以用C语言来实现较为复杂的功能。 这一阶段的工作包括，初始化这一阶段需要使用的硬件设备以及其他功能，然后将内核镜像文件从存储器读到RAM中，并为内核设置启动参数， 最后将CPU指令寄存器的内容设置为内核入口函数的地址，即可将控制权从bootloader转交给操作系统内核。</p><p>gxemul支持加载elf格式内核，所以启动流程被简化为加载内核到内存，之后跳转到内核的入口。启动完毕</p><h4 id="三-编译和链接"><a href="#三-编译和链接" class="headerlink" title="三.编译和链接"></a>三.编译和链接</h4><p>printf的实现是在链接(Link)这一步骤中被插入到最终的可执行文件中的。那么，了解这个细节究竟有什么用呢？ 作为一个库函数，printf被大量的程序所使用。因此，每次都将其编译一遍实在太浪费时间了。printf的实现其实早就被编译成了二进制形式。</p><p>但此时，printf并未链接到程序中，它的状态与我们利用-c选项产生的hello.o相仿，都还处于未链接的状态。而在编译的最后，链接器(Linker)会将所有的目标文件链接在一起，将之前未填写的地址等信息填上，形成最终的可执行文件，这就是链接的过程。</p><p>对于拥有多个c文件的工程来说，编译器会首先将所有的c文件以文件为单位，编译成.o文件。最后再将所有的.o文件以及函数库链接在一起， 形成最终的可执行文件。</p><p>链接器通过哪些信息来链接多个目标文件呢？答案就在于在目标文件（也就是我们通过-c选项生成的.o文件）。 在目标文件中，记录了代码各个段的具体信息。链接器通过这些信息来将目标文件链接到一起。而ELF(Executable and Linkable Format)正是Unix上常用的一种目标文件格式。 其实，不仅仅是目标文件，可执行文件也是使用ELF格式记录的。</p><h4 id="四-va-list、va-start和va-end三个宏的用法。"><a href="#四-va-list、va-start和va-end三个宏的用法。" class="headerlink" title="四.va_list、va_start和va_end三个宏的用法。"></a>四.va_list、va_start和va_end三个宏的用法。</h4><p>1.c语言提供了函数的不定长参数使用，比如 void func(int a, …)。三个省略号，表示了不定长参数。</p><p>注意：c标准规定了，函数必须至少有一个明确定义的参数，因此，省略号前面必须有至少一个参数。</p><p>2.va_list宏定义了一个指针类型，这个指针类型指向参数列表中的参数。</p><p>3.void va_start(va_list ap, last_arg)，修改了用va_list申明的指针，比如ap，使这个指针指向了不定长参数列表省略号前的参数。</p><p>4.type va_arg(va_list, type)，获取参数列表的下一个参数，并以type的类型返回。</p><p>5.void va_end(va_list ap)， 参数列表访问完以后，参数列表指针与其他指针一样，必须收回，否则出现野指针。一般va_start 和va_end配套使用。</p><p>5.函数的参数一般从右至左先后入栈，根据栈的特性，也就是，最左边的参数最先出栈。贴一段代码介绍下va_list、va_start和va_end的使用。</p><p>感兴趣的，可以把函数的整型换成char或者int，参数列表判断条件为NUL，还可以为每个参数指定类型。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdarg.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">functestarg</span><span class="hljs-params">(<span class="hljs-type">int</span>, ...)</span></span>;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span> <span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-built_in">functestarg</span>(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>,<span class="hljs-number">10</span>,<span class="hljs-number">0</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">functestarg</span><span class="hljs-params">(<span class="hljs-type">int</span> a, ...)</span></span><br><span class="hljs-function"></span>&#123;<br>va_list argpointer;<br><span class="hljs-built_in">va_start</span>(argpointer, a);<br><span class="hljs-type">int</span> argument;<br><span class="hljs-type">int</span> count = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">while</span>(<span class="hljs-number">0</span> != (argument = <span class="hljs-built_in">va_arg</span>(argpointer, <span class="hljs-type">int</span>)))<br>&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;parameter%d:%d\n&quot;</span>, ++count, argument);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="五-ELF文件的结构"><a href="#五-ELF文件的结构" class="headerlink" title="五.ELF文件的结构"></a>五.ELF文件的结构</h4><p>ELF文件的解析</p><p>需要输出 ELF ⽂件的所有 section header 的序号和地址信息<br><img src="https://img-blog.csdnimg.cn/d85cbf57560b441b8b203c6a72f8be1b.png#pic_center" alt="在这里插入图片描述"></p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs awk">typedef struct &#123;<br>    unsigned char   e_ident[EI_NIDENT];     <span class="hljs-regexp">/* Magic number and other info */</span><br>    <span class="hljs-regexp">//</span> 存放魔数以及其他信息<br>    Elf32_Half      e_type;                 <span class="hljs-regexp">/* Object file type */</span><br>    <span class="hljs-regexp">//</span> 文件类型 <br>    Elf32_Half      e_machine;              <span class="hljs-regexp">/* Architecture */</span><br>    <span class="hljs-regexp">//</span> 机器架构<br>    Elf32_Word      e_version;              <span class="hljs-regexp">/* Object file version */</span><br>    <span class="hljs-regexp">//</span> 文件版本<br>    Elf32_Addr      e_entry;                <span class="hljs-regexp">/* Entry point virtual address */</span><br>    <span class="hljs-regexp">//</span> 入口点的虚拟地址<br>    Elf32_Off       e_phoff;                <span class="hljs-regexp">/* Program header table file offset */</span><br>    <span class="hljs-regexp">//</span> 程序头表所在处与此文件头的偏移<br>    Elf32_Off       e_shoff;                <span class="hljs-regexp">/* Section header table file offset */</span><br>    <span class="hljs-regexp">//</span> 段头表所在处与此文件头的偏移<br>    Elf32_Word      e_flags;                <span class="hljs-regexp">/* Processor-specific flags */</span><br>    <span class="hljs-regexp">//</span> 针对处理器的标记<br>    Elf32_Half      e_ehsize;               <span class="hljs-regexp">/* ELF header size in bytes */</span><br>    <span class="hljs-regexp">//</span> ELF文件头的大小（单位为字节）<br>    Elf32_Half      e_phentsize;            <span class="hljs-regexp">/* Program header table entry size */</span><br>    <span class="hljs-regexp">//</span> 程序头表入口大小<br>    Elf32_Half      e_phnum;                <span class="hljs-regexp">/* Program header table entry count */</span><br>    <span class="hljs-regexp">//</span> 程序头表入口数<br>    Elf32_Half      e_shentsize;            <span class="hljs-regexp">/* Section header table entry size */</span><br>    <span class="hljs-regexp">//</span> 段头表入口大小<br>    Elf32_Half      e_shnum;                <span class="hljs-regexp">/* Section header table entry count */</span><br>    <span class="hljs-regexp">//</span> 段头表入口数<br>    Elf32_Half      e_shstrndx;             <span class="hljs-regexp">/* Section header string table index */</span><br>    <span class="hljs-regexp">//</span> 段头字符串编号<br>&#125; Elf32_Ehdr;<br></code></pre></td></tr></table></figure><h4 id="六-lp-Print-函数流程图"><a href="#六-lp-Print-函数流程图" class="headerlink" title="六.lp_Print()函数流程图"></a>六.lp_Print()函数流程图</h4><p><img src="https://img-blog.csdnimg.cn/018a774203e24b81b0d1cbe2052970c4.png#pic_center" alt="在这里插入图片描述"></p>]]></content>
    
    
    <categories>
      
      <category>OS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>OS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>OS-Lab0</title>
    <link href="/2022/07/16/OS-Lab0/"/>
    <url>/2022/07/16/OS-Lab0/</url>
    
    <content type="html"><![CDATA[<h3 id="一-GIT-的常规操作"><a href="#一-GIT-的常规操作" class="headerlink" title="一.GIT 的常规操作"></a>一.GIT 的常规操作</h3><p>常规操作也是我自己平时常用的几个命令, 学自于 pro git 这本书中</p><h4 id="一-git-基本使用"><a href="#一-git-基本使用" class="headerlink" title="一.git 基本使用"></a>一.git 基本使用</h4><ol><li><p>clone现有仓库</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git <span class="hljs-built_in">clone</span> URL  (URL支持git，ssh，http，https等各种协议)<br></code></pre></td></tr></table></figure></li><li><p>git中文件的各个状态</p><ul><li>unstaged - git仓库中没有此文件的相关记录</li><li>modified - git仓库中有这个文件的记录，并且此文件当前有改动</li><li>staged - 追加,删除或修改的文件被暂时保存，这些追加,删除和修改并没有提交到git仓库</li><li>commited - 追加或修改的文件被提交到本地git仓库（git仓库中大部分都是这种文件，所以git status不显示这些文件）</li></ul></li><li><p>查看git仓库中各文件状态</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs lua">git <span class="hljs-built_in">status</span><br></code></pre></td></tr></table></figure></li><li><p>初始化一个仓库</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs csharp">git <span class="hljs-keyword">init</span><br></code></pre></td></tr></table></figure><p>在当前文件夹下生成.git目录，完成初始化，此时此文件夹下的所有文件处于unstaged状态</p></li><li><p>追加文件</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs x86asm">git <span class="hljs-keyword">add</span> <span class="hljs-keyword">test</span><span class="hljs-number">.</span>c<br></code></pre></td></tr></table></figure><p>test.c的文件变为staged状态，其他文件还是unstaged状态</p><p>5.1 追加文件的结果1 - 恢复为原先状态（变为unstaged）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git <span class="hljs-built_in">rm</span> --cache test.c<br></code></pre></td></tr></table></figure><p>5.2 追加文件的结果2 - 提交到git仓库（变为commited）</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">git <span class="hljs-keyword">commit</span> <span class="hljs-operator">-</span>m &quot;my message&quot;<br></code></pre></td></tr></table></figure></li><li><p>修改文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;aaa&quot;</span>  &gt;&gt; test.c<br></code></pre></td></tr></table></figure><p>test.c的状态变为modified</p><p>6.1 修改文件的结果1</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs x86asm">git <span class="hljs-keyword">add</span> <span class="hljs-keyword">test</span><span class="hljs-number">.</span>c  (暂时保存修改的内容，即变为staged）<br></code></pre></td></tr></table></figure><p>下面有2条路可以选择：<br>6.1.1 取消刚才的暂时保存</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs perl">git <span class="hljs-keyword">reset</span> test.c  （状态变回modified）<br></code></pre></td></tr></table></figure><p>6.2.2 将暂存的修改提交到git仓库</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">git <span class="hljs-keyword">commit</span> <span class="hljs-operator">-</span>m &quot;my message&quot;<br></code></pre></td></tr></table></figure><p>6.2 修改文件的结果2</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs x86asm">git checkout <span class="hljs-keyword">test</span><span class="hljs-number">.</span>c  （将<span class="hljs-keyword">test</span><span class="hljs-number">.</span>c恢复为git仓库中的最新版本，即变为commited状态，<span class="hljs-keyword">test</span><span class="hljs-number">.</span>c的内容和<span class="hljs-number">5.2</span>节一样）<br></code></pre></td></tr></table></figure></li><li><p>删除文件<br>7.1 从git仓库和磁盘上删除文件</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs x86asm">git rm <span class="hljs-keyword">test</span><span class="hljs-number">.</span>c  （当前目录中删除了<span class="hljs-keyword">test</span><span class="hljs-number">.</span>c，在git仓库中暂时删除了<span class="hljs-keyword">test</span><span class="hljs-number">.</span>c，相当于staged状态）<br></code></pre></td></tr></table></figure><p>7.1.1 从git仓库中删除test.c</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">git <span class="hljs-keyword">commit</span> <span class="hljs-operator">-</span>m &quot;my message&quot;  (git仓库以后不再维护test.c)<br></code></pre></td></tr></table></figure><p>7.1.2 删错了，恢复刚才的操作</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs x86asm">git reset HEAD <span class="hljs-keyword">test</span><span class="hljs-number">.</span>c  (恢复到删除前的状态，当前目录中已删除的<span class="hljs-keyword">test</span><span class="hljs-number">.</span>c也恢复了，<span class="hljs-keyword">test</span><span class="hljs-number">.</span>c仍文commited状态)<br></code></pre></td></tr></table></figure><p>7.2 仅从git仓库中删除文件</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs x86asm">git rm --cache <span class="hljs-keyword">test</span><span class="hljs-number">.</span>c （当前目录中没有删除了<span class="hljs-keyword">test</span><span class="hljs-number">.</span>c，仅在git仓库中暂时删除了<span class="hljs-keyword">test</span><span class="hljs-number">.</span>c，相当于staged状态）<br></code></pre></td></tr></table></figure><p>7.2.1 从git仓库中删除test.c</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs x86asm">git commit -m <span class="hljs-string">&quot;my message&quot;</span>  (git仓库以后不再维护<span class="hljs-keyword">test</span><span class="hljs-number">.</span>c，但是当前目录中仍然有<span class="hljs-keyword">test</span><span class="hljs-number">.</span>c)<br></code></pre></td></tr></table></figure><p>7.2.2 删错了，恢复刚才的操作</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs perl">git <span class="hljs-keyword">reset</span> HEAD test.c  （和<span class="hljs-number">7.1</span>.<span class="hljs-number">2</span>一样）<br></code></pre></td></tr></table></figure><p>7.3 误删除后的恢复<br>如果删除了一个文件，并且commit之后发现删错了。也可以恢复，</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">git <span class="hljs-built_in">log</span>  （查看各次的提交信息）<br>git checkout commit号  （恢复到未删除前的commint号，此时删除的文件也恢复到磁盘上了）<br>git checkout master  (备份好删除的文件后，再回到最新状态)<br></code></pre></td></tr></table></figure></li></ol><h4 id="二-git-远程仓库"><a href="#二-git-远程仓库" class="headerlink" title="二.git 远程仓库"></a>二.git 远程仓库</h4><ol><li><p>查看远程仓库<br>1.1 简单查看-所有仓库</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">git <span class="hljs-title function_">remote</span> <span class="hljs-params">(只能查看远程仓库的名字)</span><br></code></pre></td></tr></table></figure><p>1.2 查看更多内容-所有仓库</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs scss">git remote -v (远程仓库的名字及git地址)<br></code></pre></td></tr></table></figure><p>1.3 查看单个仓库的信息</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">git remote show <span class="hljs-selector-attr">[remote-name]</span><br></code></pre></td></tr></table></figure></li><li><p>新建远程仓库</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs csharp">git remote <span class="hljs-keyword">add</span> [shortname] [url]<br>ex. git remote <span class="hljs-keyword">add</span> mc git:<span class="hljs-comment">//www.host.com/gitdir/mycode.git</span><br></code></pre></td></tr></table></figure></li><li><p>修改远程仓库</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">git remote rename <span class="hljs-selector-attr">[oldnanme]</span> <span class="hljs-selector-attr">[newname]</span><br></code></pre></td></tr></table></figure></li><li><p>删除远程仓库</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git remote <span class="hljs-built_in">rm</span> [remote-name]<br></code></pre></td></tr></table></figure></li><li><p>远程仓库的数据<br>5.1 获取数据</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs scss">git fetch <span class="hljs-selector-attr">[remote-name]</span> (获取仓库的所有更新，但是不自动合并当前分支)<br>git pull (获取仓库的所有更新, 并且自动合并到当前分支)<br></code></pre></td></tr></table></figure><p>5.2 上传数据</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs css">git push <span class="hljs-selector-attr">[remote-name]</span> <span class="hljs-selector-attr">[branch-name]</span><br>ex. git push origin master<br></code></pre></td></tr></table></figure></li></ol><h4 id="三-git-分支"><a href="#三-git-分支" class="headerlink" title="三.git 分支"></a>三.git 分支</h4><ol><li><p>查看和切换分支</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs scss">git branch (查看所有的分支及当前处于哪个分支)<br>git branch -v (查看所有的分支的详细信息)<br>git branch <span class="hljs-attr">--merged</span> (查看已经合并的分支)<br>git branch <span class="hljs-attr">--no-merged</span> (查看还没合并的分支)<br>git checkout <span class="hljs-selector-attr">[branch-name]</span> (切换到某个分支)<br></code></pre></td></tr></table></figure></li><li><p>新建分支</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">git <span class="hljs-keyword">branch </span>[<span class="hljs-keyword">branch-name] </span> (新建一个分支)<br>git <span class="hljs-keyword">branch </span>-<span class="hljs-keyword">b </span>[<span class="hljs-keyword">branch-name] </span>(新建一个分支并切换到这个分支上)<br></code></pre></td></tr></table></figure></li><li><p>合并分支</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">git merge [<span class="hljs-keyword">branch-name]</span><br><span class="hljs-keyword"></span>ex. 将分支<span class="hljs-keyword">btest合并到主分支master</span><br><span class="hljs-keyword"></span>git checkout master<br>git merge <span class="hljs-keyword">btest</span><br></code></pre></td></tr></table></figure><p>merge时有冲突的文件会列出来，需要手动合并</p><p>将冲突手动解决后，再次用 git status来查看是否还有 unmerged的文件。<br>如果没有冲突的文件，就可以 git commit 来提交这次合并了。</p></li><li><p>删除分支</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">git <span class="hljs-keyword">branch </span>-d [<span class="hljs-keyword">branch-name]</span><br><span class="hljs-keyword"></span>或者 git <span class="hljs-keyword">branch </span>-D [<span class="hljs-keyword">branch-name] </span>(强制删除某个还未合并的分支)<br></code></pre></td></tr></table></figure></li><li><p>远程分支相关<br>5.1 新建远程分支</p><ol><li>git checkout [local_branch] (首先进入想要上传的分支)</li><li>git remote add [remote_repo] [remote_branch]<br>(这里的[remote_branch]是远程分支的名字，一般和[local_branch]同名,<br>[remote_repo]是远程仓库的名字)</li></ol><p>5.2 向远程分支推送数据</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">git push <span class="hljs-selector-attr">[remote_repo]</span> <span class="hljs-selector-attr">[remote_branch]</span><br></code></pre></td></tr></table></figure><p>5.3 删除远程分支</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-selector-tag">git</span> <span class="hljs-selector-tag">push</span> <span class="hljs-selector-attr">[remote_repo]</span> :<span class="hljs-selector-attr">[remote_branch]</span> (注意远程分支前有个<span class="hljs-string">&quot;:&quot;</span>)<br></code></pre></td></tr></table></figure></li></ol><h3 id="二-shell-变量的定义，赋值，运算"><a href="#二-shell-变量的定义，赋值，运算" class="headerlink" title="二.shell 变量的定义，赋值，运算"></a>二.shell 变量的定义，赋值，运算</h3><h4 id="一、变量类型"><a href="#一、变量类型" class="headerlink" title="一、变量类型"></a>一、变量类型</h4><h5 id="1-1、自定义变量"><a href="#1-1、自定义变量" class="headerlink" title="1.1、自定义变量"></a>1.1、自定义变量</h5><p>1.定义变量</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs csharp">不能使用纯数字命名，不能使用横杠命名<br>变量名=变量值<br>[<span class="hljs-meta">root@localhost ~</span>]<span class="hljs-meta"># name=erha   </span><br></code></pre></td></tr></table></figure><p>2.引用变量</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ruby"><span class="hljs-variable">$变</span>量名 或者 <span class="hljs-variable">$&#123;</span>变量量名&#125;<br></code></pre></td></tr></table></figure><p>3.查看变量值</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs ruby">echo<span class="hljs-variable">$变</span>量量名<br>[root<span class="hljs-variable">@localhost</span> ~]<span class="hljs-comment"># echo $name</span><br>erha<br></code></pre></td></tr></table></figure><p>4.取消变量</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs csharp">[<span class="hljs-meta">root@localhost ~</span>]<span class="hljs-meta"># unset  name</span><br>[<span class="hljs-meta">root@localhost ~</span>]<span class="hljs-meta"># echo $name</span><br></code></pre></td></tr></table></figure><p>5.作⽤用范围<br>仅在当前shell中有效</p><h5 id="1-2、系统环境变量"><a href="#1-2、系统环境变量" class="headerlink" title="1.2、系统环境变量"></a>1.2、系统环境变量</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$</span><span class="language-bash">1<span class="hljs-variable">$2</span><span class="hljs-variable">$3</span><span class="hljs-variable">$4</span><span class="hljs-variable">$5</span><span class="hljs-variable">$6</span> ...</span><br><span class="hljs-meta prompt_">#</span><span class="language-bash"><span class="hljs-variable">$1</span>代表向脚本内传递的第一个位置参数，<span class="hljs-variable">$2</span>代表第二个，依次类推。</span><br></code></pre></td></tr></table></figure><h5 id="1-3、预定义变量"><a href="#1-3、预定义变量" class="headerlink" title="1.3、预定义变量"></a>1.3、预定义变量</h5><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs powershell"><span class="hljs-variable">$0</span>脚本⽂文件名 <br><span class="hljs-variable">$</span>* <span class="hljs-variable">$</span><span class="hljs-selector-tag">@</span>所有的参数 <br><span class="hljs-variable">$</span><span class="hljs-comment">#参数的个数</span><br><span class="hljs-variable">$</span><span class="hljs-variable">$</span>当前进程的 PID <br><span class="hljs-variable">$</span>!上一个后台进程的 PID <br><span class="hljs-variable">$</span>?上一个命令的返回值 <span class="hljs-number">0</span> 表示成功<br></code></pre></td></tr></table></figure><p> <strong>小脚本</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs bash">[root@localhost ~]<span class="hljs-comment"># cat var.sh </span><br><span class="hljs-comment">#!/bin/bash</span><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;第一个参数：<span class="hljs-variable">$1</span>&quot;</span><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;第二个参数：<span class="hljs-variable">$2</span>&quot;</span><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;第三个参数：<span class="hljs-variable">$3</span>&quot;</span><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;第四个参数：<span class="hljs-variable">$4</span>&quot;</span><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;所有参数为：$*&quot;</span><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;参数个数为：<span class="hljs-variable">$#</span>&quot;</span><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;当前进程ID为：$$&quot;</span><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;上一个进程ID为：$!&quot;</span><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;当前脚本名称为：<span class="hljs-variable">$0</span>&quot;</span><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;当前脚本执行结果：$?&quot;</span><br></code></pre></td></tr></table></figure><p><strong>执行如下</strong></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs csharp">[<span class="hljs-meta">root@localhost ~</span>]<span class="hljs-meta"># sh var.sh 1 2 3 4 5 </span><br>第一个参数：<span class="hljs-number">1</span><br>第二个参数：<span class="hljs-number">2</span><br>第三个参数：<span class="hljs-number">3</span><br>第四个参数：<span class="hljs-number">4</span><br>所有参数为：<span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">4</span> <span class="hljs-number">5</span><br>参数个数为：<span class="hljs-number">5</span><br>当前进程ID为：<span class="hljs-number">8875</span><br>上一个进程ID为：<br>当前脚本名称为：<span class="hljs-keyword">var</span>.sh<br>当前脚本执行结果：<span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><h4 id="二、变量赋值"><a href="#二、变量赋值" class="headerlink" title="二、变量赋值"></a>二、变量赋值</h4><h5 id="2-1、直接赋值"><a href="#2-1、直接赋值" class="headerlink" title="2.1、直接赋值"></a>2.1、直接赋值</h5><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs csharp">[<span class="hljs-meta">root@localhost ~</span>]<span class="hljs-meta"># name=huahua</span><br><span class="hljs-meta">#注意等号两边不能有空格</span><br></code></pre></td></tr></table></figure><h5 id="2-2、从键盘读入"><a href="#2-2、从键盘读入" class="headerlink" title="2.2、从键盘读入"></a>2.2、从键盘读入</h5><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs diff">[root@localhost ~]# read 参数 变量名<br>可选参数<br><span class="hljs-deletion">-p :提示信息</span><br><span class="hljs-deletion">-t :等待时间</span><br><span class="hljs-deletion">-n :读入字符数</span><br></code></pre></td></tr></table></figure><p><strong>小脚本</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs bash">解压文件到指定位置<br>[root@localhost ~]<span class="hljs-comment"># cat tr.sh </span><br><span class="hljs-comment">#!/bin/bash</span><br><span class="hljs-built_in">read</span> -p <span class="hljs-string">&quot;请输入要解压的文件，及解压目录：&quot;</span> src dst<br><span class="hljs-keyword">if</span> [ -e <span class="hljs-variable">$src</span> ];<span class="hljs-keyword">then</span><br>tar -zxvf <span class="hljs-variable">$src</span> -C <span class="hljs-variable">$dst</span><br><span class="hljs-keyword">else</span><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;没有该文件...&quot;</span><br><span class="hljs-keyword">fi</span><br></code></pre></td></tr></table></figure><h5 id="2-3、强引用与弱引用"><a href="#2-3、强引用与弱引用" class="headerlink" title="2.3、强引用与弱引用"></a>2.3、强引用与弱引用</h5><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-string">&quot;&quot;</span> :弱引用，特殊字符依旧有特定含义。<br>[root@localhost ~]<span class="hljs-comment"># age=18</span><br>[root@localhost ~]<span class="hljs-comment"># echo &quot;$age&quot;</span><br><span class="hljs-number">18</span><br><br><span class="hljs-string">&#x27;&#x27;</span> :强引用，所有字符被当作普通字符处理。<br>[root@localhost ~]<span class="hljs-comment"># echo &#x27;$name&#x27;</span><br>$name<br></code></pre></td></tr></table></figure><h5 id="2-4、命令执行结果引用"><a href="#2-4、命令执行结果引用" class="headerlink" title="2.4、命令执行结果引用"></a>2.4、命令执行结果引用</h5><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs ruby"><span class="hljs-string">``</span> <span class="hljs-symbol">:</span>反引号，不过容易与引号混淆。<br>[root<span class="hljs-variable">@localhost</span> ~]<span class="hljs-comment"># t1=`date +%F`</span><br>[root<span class="hljs-variable">@localhost</span> ~]<span class="hljs-comment"># echo $t1</span><br><span class="hljs-number">2020</span>-<span class="hljs-number">01</span>-<span class="hljs-number">20</span><br><br><span class="hljs-variable">$(</span>)<span class="hljs-symbol">:</span><span class="hljs-variable">$加</span>小括号，不容易混淆，一般使用这种方式较多<br>[root<span class="hljs-variable">@localhost</span> ~]<span class="hljs-comment"># t2=$(date +%F)</span><br>[root<span class="hljs-variable">@localhost</span> ~]<span class="hljs-comment"># echo $t2</span><br><span class="hljs-number">2020</span>-<span class="hljs-number">01</span>-<span class="hljs-number">20</span><br></code></pre></td></tr></table></figure><h4 id="三、数学运算"><a href="#三、数学运算" class="headerlink" title="三、数学运算"></a>三、数学运算</h4><h5 id="3-1、整数运算（expr）"><a href="#3-1、整数运算（expr）" class="headerlink" title="3.1、整数运算（expr）"></a>3.1、整数运算（expr）</h5><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs csharp">加 减 乘 除 取余<br>+  -  \* /   % <br><br>[<span class="hljs-meta">root@localhost ~</span>]<span class="hljs-meta"># expr 1 + 1</span><br><span class="hljs-number">2</span><br>[<span class="hljs-meta">root@localhost ~</span>]<span class="hljs-meta"># expr 1 - 1</span><br><span class="hljs-number">0</span><br>[<span class="hljs-meta">root@localhost ~</span>]<span class="hljs-meta"># expr 1 \* 1</span><br><span class="hljs-number">1</span><br>[<span class="hljs-meta">root@localhost ~</span>]<span class="hljs-meta"># expr 1 / 1</span><br><span class="hljs-number">1</span><br>[<span class="hljs-meta">root@localhost ~</span>]<span class="hljs-meta"># expr 1 % 1</span><br><span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><h5 id="3-2、整数运算（-）"><a href="#3-2、整数运算（-）" class="headerlink" title="3.2、整数运算（$(())）"></a>3.2、整数运算（$(())）</h5><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs csharp">加 减 乘 除 取余 幂运算<br>+  -  * /   %   **<br><br>[<span class="hljs-meta">root@localhost ~</span>]<span class="hljs-meta"># echo $((1 + 2))</span><br><span class="hljs-number">3</span><br>[<span class="hljs-meta">root@localhost ~</span>]<span class="hljs-meta"># echo $((1 - 2))</span><br><span class="hljs-number">-1</span><br>[<span class="hljs-meta">root@localhost ~</span>]<span class="hljs-meta"># echo $((1 * 2))</span><br><span class="hljs-number">2</span><br>[<span class="hljs-meta">root@localhost ~</span>]<span class="hljs-meta"># echo $((1 / 2))</span><br><span class="hljs-number">0</span><br>[<span class="hljs-meta">root@localhost ~</span>]<span class="hljs-meta"># echo $((1 % 2))</span><br><span class="hljs-number">1</span><br>[<span class="hljs-meta">root@localhost ~</span>]<span class="hljs-meta"># echo $((1 ** 2))</span><br><span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><h5 id="3-3、整数运算（-）"><a href="#3-3、整数运算（-）" class="headerlink" title="3.3、整数运算（$[]）"></a>3.3、整数运算（$[]）</h5><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs ruby">与 <span class="hljs-variable">$(</span>())类似<br>[root<span class="hljs-variable">@localhost</span> ~]<span class="hljs-comment"># echo $[1+2]</span><br><span class="hljs-number">3</span><br>[root<span class="hljs-variable">@localhost</span> ~]<span class="hljs-comment"># echo $[1-2]</span><br>-<span class="hljs-number">1</span><br>[root<span class="hljs-variable">@localhost</span> ~]<span class="hljs-comment"># echo $[1*2]</span><br><span class="hljs-number">2</span><br>[root<span class="hljs-variable">@localhost</span> ~]<span class="hljs-comment"># echo $[1/2]</span><br><span class="hljs-number">0</span><br>[root<span class="hljs-variable">@localhost</span> ~]<span class="hljs-comment"># echo $[1**2]</span><br><span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><h5 id="3-4、整数运算（let）"><a href="#3-4、整数运算（let）" class="headerlink" title="3.4、整数运算（let）"></a>3.4、整数运算（let）</h5><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs csharp">加 减 乘 除 取余 幂运算<br>+  -  * /   %   **<br><br>[<span class="hljs-meta">root@localhost ~</span>]<span class="hljs-meta"># let nu=2**4</span><br>[<span class="hljs-meta">root@localhost ~</span>]<span class="hljs-meta"># echo $nu</span><br><span class="hljs-number">16</span><br></code></pre></td></tr></table></figure><h5 id="3-5、小数运算"><a href="#3-5、小数运算" class="headerlink" title="3.5、小数运算"></a>3.5、小数运算</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp">可以使用bc命令<br>[root@localhost ~]<span class="hljs-meta"># echo <span class="hljs-string">&quot;1.1&quot;</span>+<span class="hljs-string">&quot;2.3&quot;</span>|bc</span><br><span class="hljs-number">3.4</span><br></code></pre></td></tr></table></figure><h3 id="三-vim实用笔记"><a href="#三-vim实用笔记" class="headerlink" title="三.vim实用笔记"></a>三.vim实用笔记</h3><h4 id="一、vim实用基础配置"><a href="#一、vim实用基础配置" class="headerlink" title="一、vim实用基础配置"></a>一、vim实用基础配置</h4><p>配置出了可以通过命令实现外，也可以将set内容添加到vim配置文件&#x2F;etc&#x2F;vim&#x2F;vimrc中，当然，添加到vimrc就不需要在set前面加”:”了。</p><p><strong>1、设置显示行号可以使用命令</strong> ”:set number”</p><p><strong>2、文件自动保存</strong>，”:set autowrite”</p><p><strong>3、实用配置列表：</strong></p><p>因为这些配置实在太多，就不一一列举了，总结和摘录了一个常用的配置表，可以直接复制粘贴到vimrc配置文件中（“符号后面的都会被识别为注释）：</p><blockquote><p>syntax on “ 自动语法高亮，其实vim7.3版本语法默认是高亮的</p><p>colorscheme evening” 一种好看的配色方案</p><p>set shiftwidth&#x3D;4 “ 设定 &lt;&lt; 和 &gt;&gt; 命令移动时的宽度为 4个字符</p><p>set tabstop&#x3D;4 “ 设定 tab 长度为 4个字符</p><p>filetype plugin indent on “ 开启插件</p><p>set ignorecase “ 搜索时忽略大小写</p><p>set incsearch “ 即刻显示当前输入的搜索结果</p><p>set hlsearch “ 高亮搜索结果</p><p>set noerrorbells “ 关闭错误信息响铃</p><p>set autochdir “ 自动切换当前目录为当前文件所在目录</p><p>filetype indent on “自动缩进</p><p>set autoindent shiftwidth&#x3D;n “修正缩进，ctrl+T或ctrl+D或者&gt;&gt;、&lt;&lt;均对应n个字符缩进</p></blockquote><h4 id="二、vim查找功能"><a href="#二、vim查找功能" class="headerlink" title="二、vim查找功能"></a>二、vim查找功能</h4><p><strong>1、最基础的查找：</strong></p><p><Esc>状态，直接按 &#x2F; 键。然后输入要查找的内容。下一个查找结果按n。如果查找的内容带有符号‘.*[]^%&#x2F;n?~$ ，则添加转义字符方式“ \ ”再进行查找即可。</p><p><strong>2、精确查找：</strong></p><p>比如说我要确切地找到一个单词“top”。则按 &#x2F; 键，然后输入如下内容：</p><p>&#x2F;&lt;top&gt;</p><p>其实它的意思是，搜索以top开头，并以top结尾的单词。所以如果我们希望查找以top开头的所有单词：</p><p>&#x2F;&lt;top</p><p>以top结尾的单词：</p><p>&#x2F;top&gt;</p><p><strong>3、跨文件查找字符：</strong></p><p>比如，在进行某个文件的编辑时，我希望找到当前工作目录中所有含有”include”字符串的cpp文件：</p><blockquote><p>“:grep include *.cpp”</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>OS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>OS</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
