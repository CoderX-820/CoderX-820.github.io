<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>OS-Lab4-challenge</title>
    <link href="/2022/07/17/OS-Lab4-challenge/"/>
    <url>/2022/07/17/OS-Lab4-challenge/</url>
    
    <content type="html"><![CDATA[<h3 id="实现思路"><a href="#实现思路" class="headerlink" title="实现思路"></a>实现思路</h3><p>实现线程运行与信号量机制的一个基础就是正确定义好线程控制块(TCB)与信号量(sem)结构,然后其他所有的函数都围绕这两个数据结构中的对应内容进行编写。</p><p>下述以部分重点内容为例，结合代码分析所做的工作</p><p><strong>1.include&#x2F;env.h</strong></p><p><strong>（1）定义线程，信号量相关宏</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp">例如：<br><span class="hljs-meta">#<span class="hljs-keyword">define</span> THREAD_MAX8</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> THREAD_CAN_BE_CANCELED 1</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> THREAD_CANNOT_BE_CANCELED0</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> THREAD_CANCEL_IMI0</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> THREAD_CANCEL_POINT1</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> SEM_FREE0</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> SEM_VALID1</span><br></code></pre></td></tr></table></figure><p><strong>（2）定义线程控制块与信号量的结构</strong></p><figure class="highlight d"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs d">线程控制块的编写主要依据是我们要实现的四个线程功能：创建、终止、撤销和阻塞至线程结束，依据这四个要实现的功能定义我们的线程控制块。<br><span class="hljs-keyword">struct</span> Tcb &#123;<br><span class="hljs-comment">// 基础信息</span><br><span class="hljs-keyword">struct</span> Trapframe tcb_tf;<br>u_int thread_id;<br>u_int tcb_status;<br>u_int tcb_pri;<br><br><span class="hljs-comment">// 阻塞相关信息</span><br>LIST_ENTRY(Tcb) tcb_sched_link;<br>LIST_ENTRY(Tcb) tcb_joined_link;<br>LIST_HEAD(Tcb_joined_list,Tcb);<br><span class="hljs-keyword">struct</span> Tcb_joined_list tcb_joined_list;<br><span class="hljs-keyword">void</span> **tcb_join_value_ptr;<br>u_int tcb_detach;<br><br><span class="hljs-comment">// 线程终止</span><br><span class="hljs-keyword">void</span> *tcb_exit_ptr;<br><span class="hljs-keyword">int</span> tcb_exit_value;<br><br><span class="hljs-comment">// 撤销线程</span><br><span class="hljs-keyword">int</span> tcb_cancelstate;<br><span class="hljs-keyword">int</span> tcb_canceltype;<br>u_int tcb_canceled;<br><br><span class="hljs-comment">// 留白</span><br>u_int tcb_nop[<span class="hljs-number">10</span>];<br>&#125;;<br><br>其中需要特别注意的部分就是<span class="hljs-string">`tcb_nop`</span>这个变量。这个变量在实际的线程控制中不起到任何作用，添加这个变量是为了页对齐。在我们的设计中，一个线程最多可以创建<span class="hljs-number">8</span>个线程，设计上我们让一个进程控制块占据一个页表大小(<span class="hljs-number">4</span>KB)，一个线程控制块占据<span class="hljs-number">256</span>B。这样的设计让我们在之后创建线程号以及分配线程栈的时候有很多的方便之处。为了达到这个大小要求，我们在线程控制块和进程控制块中均进行了留白。<br><br>线程中的留白<br><span class="hljs-keyword">struct</span> Env &#123;<br>    ......<br><span class="hljs-comment">// 留白</span><br>u_int env_nop[<span class="hljs-number">496</span>];<br><br><span class="hljs-comment">// 线程控制块</span><br><span class="hljs-keyword">struct</span> Tcb env_threads[<span class="hljs-number">8</span>];<br>&#125;;<br><br>信号量的整个结构体相较线程较为简单，没有特别的难点。使用以下结构体便可以实现信号量的初始化、销毁、阻塞P操作、非阻塞P操作、V操作和取值。这里不过多叙述。<br><span class="hljs-keyword">struct</span> sem &#123;<br>u_int sem_envid;<br>u_int sem_head_index;<br>u_int sem_tail_index;<br><span class="hljs-built_in">char</span> sem_name[<span class="hljs-number">16</span>];<br><span class="hljs-keyword">int</span> sem_value;<br><span class="hljs-keyword">int</span> sem_status;<br><span class="hljs-keyword">int</span> sem_shared;<br><span class="hljs-keyword">int</span> sem_wait_count;<br><span class="hljs-keyword">struct</span> Tcb *sem_wait_list[<span class="hljs-number">10</span>];<br>&#125;;<br></code></pre></td></tr></table></figure><p><strong>（3）定义实现线程与信号量机制的相关函数与数据结构</strong></p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">类似于进程的创建，线程也需要一些全局的变量去控制。<br><span class="hljs-constructor">LIST_HEAD(Tcb_list, Tcb)</span>;<br>extern <span class="hljs-keyword">struct</span> Tcb *curtcb;<br>extern <span class="hljs-keyword">struct</span> Tcb_list tcb_sched_list<span class="hljs-literal">[<span class="hljs-number">2</span>]</span>;<br><span class="hljs-built_in">int</span> thread<span class="hljs-constructor">_alloc(<span class="hljs-params">struct</span> Env <span class="hljs-operator">*</span><span class="hljs-params">e</span>, <span class="hljs-params">struct</span> Tcb <span class="hljs-operator">**</span><span class="hljs-params">t</span>)</span>;<br></code></pre></td></tr></table></figure><p><strong>（4）修改引入线程信号量前体系下的逻辑冲突</strong></p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">在挑战性任务的实现中，任何任务的运行都是以线程为单位的，所以很多如下的函数都要修改：<br><span class="hljs-keyword">struct</span> env的定义<br>void env<span class="hljs-constructor">_run(<span class="hljs-params">struct</span> Tcb <span class="hljs-operator">*</span><span class="hljs-params">e</span>)</span>的定义<br></code></pre></td></tr></table></figure><p><strong>2.include&#x2F;error.h</strong></p><p>定义线程与信号量机制相关的错误</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">define</span> E_THREAD_MAX13</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> E_THREAD_NOTFOUND 14</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> E_THREAD_CANNOTCANCEL 15</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> E_SEM_ERROR16</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> E_SEM_NOTFOUND17</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> E_SEM_EAGAIN18</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAXERROR 18</span><br></code></pre></td></tr></table></figure><p><strong>3.lib&#x2F;env.c</strong></p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-number">1.</span>新函数的实现<br>u_int mktcbid(<span class="hljs-keyword">struct</span> Tcb *t)<br><span class="hljs-built_in">int</span> threadid2tcb(u_int threadid, <span class="hljs-keyword">struct</span> Tcb **ptcb)<br><span class="hljs-built_in">int</span> thread<span class="hljs-constructor">_alloc(<span class="hljs-params">struct</span> Env <span class="hljs-operator">*</span><span class="hljs-params">e</span>, <span class="hljs-params">struct</span> Tcb <span class="hljs-operator">**</span><span class="hljs-params">new</span>)</span><br>void thread<span class="hljs-constructor">_free(<span class="hljs-params">struct</span> Tcb <span class="hljs-operator">*</span><span class="hljs-params">t</span>)</span> <br>void thread<span class="hljs-constructor">_destroy(<span class="hljs-params">struct</span> Tcb <span class="hljs-operator">*</span><span class="hljs-params">t</span>)</span> <br><br><span class="hljs-number">2.</span>修改新体系下的逻辑冲突<br><span class="hljs-built_in">int</span> envid2env(u_int envid, <span class="hljs-keyword">struct</span> Env **penv, <span class="hljs-built_in">int</span> checkperm)<br><span class="hljs-built_in">int</span> env<span class="hljs-constructor">_alloc(<span class="hljs-params">struct</span> Env <span class="hljs-operator">**</span><span class="hljs-params">new</span>, <span class="hljs-params">u_int</span> <span class="hljs-params">parent_id</span>)</span><br>static void load<span class="hljs-constructor">_icode(<span class="hljs-params">struct</span> Env <span class="hljs-operator">*</span><span class="hljs-params">e</span>, <span class="hljs-params">u_char</span> <span class="hljs-operator">*</span><span class="hljs-params">binary</span>, <span class="hljs-params">u_int</span> <span class="hljs-params">size</span>)</span><br>void env<span class="hljs-constructor">_create_priority(<span class="hljs-params">u_char</span> <span class="hljs-operator">*</span><span class="hljs-params">binary</span>, <span class="hljs-params">int</span> <span class="hljs-params">size</span>, <span class="hljs-params">int</span> <span class="hljs-params">priority</span>)</span><br>void env<span class="hljs-constructor">_create(<span class="hljs-params">u_char</span> <span class="hljs-operator">*</span><span class="hljs-params">binary</span>, <span class="hljs-params">int</span> <span class="hljs-params">size</span>)</span><br>void env<span class="hljs-constructor">_free(<span class="hljs-params">struct</span> Env <span class="hljs-operator">*</span><span class="hljs-params">e</span>)</span><br>void env<span class="hljs-constructor">_destroy(<span class="hljs-params">struct</span> Env <span class="hljs-operator">*</span><span class="hljs-params">e</span>)</span><br>void env<span class="hljs-constructor">_run(<span class="hljs-params">struct</span> Tcb <span class="hljs-operator">*</span><span class="hljs-params">t</span>)</span><br></code></pre></td></tr></table></figure><p><strong>重点函数解析：</strong></p><p><strong>（1）创建进程的ID</strong></p><p>如前文所说，一个进程控制块占据一页的大小，可以容纳8个线程控制块，所以这里可以直接根据偏移量来生成线程的控制号。</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs lisp">u_int mktcbid(<span class="hljs-name">struct</span> Tcb *t) &#123;<br>struct Env *e = ROUNDDOWN(<span class="hljs-name">t</span>,BY2PG)<span class="hljs-comment">;</span><br>u_int tcb_no = ((<span class="hljs-name">u_int</span>)<span class="hljs-literal">t</span> - (<span class="hljs-name">u_int</span>)e - BY2PG/2)/(<span class="hljs-name">BY2PG/16</span>)<span class="hljs-comment">;</span><br>return ((<span class="hljs-name">e-&gt;env_id</span> &lt;&lt; <span class="hljs-number">3</span>) | tcb_no)<span class="hljs-comment">;</span><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>（2）创建线程</strong></p><p>这个函数其实就是将之前env_alloc函数初始化的东西移入了线程的创建，因为现在运行的最小单位变成了线程 。下面列出来的部分是线程控制块的选择逻辑。我们会从上一次创建线程的位置开始往下找，直到找到一个可用的空间，这样可以让每一个存储位置都有机会被使用。省略号部分是初始化内容。</p><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs xl">int thread_alloc(struct Env *e, struct Tcb **new) &#123;<br><span class="hljs-function"><span class="hljs-title">if</span> (e-&gt;</span>env_thread_count &gt;= THREAD_MAX) <br>return E_THREAD_MAX;<br><span class="hljs-function"><span class="hljs-title">u_int</span> thread_no = e-&gt;</span>env_thread_count;<br>u_int i = <span class="hljs-number">0</span>;<br><span class="hljs-function"><span class="hljs-title">while</span> (e-&gt;</span>env_threads[thread_no].tcb_status != ENV_FREE) &#123;<br>++thread_no;<br>thread_no = thread_no % THREAD_MAX;<br>++i; <br><span class="hljs-keyword">if</span> (i &gt;= THREAD_MAX)<br>return E_THREAD_MAX;<br>&#125;<br>++(<span class="hljs-function"><span class="hljs-title">e</span>-&gt;</span>env_thread_count);<br><span class="hljs-function"><span class="hljs-title">struct</span> Tcb *t = &amp;e-&gt;</span>env_threads[thread_no];<br><span class="hljs-function"><span class="hljs-title">t</span>-&gt;</span>thread_id = mktcbid(t);<br><span class="hljs-function"><span class="hljs-title">printf</span>(&quot;thread id <span class="hljs-keyword">is</span> 2&#x27;b%b\n&quot;,t-&gt;</span>thread_id);<br><span class="hljs-function"><span class="hljs-title">t</span>-&gt;</span>tcb_status = ENV_RUNNABLE;<br><span class="hljs-function"><span class="hljs-title">t</span>-&gt;</span>tcb_tf.cp0_status = <span class="hljs-number">0</span>x10001004;<br><span class="hljs-function"><span class="hljs-title">t</span>-&gt;</span>tcb_exit_ptr = (void *)<span class="hljs-number">0</span>;<br><span class="hljs-function"><span class="hljs-title">t</span>-&gt;</span><span class="hljs-function"><span class="hljs-title">tcb_tf</span>.regs[29] = USTACKTOP - 4*BY2PG*(t-&gt;</span>thread_id &amp; <span class="hljs-number">0</span>x7);<br><span class="hljs-function"><span class="hljs-title">t</span>-&gt;</span>tcb_cancelstate = THREAD_CANNOT_BE_CANCELED;<br><span class="hljs-function"><span class="hljs-title">t</span>-&gt;</span>tcb_canceltype = THREAD_CANCEL_IMI;<br><span class="hljs-function"><span class="hljs-title">t</span>-&gt;</span>tcb_canceled = <span class="hljs-number">0</span>;<br><span class="hljs-function"><span class="hljs-title">t</span>-&gt;</span>tcb_exit_value = <span class="hljs-number">0</span>;<br><span class="hljs-function"><span class="hljs-title">t</span>-&gt;</span><span class="hljs-function"><span class="hljs-title">tcb_exit_ptr</span> = (void *)&amp;t-&gt;</span>tcb_exit_value;<br><span class="hljs-function"><span class="hljs-title">t</span>-&gt;</span>tcb_detach = <span class="hljs-number">0</span>;<br>LIST_INIT(&amp;<span class="hljs-function"><span class="hljs-title">t</span>-&gt;</span>tcb_joined_list);<br>*new = t;<br>return <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>（3）线程的销毁</strong></p><p>类似于进程的销毁，在进行时钟中断的时候要将当前的 KERNEL_SP 内容拷贝到 TIMESTACK 中，并且当一个进程的所有线程都被销毁后要将这个进程控制块释放。</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">void thread<span class="hljs-constructor">_free(<span class="hljs-params">struct</span> Tcb <span class="hljs-operator">*</span><span class="hljs-params">t</span>)</span> <br>&#123;<br><span class="hljs-keyword">struct</span> Env *e = <span class="hljs-constructor">ROUNDDOWN(<span class="hljs-params">t</span>,BY2PG)</span>;<br>printf(<span class="hljs-string">&quot;[%08x] free tcb %08x\n&quot;</span>, e-&gt;env_id, t-&gt;thread_id);<br>--e-&gt;env_thread_count;<br><span class="hljs-keyword">if</span> (e-&gt;env_thread_count &lt;= <span class="hljs-number">0</span>) &#123;<br>env<span class="hljs-constructor">_free(<span class="hljs-params">e</span>)</span>;<br>&#125;<br>t-&gt;tcb_status = ENV_FREE;<br>&#125;<br><br>void thread<span class="hljs-constructor">_destroy(<span class="hljs-params">struct</span> Tcb <span class="hljs-operator">*</span><span class="hljs-params">t</span>)</span> &#123;<br><span class="hljs-keyword">if</span> (t-&gt;tcb_status<span class="hljs-operator"> == </span>ENV_RUNNABLE)<br><span class="hljs-constructor">LIST_REMOVE(<span class="hljs-params">t</span>,<span class="hljs-params">tcb_sched_link</span>)</span>;<br>thread<span class="hljs-constructor">_free(<span class="hljs-params">t</span>)</span>;<br><span class="hljs-keyword">if</span> (curtcb<span class="hljs-operator"> == </span>t) &#123;<br>curtcb = NULL;<br>bcopy((void *)KERNEL_SP - sizeof(<span class="hljs-keyword">struct</span> Trapframe),<br>(void *)TIMESTACK - sizeof(<span class="hljs-keyword">struct</span> Trapframe),<br>sizeof(<span class="hljs-keyword">struct</span> Trapframe));<br>printf(<span class="hljs-string">&quot;i am thread, i am killed ... \n&quot;</span>);<br>sched<span class="hljs-constructor">_yield()</span>;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>4.lib&#x2F;sched.c</strong></p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">以线程为单位进行调度<br>void sched<span class="hljs-constructor">_yield(<span class="hljs-params">void</span>)</span><br>&#123;<br>static <span class="hljs-built_in">int</span> times = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">struct</span> Env *e = curenv;<br><span class="hljs-keyword">struct</span> Tcb *t = curtcb;<br>static <span class="hljs-built_in">int</span> sched_i = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">if</span> (!t) &#123;<br><span class="hljs-keyword">while</span> (<span class="hljs-constructor">LIST_EMPTY(&amp;<span class="hljs-params">tcb_sched_list</span>[<span class="hljs-params">sched_i</span>])</span>) &#123;<br>sched_i ^= <span class="hljs-number">1</span>;<br>&#125;<br>t = <span class="hljs-constructor">LIST_FIRST(&amp;<span class="hljs-params">tcb_sched_list</span>[<span class="hljs-params">sched_i</span>])</span>;<br>times = t-&gt;tcb_pri;<br>times -= <span class="hljs-number">1</span>;<br>env<span class="hljs-constructor">_run(<span class="hljs-params">t</span>)</span>;<br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (t-&gt;tcb_status != ENV_RUNNABLE) &#123;<br><span class="hljs-keyword">while</span> (<span class="hljs-constructor">LIST_EMPTY(&amp;<span class="hljs-params">tcb_sched_list</span>[<span class="hljs-params">sched_i</span>])</span>) &#123;<br>sched_i ^= <span class="hljs-number">1</span>;<br>&#125;<br>t = <span class="hljs-constructor">LIST_FIRST(&amp;<span class="hljs-params">tcb_sched_list</span>[<span class="hljs-params">sched_i</span>])</span>;<br>times = t-&gt;tcb_pri;<br>times -= <span class="hljs-number">1</span>;<br>env<span class="hljs-constructor">_run(<span class="hljs-params">t</span>)</span>;<br>&#125;<br><span class="hljs-keyword">if</span> (times &lt;= <span class="hljs-number">0</span>) &#123;<br><span class="hljs-constructor">LIST_REMOVE(<span class="hljs-params">t</span>,<span class="hljs-params">tcb_sched_link</span>)</span>;<br><span class="hljs-constructor">LIST_INSERT_HEAD(&amp;<span class="hljs-params">tcb_sched_list</span>[<span class="hljs-params">sched_i</span>^1],<span class="hljs-params">t</span>,<span class="hljs-params">tcb_sched_link</span>)</span>;<br><span class="hljs-keyword">while</span> (<span class="hljs-constructor">LIST_EMPTY(&amp;<span class="hljs-params">tcb_sched_list</span>[<span class="hljs-params">sched_i</span>])</span>) &#123;<br>sched_i ^= <span class="hljs-number">1</span>;<br>&#125;<br>t = <span class="hljs-constructor">LIST_FIRST(&amp;<span class="hljs-params">tcb_sched_list</span>[<span class="hljs-params">sched_i</span>])</span>;<br>times = t-&gt;tcb_pri;<br>times -= <span class="hljs-number">1</span>;<br>env<span class="hljs-constructor">_run(<span class="hljs-params">t</span>)</span>;<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>times -= <span class="hljs-number">1</span>;<br>env<span class="hljs-constructor">_run(<span class="hljs-params">t</span>)</span>;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>5.系统调用的新增与修改</strong></p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-number">1.</span>新增的系统调用<br>u_int sys<span class="hljs-constructor">_getthreadid(<span class="hljs-params">void</span>)</span><br><span class="hljs-built_in">int</span> sys<span class="hljs-constructor">_thread_destroy(<span class="hljs-params">int</span> <span class="hljs-params">sysno</span>, <span class="hljs-params">u_int</span> <span class="hljs-params">threadid</span>)</span><br><span class="hljs-built_in">int</span> sys<span class="hljs-constructor">_thread_alloc(<span class="hljs-params">void</span>)</span><br><span class="hljs-built_in">int</span> sys<span class="hljs-constructor">_set_thread_status(<span class="hljs-params">int</span> <span class="hljs-params">sysno</span>, <span class="hljs-params">u_int</span> <span class="hljs-params">threadid</span>, <span class="hljs-params">u_int</span> <span class="hljs-params">status</span>)</span><br><span class="hljs-built_in">int</span> sys<span class="hljs-constructor">_thread_join(<span class="hljs-params">int</span> <span class="hljs-params">sysno</span>, <span class="hljs-params">u_int</span> <span class="hljs-params">threadid</span>, <span class="hljs-params">void</span> <span class="hljs-operator">**</span><span class="hljs-params">value_ptr</span>)</span><br><br><span class="hljs-built_in">int</span> sys<span class="hljs-constructor">_sem_destroy(<span class="hljs-params">int</span> <span class="hljs-params">sysno</span>,<span class="hljs-params">sem_t</span> <span class="hljs-operator">*</span><span class="hljs-params">sem</span>)</span><br><span class="hljs-built_in">int</span> sys<span class="hljs-constructor">_sem_wait(<span class="hljs-params">int</span> <span class="hljs-params">sysno</span>,<span class="hljs-params">sem_t</span> <span class="hljs-operator">*</span><span class="hljs-params">sem</span>)</span><br><span class="hljs-built_in">int</span> sys<span class="hljs-constructor">_sem_trywait(<span class="hljs-params">int</span> <span class="hljs-params">sysno</span>, <span class="hljs-params">sem_t</span> <span class="hljs-operator">*</span><span class="hljs-params">sem</span>)</span><br><span class="hljs-built_in">int</span> sys<span class="hljs-constructor">_sem_post(<span class="hljs-params">int</span> <span class="hljs-params">sysno</span>, <span class="hljs-params">sem_t</span> <span class="hljs-operator">*</span><span class="hljs-params">sem</span>)</span><br><span class="hljs-built_in">int</span> sys<span class="hljs-constructor">_sem_getvalue(<span class="hljs-params">int</span> <span class="hljs-params">sysno</span>, <span class="hljs-params">sem_t</span> <span class="hljs-operator">*</span><span class="hljs-params">sem</span>, <span class="hljs-params">int</span> <span class="hljs-operator">*</span><span class="hljs-params">valp</span>)</span><br><br><span class="hljs-number">2.</span>修改的系统调用<br><span class="hljs-built_in">int</span> sys<span class="hljs-constructor">_env_alloc(<span class="hljs-params">void</span>)</span><br><span class="hljs-built_in">int</span> sys<span class="hljs-constructor">_set_env_status(<span class="hljs-params">int</span> <span class="hljs-params">sysno</span>, <span class="hljs-params">u_int</span> <span class="hljs-params">envid</span>, <span class="hljs-params">u_int</span> <span class="hljs-params">status</span>)</span><br>void sys<span class="hljs-constructor">_ipc_recv(<span class="hljs-params">int</span> <span class="hljs-params">sysno</span>, <span class="hljs-params">u_int</span> <span class="hljs-params">dstva</span>)</span><br><span class="hljs-built_in">int</span> sys<span class="hljs-constructor">_ipc_can_send(<span class="hljs-params">int</span> <span class="hljs-params">sysno</span>, <span class="hljs-params">u_int</span> <span class="hljs-params">envid</span>, <span class="hljs-params">u_int</span> <span class="hljs-params">value</span>, <span class="hljs-params">u_int</span> <span class="hljs-params">srcva</span>, <span class="hljs-params">u_int</span> <span class="hljs-params">perm</span>)</span><br></code></pre></td></tr></table></figure><p><strong>重点函数解析：</strong></p><p><strong>（1）设置线程的状态</strong></p><p>进行这个系统调用可以改变线程的状态，这在线程的阻塞和调度中起到了十分重要的作用。</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-built_in">int</span> sys<span class="hljs-constructor">_set_env_status(<span class="hljs-params">int</span> <span class="hljs-params">sysno</span>, <span class="hljs-params">u_int</span> <span class="hljs-params">envid</span>, <span class="hljs-params">u_int</span> <span class="hljs-params">status</span>)</span><br>&#123;<br><span class="hljs-comment">// Your code here.</span><br><span class="hljs-keyword">struct</span> Env *env;<br><span class="hljs-keyword">struct</span> Tcb *tcb;<br><span class="hljs-built_in">int</span> ret;<br><br><span class="hljs-keyword">if</span> ((status != ENV_RUNNABLE)&amp;&amp;(status != ENV_NOT_RUNNABLE)&amp;&amp;(status != ENV_FREE))<br>return -E_INVAL;<br>ret = envid2env(envid,&amp;env,<span class="hljs-number">0</span>);<br>tcb = &amp;env-&gt;env_threads<span class="hljs-literal">[<span class="hljs-number">0</span>]</span>;<br><span class="hljs-keyword">if</span> (ret &lt; <span class="hljs-number">0</span>)<br>return ret;<br><span class="hljs-keyword">if</span> ((status<span class="hljs-operator"> == </span>ENV_RUNNABLE)&amp;&amp;(tcb-&gt;tcb_status != ENV_RUNNABLE)) &#123;<br><span class="hljs-constructor">LIST_INSERT_HEAD(<span class="hljs-params">tcb_sched_list</span>,<span class="hljs-params">tcb</span>,<span class="hljs-params">tcb_sched_link</span>)</span>;<br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>((tcb-&gt;tcb_status<span class="hljs-operator"> == </span>ENV_RUNNABLE)&amp;&amp;(status != ENV_RUNNABLE)) &#123;<br><span class="hljs-constructor">LIST_REMOVE(<span class="hljs-params">tcb</span>,<span class="hljs-params">tcb_sched_link</span>)</span>;<br>&#125;<br>env-&gt;env_threads<span class="hljs-literal">[<span class="hljs-number">0</span>]</span>.tcb_status = status;<br>return <span class="hljs-number">0</span>;<br><span class="hljs-comment">//panic(&quot;sys_env_set_status not implemented&quot;);</span><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>（2）线程的阻塞等待</strong></p><p>一个进程可以主动等待一个指定的线程完成后才继续往下执行。这个系统调用可以保证一些执行的顺序。</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-built_in">int</span> sys<span class="hljs-constructor">_thread_join(<span class="hljs-params">int</span> <span class="hljs-params">sysno</span>, <span class="hljs-params">u_int</span> <span class="hljs-params">threadid</span>, <span class="hljs-params">void</span> <span class="hljs-operator">**</span><span class="hljs-params">value_ptr</span>)</span><br>&#123;<br><span class="hljs-keyword">struct</span> Tcb *t;<br><span class="hljs-built_in">int</span> r;<br><span class="hljs-comment">//printf(&quot;here id is 0x%x\n&quot;,threadid);</span><br>r = threadid2tcb(threadid,&amp;t);<br><span class="hljs-comment">//printf(&quot;find id is 0x%x\n&quot;,t-&gt;thread_id);</span><br><span class="hljs-keyword">if</span> (r &lt; <span class="hljs-number">0</span>)<br>return r;<br><span class="hljs-keyword">if</span> (t-&gt;tcb_detach) &#123;<br>return -E_THREAD_JOIN_FAIL;<br>&#125;<br><span class="hljs-keyword">if</span> (t-&gt;tcb_status<span class="hljs-operator"> == </span>ENV_FREE) &#123;<br><span class="hljs-keyword">if</span> (value_ptr != <span class="hljs-number">0</span>) &#123;<br>*value_ptr = t-&gt;tcb_exit_ptr;<br>&#125;<br>return <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-comment">//printf(&quot;father id is 0x%x\n&quot;,t-&gt;thread_id);</span><br><span class="hljs-constructor">LIST_INSERT_HEAD(&amp;<span class="hljs-params">t</span>-&gt;<span class="hljs-params">tcb_joined_list</span>,<span class="hljs-params">curtcb</span>,<span class="hljs-params">tcb_joined_link</span>)</span>;<br>curtcb-&gt;tcb_join_value_ptr = value_ptr;<br>sys<span class="hljs-constructor">_set_thread_status(0,<span class="hljs-params">curtcb</span>-&gt;<span class="hljs-params">thread_id</span>,ENV_NOT_RUNNABLE)</span>;<br><span class="hljs-keyword">struct</span> Trapframe *trap = (<span class="hljs-keyword">struct</span> Trapframe *)(KERNEL_SP - sizeof(<span class="hljs-keyword">struct</span> Trapframe));<br>trap-&gt;regs<span class="hljs-literal">[<span class="hljs-number">2</span>]</span> = <span class="hljs-number">0</span>;<br>trap-&gt;pc = trap-&gt;cp0_epc;<br>sys<span class="hljs-constructor">_yield()</span>;<br>return <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>（3）信号量的P操作(阻塞和非阻塞)</strong></p><p>当一个线程想要申请一个信号量的时候就会调用一下两个函数之一。如果是进行的阻塞申请，并且当前没有可用的信号量，那么信号量结构体就会将当前申请的进程加入到等待队列中。等待队列的实现逻辑本质上是一个循环列表，当超过最大等待上线的时候便会报错。</p><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs xl"><span class="hljs-comment">//阻塞</span><br>int sys_sem_wait(int sysno,sem_t *sem)<br>&#123;<br><span class="hljs-function"><span class="hljs-title">if</span> (sem-&gt;</span>sem_status == SEM_FREE) &#123;<br>return -E_SEM_ERROR;<br>&#125;<br>int i;<br><span class="hljs-function"><span class="hljs-title">if</span> (sem-&gt;</span>sem_value &gt; <span class="hljs-number">0</span>) &#123;<br>--<span class="hljs-function"><span class="hljs-title">sem</span>-&gt;</span>sem_value;<br>return <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-title">if</span> (sem-&gt;</span>sem_wait_count &gt;= <span class="hljs-number">10</span>) &#123;<br>return -E_SEM_ERROR;<br>&#125;<br><span class="hljs-function"><span class="hljs-title">sem</span>-&gt;</span><span class="hljs-function"><span class="hljs-title">sem_wait_list</span>[sem-&gt;</span>sem_head_index] = curtcb;<br><span class="hljs-function"><span class="hljs-title">sem</span>-&gt;</span><span class="hljs-function"><span class="hljs-title">sem_head_index</span> = (sem-&gt;</span>sem_head_index + <span class="hljs-number">1</span>) % <span class="hljs-number">10</span>;<br>++<span class="hljs-function"><span class="hljs-title">sem</span>-&gt;</span>sem_wait_count;<br>sys_set_thread_status(<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,ENV_NOT_RUNNABLE);<br>struct Trapframe *trap = (struct Trapframe *)(KERNEL_SP - sizeof(struct Trapframe));<br><span class="hljs-function"><span class="hljs-title">trap</span>-&gt;</span>regs[<span class="hljs-number">2</span>] = <span class="hljs-number">0</span>;<br><span class="hljs-function"><span class="hljs-title">trap</span>-&gt;</span><span class="hljs-function"><span class="hljs-title">pc</span> = trap-&gt;</span>cp0_epc;<br><span class="hljs-comment">//printf(&quot;wait thread is 0x%x\n&quot;,curtcb-&gt;thread_id);</span><br>sys_yield();<br>return -E_SEM_ERROR;<br>&#125;<br><br><span class="hljs-comment">//非阻塞</span><br>int sys_sem_trywait(int sysno, sem_t *sem)<br>&#123;<br><span class="hljs-function"><span class="hljs-title">if</span> (sem-&gt;</span>sem_status == SEM_FREE) &#123;<br>return -E_SEM_ERROR;<br>&#125;<br><span class="hljs-function"><span class="hljs-title">if</span> (sem-&gt;</span>sem_value &gt; <span class="hljs-number">0</span>) &#123;<br>--<span class="hljs-function"><span class="hljs-title">sem</span>-&gt;</span>sem_value;<br>return <span class="hljs-number">0</span>;<br>&#125;<br>return -E_SEM_EAGAIN;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>（4）信号量的V操作</strong></p><p>实现了基本的V操作，对当前有无等待进行了分别的处理。</p><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs xl">int sys_sem_post(int sysno, sem_t *sem)<br>&#123;<br><span class="hljs-function"><span class="hljs-title">if</span> (sem-&gt;</span>sem_status == SEM_FREE) &#123;<br>return -E_SEM_ERROR;<br>&#125;<br><span class="hljs-function"><span class="hljs-title">if</span> (sem-&gt;</span>sem_value &gt; <span class="hljs-number">0</span>) &#123;<br>++<span class="hljs-function"><span class="hljs-title">sem</span>-&gt;</span>sem_value;<br>&#125; <span class="hljs-keyword">else</span> &#123;<br><span class="hljs-function"><span class="hljs-title">if</span> (sem-&gt;</span>sem_wait_count == <span class="hljs-number">0</span>) &#123;<br>++<span class="hljs-function"><span class="hljs-title">sem</span>-&gt;</span>sem_value;<br>&#125;<br><span class="hljs-keyword">else</span> &#123;<br>struct Tcb *t;<br>--<span class="hljs-function"><span class="hljs-title">sem</span>-&gt;</span>sem_wait_count;<br><span class="hljs-function"><span class="hljs-title">t</span> = sem-&gt;</span><span class="hljs-function"><span class="hljs-title">sem_wait_list</span>[sem-&gt;</span>sem_tail_index];<br><span class="hljs-function"><span class="hljs-title">sem</span>-&gt;</span><span class="hljs-function"><span class="hljs-title">sem_wait_list</span>[sem-&gt;</span>sem_tail_index] = <span class="hljs-number">0</span>;<br><span class="hljs-function"><span class="hljs-title">sem</span>-&gt;</span><span class="hljs-function"><span class="hljs-title">sem_tail_index</span> = (sem-&gt;</span>sem_tail_index + <span class="hljs-number">1</span>) % <span class="hljs-number">10</span>;<br><span class="hljs-function"><span class="hljs-title">sys_set_thread_status</span>(0,t-&gt;</span>thread_id,ENV_RUNNABLE);<br>&#125;<br>&#125;<br>return <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>6.用户态函数的实现</strong></p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-number">1.</span>user/pthread.c<br><span class="hljs-built_in">int</span> pthread<span class="hljs-constructor">_create(<span class="hljs-params">pthread_t</span> <span class="hljs-operator">*</span><span class="hljs-params">thread</span>, <span class="hljs-params">const</span> <span class="hljs-params">pthread_attr_t</span> <span class="hljs-operator">*</span><span class="hljs-params">attr</span>, <span class="hljs-params">void</span> <span class="hljs-operator">*</span> (<span class="hljs-operator">*</span><span class="hljs-params">start_rountine</span>)</span>(void *), void *arg)<br>void pthread<span class="hljs-constructor">_exit(<span class="hljs-params">void</span> <span class="hljs-operator">*</span><span class="hljs-params">value_ptr</span>)</span><br><span class="hljs-built_in">int</span> pthread<span class="hljs-constructor">_setcancelstate(<span class="hljs-params">int</span> <span class="hljs-params">state</span>, <span class="hljs-params">int</span> <span class="hljs-operator">*</span><span class="hljs-params">oldvalue</span>)</span> <br><span class="hljs-built_in">int</span> pthread<span class="hljs-constructor">_setcanceltype(<span class="hljs-params">int</span> <span class="hljs-params">type</span>, <span class="hljs-params">int</span> <span class="hljs-operator">*</span><span class="hljs-params">oldvalue</span>)</span> <br>void pthread<span class="hljs-constructor">_testcancel()</span> <br><span class="hljs-built_in">int</span> pthread<span class="hljs-constructor">_cancel(<span class="hljs-params">pthread_t</span> <span class="hljs-params">thread</span>)</span><br><span class="hljs-built_in">int</span> pthread<span class="hljs-constructor">_detach(<span class="hljs-params">pthread_t</span> <span class="hljs-params">thread</span>)</span><br><span class="hljs-built_in">int</span> pthread<span class="hljs-constructor">_join(<span class="hljs-params">pthread_t</span> <span class="hljs-params">thread</span>, <span class="hljs-params">void</span> <span class="hljs-operator">**</span><span class="hljs-params">value_ptr</span>)</span><br><br><span class="hljs-number">2.</span>user/sem.c<br><span class="hljs-built_in">int</span> sem<span class="hljs-constructor">_init(<span class="hljs-params">sem_t</span> <span class="hljs-operator">*</span><span class="hljs-params">sem</span>,<span class="hljs-params">int</span> <span class="hljs-params">shared</span>,<span class="hljs-params">unsigned</span> <span class="hljs-params">int</span> <span class="hljs-params">value</span>)</span><br><span class="hljs-built_in">int</span> sem<span class="hljs-constructor">_destroy(<span class="hljs-params">sem_t</span> <span class="hljs-operator">*</span><span class="hljs-params">sem</span>)</span><br><span class="hljs-built_in">int</span> sem<span class="hljs-constructor">_wait(<span class="hljs-params">sem_t</span> <span class="hljs-operator">*</span><span class="hljs-params">sem</span>)</span> <br><span class="hljs-built_in">int</span> sem<span class="hljs-constructor">_trywait(<span class="hljs-params">sem_t</span> <span class="hljs-operator">*</span><span class="hljs-params">sem</span>)</span><br><span class="hljs-built_in">int</span> sem<span class="hljs-constructor">_post(<span class="hljs-params">sem_t</span> <span class="hljs-operator">*</span><span class="hljs-params">sem</span>)</span><br><span class="hljs-built_in">int</span> sem<span class="hljs-constructor">_getvalue(<span class="hljs-params">sem_t</span> <span class="hljs-operator">*</span><span class="hljs-params">sem</span>,<span class="hljs-params">int</span> <span class="hljs-operator">*</span><span class="hljs-params">valp</span>)</span><br></code></pre></td></tr></table></figure><h3 id="遇到的困难及解决方案"><a href="#遇到的困难及解决方案" class="headerlink" title="遇到的困难及解决方案"></a>遇到的困难及解决方案</h3><p><strong>1.线程控制块的位置及查找</strong></p><p>我们采用了采用填充对齐的方法去布局线程和进程。这样实现简单，其次创建进程、线程的时候可以很快的生产ID，快速查找，并且空余的空间还可以添加未来可能的功能。这种结构比较适合OS课程这种小型操作系统，但是其缺点也很明显：空间浪费。如果还想要节约空间的话可能就需要使用链表之类的结构，但是那样实现繁琐，并且链表等操作速度肯定是慢于直接查找，所以没有采用链表的实现方式。</p><p><strong>2.join阻塞的实现</strong></p><p>join阻塞机制的实现利用了TCB结构体中的 Tcb_joined_list 的链表结构，利用链表储存被阻塞的线程ID，从而在线程结束时可以定位到被阻塞的进程，进行进程状态的恢复。</p><p><strong>3.线程栈的实现</strong></p><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xl"><span class="hljs-function"><span class="hljs-title">t</span>-&gt;</span><span class="hljs-function"><span class="hljs-title">tcb_tf</span>.regs[29] = USTACKTOP - 4*BY2PG*(t-&gt;</span>thread_id &amp; <span class="hljs-number">0</span>x7);<br></code></pre></td></tr></table></figure><p>在上述语句中为每一个线程分配了不同的栈区，从而保证了不同线程中运行栈的地址不能重合，实现了同一进程的不同线程可以相互访问栈内数据。</p>]]></content>
    
    
    <categories>
      
      <category>OS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>OS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>OS-Lab5</title>
    <link href="/2022/07/17/OS-Lab5/"/>
    <url>/2022/07/17/OS-Lab5/</url>
    
    <content type="html"><![CDATA[<h2 id="一-全局变量名词解释"><a href="#一-全局变量名词解释" class="headerlink" title="一.全局变量名词解释"></a>一.全局变量名词解释</h2><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs gauss"><span class="hljs-meta">#<span class="hljs-keyword">define</span> NBLOCK 1024 <span class="hljs-comment">//一块磁盘里面的block数目</span></span><br>uint32_t nbitblock; <span class="hljs-comment">// 用于存储bitmap的block数目</span><br>uint32_t nextbno;   <span class="hljs-comment">// 下一块可用的block编号</span><br><br><span class="hljs-keyword">struct</span> <span class="hljs-type">Super</span> super; <span class="hljs-comment">// 超级块</span><br><span class="hljs-keyword">struct</span> <span class="hljs-type">Block</span> &#123;<br>    uint8_t data[BY2BLK];<br>    uint32_t <span class="hljs-built_in">type</span>;<br>&#125; disk[NBLOCK];<br><br><span class="hljs-comment">///////////////////下面的内容在include里面的fs.h里面</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> BY2BLKBY2PG<span class="hljs-comment">//一个block对应的字节，也就是说，一个block正好等于一页大小</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> BIT2BLK(BY2BLK*8)<span class="hljs-comment">//一个block对应的*位数*，一字节等于8位，所以要乘8</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAXNAMELEN128<span class="hljs-comment">//用于存文件名的char数组大小，由于最后一个必定为&#x27;\0&#x27;,所以只能存127个字符</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAXPATHLEN1024<span class="hljs-comment">//和上面的类似，只不过是用来存路径的</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> NDIRECT10<span class="hljs-comment">//直接引用的个数，可以认为是10个指针，这里用int存block的下标来代替了指针的作用</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> NINDIRECT(BY2BLK/4)<span class="hljs-comment">//间接引用块的指针个数，由于一个int是32位，也就是4byte，所以是除4</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAXFILESIZE(NINDIRECT*BY2BLK)<span class="hljs-comment">//最大文件大小，那么就是引用指针的个数*一块大小</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> BY2FILE     256<span class="hljs-comment">//定义了一个FIle结构体（文件索引结构体）所占用的大小，实际上比FILE结构体实际占用大小要大，是为了保持扩展性？</span></span><br><br><span class="hljs-keyword">struct</span> <span class="hljs-type">File</span> &#123;<span class="hljs-comment">//文件索引结构体</span><br>u_char f_name[MAXNAMELEN];<span class="hljs-comment">// 文件名</span><br>u_int f_size;<span class="hljs-comment">// 文件大小（字节），其实就是引用块所占的总大小</span><br>u_int f_type;<span class="hljs-comment">// 文件类型，有两种，一种是普通文件，一种是目录</span><br>u_int f_direct[NDIRECT];<span class="hljs-comment">//直接引用指针</span><br>u_int f_indirect;<span class="hljs-comment">//指向间接引用块</span><br><br><span class="hljs-keyword">struct</span> <span class="hljs-type">File</span> *f_dir;<span class="hljs-comment">// 指向包含这个文件的目录，只在内存中存在着（真正写入文件之后没有这部分）</span><br>u_char f_pad[BY2FILE - MAXNAMELEN - <span class="hljs-number">4</span> - <span class="hljs-number">4</span> - NDIRECT * <span class="hljs-number">4</span> - <span class="hljs-number">4</span> - <span class="hljs-number">4</span>];<span class="hljs-comment">//为了填满by2file，而开了这部分内容</span><br>&#125;;<br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> FILE2BLK(BY2BLK/sizeof(struct File))<span class="hljs-comment">//就是一个block能容纳多少个file索引</span></span><br><br><span class="hljs-comment">// File types</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> FTYPE_REG0<span class="hljs-comment">// 普通文件</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> FTYPE_DIR1<span class="hljs-comment">// 目录</span></span><br><br><br><span class="hljs-comment">// File system super-block (both in-memory and on-disk)</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> FS_MAGIC0x68286097<span class="hljs-comment">// 神秘代码，用来表示这是个合法的文件</span></span><br><br><span class="hljs-keyword">struct</span> <span class="hljs-type">Super</span> &#123;<br>u_int s_magic;<span class="hljs-comment">// Magic number: FS_MAGIC</span><br>u_int s_nblocks;<span class="hljs-comment">// Total number of blocks on disk</span><br><span class="hljs-keyword">struct</span> <span class="hljs-type">File</span> s_root;<span class="hljs-comment">// Root directory node</span><br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="二-实验难点图示"><a href="#二-实验难点图示" class="headerlink" title="二.实验难点图示"></a>二.实验难点图示</h2><h4 id="1-文件系统层次关系梳理"><a href="#1-文件系统层次关系梳理" class="headerlink" title="1.文件系统层次关系梳理"></a>1.文件系统层次关系梳理</h4><p>文件系统可以分成四个层次：</p><p>文件系统用户接口、文件系统抽象层、文件系统具体实现、文件系统设备接口。</p><p>文件系统的逐级调用关系可以用下图表示：<br><img src="https://img-blog.csdnimg.cn/f7f227bf88e4455da700e8128de850d6.png" alt="在这里插入图片描述"></p><h4 id="2-多级目录与多级索引"><a href="#2-多级目录与多级索引" class="headerlink" title="2.多级目录与多级索引"></a>2.多级目录与多级索引</h4><p>多级目录用来管理文件间的层次关系，多级索引用来管理单个文件的数据。两者并不是一个概念。</p><p>在我们的实验中，目录文件的内容是文件控制块<code>struct File</code>，目录文件的每一个数据块由16个文件目录项组成，找到相应的文件名，找到对应文件的FCB，进而找到该文件的数据块。</p><p>多级索引用来管理文件的数据块，我们的实验中使用二级索引机制。在FCB中可以有一级索引数组<code>f_direct[NDIRECT]</code>，和一个二级索引<code>f_indirect</code>，二级索引找到的磁盘块为索引块，这个磁盘块可以存储1024的FCB。</p><p>目录文件综合体现了这一点，以下图来说明：</p><p><img src="https://img-blog.csdnimg.cn/e8249302ff204ed898d588a14ce80be7.png" alt="在这里插入图片描述"></p><h2 id="三-代码梳理"><a href="#三-代码梳理" class="headerlink" title="三.代码梳理"></a>三.代码梳理</h2><h4 id="1-磁盘管理"><a href="#1-磁盘管理" class="headerlink" title="1.磁盘管理"></a>1.磁盘管理</h4><p>完成文件系统的第一步就是要能够处理磁盘等外设的信息。</p><ul><li><p>lib&#x2F;syscall_all.c</p><p>处理磁盘的信息，最基本的就是对磁盘进行读写操作。<br><code>sys_write_dev</code>函数用于对外设进行写操作。首先是检查地址的合法性，写入的这段地址需要在规定地址范围之内，接着使用<code>bcopy</code>把数据复制过去即可。<br><code>sys_read_dev</code>函数用于读操作。过程与写类似。</p></li><li><p>fs&#x2F;ide.c</p><p>在实现了对外设基本的读写后，对于磁盘，为了方便上层用户操作，还需要一个封装好的磁盘驱动程序，也就是这里的<code>ide_read</code>和<code>ide_write</code>函数。<br><code>ide_read</code>函数用于从特定的磁盘块读取一定量的数据。首先需要做的就是根据起始扇区和扇区数计算首尾地址，接着是循环读取数据，具体来说首先是向控制磁盘的几个地址写入对应的信息，接着检查磁盘状态，如果正常则读取一个扇区。<br><code>ide_write</code>函数和<code>ide_read</code>函数类似，不同在于，读取磁盘状态是在写操作结束后读取检查。</p><p><img src="https://img-blog.csdnimg.cn/img_convert/ed0411419922866ca7bcedf87744bcc5.png" alt="img"></p></li><li><p>fs&#x2F;fs.c</p><p>完成了磁盘读写后，我们需要对磁盘的信息进行管理，也就是对磁盘块的使用状态进行管理。</p><p><img src="https://img-blog.csdnimg.cn/img_convert/c43836eefb38ebf058bcfb560575bf57.png" alt="img"></p><p>磁盘最开始的一个扇区被当成是启动扇区和分区表使用；接着是一个超级块，这个超级块结构体定义在include&#x2F;fs.h中，里面定义了魔数、磁盘块数量和根目录的文件控制块。接下来存储的是位图信息，用来记录磁盘块的使用信息，每一个二进制位到代表了一个磁盘块。剩余的内容都是存储数据的数据块。</p><p><code>diskaddr</code>函数用于求出某一个磁盘块的地址。首先需要判断磁盘块号的合法性，接着计算偏移加上基地址即可。块大小为<code>BY2BLK</code>。<br><code>block_is_mapped</code>函数用于检查这个块是否已经映射到了页表中。也就是通过<code>diskaddr</code>计算出地址后使用<code>va_is_mapped</code>检查是否存在于页表。<br><code>block_is_dirty</code>函数用于确定这个块的数据是否已经被修改。具体做法类似，检查页表项的<code>PTE_D</code>标志位即可。<br><code>map_block</code>函数用于分配一页内存映射到一个数据块。首先检查这个数据块是否已经映射，没被映射再使用<code>syscall_mem_alloc</code>完成映射。<br><code>unmap_block</code>函数用于移除数据块的映射关系。首先检查这个数据块是否被映射了；然后检查这个数据块是否被修改过，如果被修改了则需要把数据写入到磁盘块中；接着使用<code>syscall_mem_unmap</code>移除映射关系。<br><code>read_block</code>函数用于读入数据块的数据到内存中。首先需要判断数据块号合法性和数据块是否被使用；然后取得数据块地址；检查这个数据块是否在内存中，如果不在则需要分配一页映射到数据块，然后调用<code>ide_read</code>读入数据；检查<code>blk</code>是否为NULL，如果不是则把虚拟地址赋值。<br><code>write_block</code>函数用于把内存数据块的信息写入到磁盘中。首先判断数据块是否被映射；取得地址后调用<code>ide_write</code>写磁盘块，最后移除这个映射。<br><code>block_is_free</code>函数用于判断数据块是否被释放。具体来说就是检查位图对应的信息是否为1。<br><code>free_block</code>函数用于释放一个数据块，更新位图。也就是将位图的信息置0。<br><code>alloc_block_num</code>函数用于查找分配一个空闲的数据块。也就是从3号开始，搜索位图检查是否有空闲的数据块，并返回空闲数据块号。<br><code>alloc_block</code>函数用于获得一个空闲数据块并映射到内存中。首先通过<code>alloc_block_num</code>获得一个空闲的磁盘块号，然后将对应的磁盘用<code>map_block</code>映射到内存中。<br><code>read_super</code>用于读取和检验超级块。首先使用<code>read_block</code>将超级块信息读入内存；然后检查魔数；最后检查磁盘大小信息是否吻合。<br><code>read_bitmap</code>用于读取和检查位图。类似的，首先是读入位图，然后检查前两个磁盘块是否在使用，最后检查位图块全部在使用。<br><code>check_write_block</code>用于检查<code>wrtie_block</code>函数功能正常。</p><p>到这里，磁盘块的管理操作就完成了。</p></li></ul><h4 id="2-文件系统"><a href="#2-文件系统" class="headerlink" title="2.文件系统"></a>2.文件系统</h4><p>磁盘管理完成后，就可以在这个基础上完成文件系统的搭建了。</p><p>首先是管理文件的文件控制块<code>File</code>。这个结构体定义在include&#x2F;fs.h中，定义了文件名、文件大小、文件类型、文件数据块索引、文件上级目录，为了保证每个文件控制块大小固定，还设置了<code>f_pad</code>，用填充0的方法，保证了文件控制块大小为256字节。</p><p><img src="https://img-blog.csdnimg.cn/img_convert/755aa2dda57d2a42cc867357012fc24b.png" alt="img"></p><ul><li><p>fs&#x2F;fsformat.c</p><p>这个文件中定义了实验的文件系统的形式。里面定义了初始化磁盘、大端转换为小端、刷新位图等操作。</p><p><code>reverse</code>函数用于将大端存储的数据转换为小端格式。<br><code>reverse_block</code>函数用于将磁盘块的数据格式都转换过来。<br><code>init_disk</code>函数用于初始化磁盘。<br><code>flush_bitmap</code>函数用于刷新位图。<br><code>finish_fs</code>函数用于将设置好的磁盘写入到镜像文件中。<br><code>save_block_link</code>函数用于将被引用的磁盘块存进文件的索引中。<br><code>make_link_block</code>用于建立一个新的数据块引用。<br><code>create_file</code>用于在给定的目录中创建一个新的文件控制块指针。简单来说就是找到一个数据块中的空闲的文件索引，也就是没有存储信息的文件控制块，返回这个地址；如果没有数据块或者没找到空闲索引则使用<code>make_link_block</code>加入一个新的数据块。<br><code>write_file</code>用于在给定的目录下的一个文件写入到磁盘中。</p><p>通过了解这个文件，我们大概了解了文件和磁盘的关系。</p></li><li><p>fs&#x2F;fs.c</p><p>接下来我们就来完成具体的文件和磁盘交互的函数。</p><p><code>fs_init</code>函数完成了文件系统的初始化，也就是检查了超级块等信息是否正常。<br><code>file_block_walk</code>函数用于查找一个文件中某个文件块所在的磁盘块，并返回磁盘块的虚拟地址，这里所指的文件块就是文件控制块中索引的数据块。对于在直接索引中的文件块，直接返回那个块的地址即可；对于间接索引，如果没有间接索引且需要分配一个数据块，则使用<code>alloc_block</code>分配一个数据块，否则就报错，然后用<code>read_block</code>把这个块读入内存中，获得这个块的虚拟地址，加上文件块号的偏移；最后返回磁盘块的虚拟地址。<br><code>file_map_block</code>函数用于设置<code>*diskbno</code>为指定的文件块，也就是用一个。首先通过<code>file_block_walk</code>找到需要的文件块，如果没有且<code>alloc</code>被置位，则需要新建一个索引块，最后将这个块的编号赋给<code>*diskbno</code>。<br><code>file_clear_block</code>函数用于用于把一个文件块从文件中移除。先找到这个块，然后使用<code>free_block</code>释放这个块。<br><code>file_get_block</code>函数用于将文件块的数据读入<code>blk</code>中，也就是将<code>*blk</code>指向这个文件块。首先是用<code>file_map_block</code>找到磁盘块号，接着用<code>read_block</code>将这个块的地址赋给<code>blk</code>。<br><code>file_dirty</code>函数用于标记某个块为dirty。<code>*(volatile char *)blk = *(volatile char *)blk;</code>，这个倒是很神奇的一条语句，我也不知道怎么就能标记为dirty。<br><code>dir_lookup</code>函数用于查找目录下指定文件名的文件。做法也很简单，就是遍历目录文件的所有文件块，通过<code>file_get_block</code>读取数据，再检查这个块内所有文件控制块的文件名是否符合。<br><code>dir_alloc_file</code>函数用于在特定的目录下建立一个新的文件控制块。过程与<code>dir_lookup</code>类似，找到一个空白的文件控制块返回地址即可，而如果没找到，则需要建立新的文件块存放。<br><code>walk_path</code>函数用于给定一个路径，查找这个路径指向的文件。简单来说就是每一级目录查找下一级目录是否存在，直到找到目标文件。<br><code>file_open</code>函数利用<code>walk_path</code>函数实现打开一个给定路径的文件，也就是返回这个文件控制块的地址。<br><code>file_create</code>函数根据给出的路径创建对应的文件。做法就是通过<code>walk_path</code>找到文件地址，然后使用<code>dir_alloc_file</code>建立一个文件控制块，最后把文件名复制到对应的变量。<br><code>file_truncate</code>函数用于把一个文件截断到一个新的大小。做法也很容易，计算出前后两个文件块的数量，然后使用<code>file_clear_block</code>删除文件块即可，最后设置新的文件大小。<br><code>file_set_size</code>函数完成了将一个文件设置为新的大小。对于大于这个大小的文件，使用<code>file_truncate</code>截断文件，然后需要利用<code>file_flush</code>刷新文件所在的目录。<br><code>file_flush</code>函数用于更新磁盘的内容，具体做法就是遍历文件的所有文件块，检查每个文件块是否为dirty，然后写入磁盘。<br><code>fs_sync</code>函数则是刷新整个文件系统所有文件。<br><code>file_close</code>函数则是为关闭文件做准备，也就是将文件和所在目录刷新。<br><code>file_remove</code>函数则是删除一个文件。首先是通过<code>walk_path</code>找到文件，接着通过<code>file_truncate</code>将文件大小减到0，也就是删掉了文件内容，接着把文件名删除，最后更新这个文件和所在的目录。</p><p>到这里，我们已经能够进行查找文件、删除文件、更新文件(或许保存更贴切？)等宏观的操作，完成了文件系统与磁盘的接口。但对于用户来说，具体打开一个文件，对一个文件进行细致的读写操作我们还没有实现。</p></li></ul><h4 id="3-用户接口"><a href="#3-用户接口" class="headerlink" title="3.用户接口"></a>3.用户接口</h4><p>接下来我们需要设计文件系统与用户的交互接口，对于用户来说，对文件的操作无外乎打开、读写、关闭等操作，而并不太关心文件索引块的信息，因此就有了一个新的结构体：文件描述符<code>Fd</code>。但在此之前，先来看另一个结构体<code>Dev</code>。<br><code>Dev</code>结构体定义了一个外设的信息，如外设的编号、外设名、外设的读写等函数指针。在这个操作系统中，对外设的读写在用户层面来看可以认为就是读写一个文件，而每一种外设都有自己的特定读写函数，我猜测这些信息都存放在了设备控制表中。<br>接下来来看文件描述符<code>Fd</code>。这个结构体首先定义了<code>fd_dev_id</code>，这个指的是文件所在的设备编号，与<code>Dev</code>应该是对应的，接着是<code>fd_offset</code>，这个变量存放着文件读写头的位置，也就是当前读写文件的指针相对于文件头的偏移，最后是<code>fd_omode</code>，这个指的是文件打开的类型，比如只读、只写、读写。</p><ul><li><p>在这个文件中定义了一系列与<code>Fd</code>有关的函数。在文件的开头定义了全局变量<code>devtab</code>，也就是这个操作系统中支持的三种设备：文件<code>devfile</code>、终端<code>devcons</code>、管道<code>devpipe</code>。</p><p><code>dev_lookup</code>函数用于根据设备编号查找设备，也就是在<code>devtab</code>中查找设备。<br><code>fd_alloc</code>函数用于分配一个空闲的描述符。具体做法就是找到没有被使用的页面返回其地址。<br><code>fd_close</code>函数用于关闭一个文件描述符。具体做法就是移除所在页面的映射关系。<br><code>fd_lookup</code>函数用于根据一个文件描述符的编号得到对应的文件描述符。先检查编号的合法性，接着通过<code>INDEX2FD</code>获得描述符的地址，检查对应描述符的页表项有效后返回地址即可。<br><code>fd2data</code>函数通过给定的文件描述符返回文件起始数据地址。<br><code>fd2num</code>函数通过给定的描述符返回其编号。<br><code>num2fd</code>函数通过编号得到描述符。<br><code>close</code>函数通过给定的编号关闭对应的描述符。首先是获得文件描述符和设备；接着关闭设备和文件描述符。<br><code>close_all</code>是关闭所有的文件描述符。<br><code>dup</code>函数用于将一个文件复制到一个新的文件中。首先是找到旧的文件描述符，接着关闭新的描述符，获得新的描述符(这个操作到lab6就清楚了)；接着把旧的描述符映射到新的描述符处；最后把相关的页面都映射过去。<br><code>read</code>函数用于从<code>fd_offset</code>处读取n字节到<code>buf</code>中。同样，先找到描述符和设备；接着检查打开模式<code>fd_omode</code>是否有权限；然后调用<code>*dev_read</code>读取内容，更新<code>fd_offset</code>后返回。这个函数不一定最终会读取n字节。<br><code>readn</code>函数与<code>read</code>函数类似，不过这个函数只有在读取n字节后才会结束。具体来说就是不断调用<code>read</code>使得最后读取的字节数达到n。<br><code>write</code>函数与<code>read</code>类似，操作也基本一致，将读换成写即可。<br><code>seek</code>函数用于调整文件的读写头到指定位置，具体来说就是修改<code>fd_offset</code>。</p><p>到这里，我们就能够通过操作文件描述符来进行对文件内容的读写操作了。但是具体到每一个设备，我们还需要补全具体设备的相关函数即<code>*dev_read</code>等才能实现在用户界面对外设的读写。对于文件类的外设，具体的函数定义在了user&#x2F;file.c中。</p></li></ul><p>在具体实现文件类外设的读写时，实际上并不是直接操作<code>File</code>，而是通过文件系统来完成，为了方便与文件系统交互又设计了一种结构体<code>Filefd</code>，简单来说就是结合了<code>Fd</code>和<code>File</code>的结构体。这样即能够获取文件与用户的交互信息<code>Fd</code>，又能够知道文件与磁盘的交互信息<code>File</code>。而更精巧的是，得到<code>Filefd</code>并不困难，可以直接通过结构体的强制转换，从<code>Fd</code>转到<code>Filefd</code>，原因就在于<code>Filefd</code>利用<code>Fd</code>占位，这样就保证了后面的变量<code>f_fileid</code>和<code>f_file</code>访问地址正确。</p><ul><li><p>user&#x2F;file.c</p><p>文件的开头完善了<code>devfile</code>的信息。具体实现在下面。</p><p><code>open</code>函数实现了根据路径和模式打开一个文件。首先需要通过<code>fd_alloc</code>获得一个文件描述符；接着通过<code>fsipc_open</code>请求文件系统打开文件；接下来通过强制转换得到<code>Filefd</code>，设置相关的变量；最后请求文件系统分配内存将文件载入到内存中，返回描述符编号。<br><code>file_close</code>函数则是关闭一个文件。首先是获得<code>Filefd</code>的信息，接着得到文件数据的起始地址；遍历整个文件，请求文件系统处理dirty信息；请求文件系统关闭文件；如果这时的<code>size</code>还不为0，则需要手动通过<code>syscall_mem_unmap</code>移除文件的映射关系。<br><code>file_read</code>函数用于读取n字节信息。首先是得到文件的大小，检查能不能读n字节；如果可以，则使用<code>user_bcopy</code>将文件的信息复制到<code>buf</code>中。<br><code>read_map</code>函数用于找到文件内容所在的文件块。首先找到描述符，判断设备编号是否吻合，接着利用<code>fd2data</code>找到地址，判断这个地址是否有效，最后返回这个地址。<br><code>file_write</code>函数用于向当前读写的位置写入n字节数据。首先是利用<code>ftruncate</code>将文件扩大，接着把内容写到指定的位置。<br><code>ftruncate</code>函数用于截断或增长文件。首先找到文件描述符转成<code>Filefd</code>；接着请求文件系统申请更多的页面来存储信息或者使用系统调用移除多余的映射。<br><code>remove</code>函数用于删除文件或目录。<br><code>sync</code>函数用于更新磁盘。</p><p>到这里我们就完成了对于文件类设备的各种常用操作。但在开头我也提到，这些操作都需要请求文件系统才能完成。因此我们还缺少处理这些请求的函数。这些函数主要在user&#x2F;fsipc.c和fs&#x2F;serv.c中。</p></li></ul><h4 id="4-文件服务"><a href="#4-文件服务" class="headerlink" title="4.文件服务"></a>4.文件服务</h4><p>服务分为两部分，一边是用户程序将各种请求分类，统一成<code>fsipc</code>和请求类型发送给文件系统，一边是文件系统通过传入的请求类型进入相应的处理函数进行处理。</p><ul><li><p>user&#x2F;fsipc.c</p><p>这个文件就定义了一系列发送请求的函数，最终都统一成<code>fsipc</code>函数发送。</p><p><code>fsipc</code>函数就是最终发送请求的函数，通过进程间通信完成，也就是利用<code>ipc_send</code>向文件系统进程发送信息，然后利用<code>ipc_recv</code>返回处理结果。<br>而剩下的函数则大同小异，都是预处理一些信息，然后调用<code>fsipc</code>完成。</p></li><li><p>fs&#x2F;serv.c</p><p>这个文件定义了文件系统处理一系列请求的函数。主体函数是<code>serve</code>函数，这个函数是一个死循环，不断通过<code>ipc_recv</code>接收请求，申请一页临时处理内存，根据请求类型调用对应的处理函数完成处理，最后释放这块内存。</p><p>在文件开头定义了一个结构体<code>Open</code>，这个结构体就是文件系统内部处理文件时描述文件的结构体，包含了文件控制块、文件编号、打开方式、<code>Filefd</code>。从这里我们会发现，对于同一个文件，不同的视角来看，就会有不同的信息，比如底层看到的是文件控制块<code>File</code>，用户看到的是描述符<code>Fd</code>和<code>Filefd</code>，文件服务系统看到的是<code>Open</code>。</p><p><code>serve_init</code>函数用于初始化文件服务进程。<br><code>open_alloc</code>函数用于分配一个<code>Open</code>，也就是找到一个空闲的<code>Open</code>结构体。<br><code>open_lookup</code>函数用于查找一个进程打开的文件。</p><p><code>serve_open</code>函数用于处理打开文件的请求。首先得到文件路径，然后分配一个<code>Open</code>结构体，接着调用<code>file_open</code>打开文件，最后天写相关的信息，再通过<code>ipc_send</code>发回给用户进程即可。<br><code>serve_map</code>函数用于获得一个数据块。首先用<code>open_lookup</code>查找文件的<code>Open</code>结构体，接着计算需要查找的文件块，并通过<code>file_get_block</code>获得，把结果发送给用户。<br>剩下的函数基本是一个写法，通过<code>open_lookup</code>查找文件信息，调用fs.c中的函数完成具体处理，再通过<code>ipc_send</code>返回信息给用户进程。</p></li></ul><p>到这里，用户进程与文件服务系统进程的交互也完成了，现在一个用户进程就能够完成从磁盘读取一个文件、加载到内存中、打开这个文件对文件进行读写操作、并写回磁盘关闭文件的完整操作。文件系统就算是搭建完成了。</p>]]></content>
    
    
    <categories>
      
      <category>OS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>OS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>OS-Lab4</title>
    <link href="/2022/07/17/OS-Lab4/"/>
    <url>/2022/07/17/OS-Lab4/</url>
    
    <content type="html"><![CDATA[<h3 id="一-预备知识"><a href="#一-预备知识" class="headerlink" title="一.预备知识"></a>一.预备知识</h3><p>在前面三个Lab的实验中，我们成功的搭建起了操作系统的内核，建立了内存管理机制和进程调度机制。一般来说，进程是给用户使用的，而用户无法直接对系统内核进行存取。另一方面，进程与进程之间的虚拟地址互相独立，这使得两个进程之间的互相通信变得困难。但是，用户会在有些情况下需要使用只有内核才能进行的操作。为了解决这个问题，操作系统设计了系统调用。</p><p><img src="https://img-blog.csdnimg.cn/img_convert/116723916b3da0dd4df9601f4d69f3e9.png" alt="img"></p><p>指导书上已有的知识，我在此不再赘述。在进行实验之前，我们需要稍微补习一点知识，主要是关于汇编函数方面的东西。这些知识，指导书或者其他地方都有，只不过比较零碎。我稍微聚集了一下这些知识，如果想要了解的更详细，可以深入了解。</p><h4 id="1-汇编函数构造宏-include-x2F-asm-x2F-asm-h"><a href="#1-汇编函数构造宏-include-x2F-asm-x2F-asm-h" class="headerlink" title="1. 汇编函数构造宏(include&#x2F;asm&#x2F;asm.h)"></a>1. 汇编函数构造宏(include&#x2F;asm&#x2F;asm.h)</h4><p>为了方便的像C语言一样构造函数，我们的操作系统事先为我们提供了函数的宏，我们可以直接使用。这个宏的代码并非由本校人员开发，应当是较为通用的定义方式。文件中为我们提供了两种函数的宏，即叶函数（LEAF）和嵌套函数(NESTED)。</p><blockquote><p>我们把函数体中没有函数调用语句的函数称为叶函数，自然如果有函数调用语句的函数称为非叶函数。在MIPS 的调用规范中，进入函数体时会通过对栈指针做减法的方式为自身的局部变量、返回地址、调用函数的参数分配存储空间（叶函数没有后两者），在函数调用结束之后会对栈指针做加法来释放这部分空间，我们把这部分空间称为栈帧（Stack Frame）。</p><p>——OS指导书</p></blockquote><p>下面是宏的具体实现定义。可以看到，函数定义无非是声明一个全局符号，给定一个标签用于跳转和返回。</p><p>下面是文件中部分代码的引用。有些代码后面我没有写注释，是因为我自己也弄不太清楚，不敢乱讲，怕引起误会。如果有同学明白，希望可以给我讲讲。</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm"><span class="hljs-comment">#define LEAF(symbol)                            \</span><br>        .globl  symbol<span class="hljs-comment">;                         \声明&quot;symbol&quot;为全局变量</span><br>        <span class="hljs-meta">.align</span>  <span class="hljs-number">2</span><span class="hljs-comment">;                              \下一个数据的地址空间按字对齐</span><br>        .type   symbol,@function<span class="hljs-comment">;               \</span><br>        .ent    symbol,<span class="hljs-number">0</span><span class="hljs-comment">;                       \告诉汇编器&quot;symbol&quot;函数的起始点，用于调试</span><br><span class="hljs-symbol">        symbol:</span>         .frame  <span class="hljs-built_in">sp</span>,<span class="hljs-number">0</span>,<span class="hljs-built_in">ra</span>          提供一个名为<span class="hljs-string">&quot;symbol&quot;</span>的标签，将跳转到此处<br><br><span class="hljs-comment">#define NESTED(symbol, framesize, rpc)          \</span><br>        .globl  symbol<span class="hljs-comment">;                         \</span><br>        <span class="hljs-meta">.align</span>  <span class="hljs-number">2</span><span class="hljs-comment">;                              \</span><br>        .type   symbol,@function<span class="hljs-comment">;               \</span><br>        .ent    symbol,<span class="hljs-number">0</span><span class="hljs-comment">;                       \</span><br><span class="hljs-symbol">        symbol:</span>         .frame  <span class="hljs-built_in">sp</span>, framesize, rpc   确定栈帧大小以及结束时的返回地址<br><br><span class="hljs-comment">#define END(function)                           \</span><br>        <span class="hljs-meta">.end</span>    function<span class="hljs-comment">;                       \指出函数结尾，用于调试</span><br>        .size   function,.-function              在符号表中列出函数名和函数指令字节数<br></code></pre></td></tr></table></figure><h4 id="2-C函数和汇编函数的参数、返回值传递"><a href="#2-C函数和汇编函数的参数、返回值传递" class="headerlink" title="2.C函数和汇编函数的参数、返回值传递"></a>2.C函数和汇编函数的参数、返回值传递</h4><p>有时候，我们会不可避免的在C语言中调用汇编函数，也会在汇编语言中调用C函数。根据MIPS软件标准(ABI)的定义，函数的参数传递按照如下原则：</p><ul><li>如果函数参数个数≤4，则将参数依次存入a0-a3寄存器中，并在栈帧底部保留16字节的空间（即sp的值减去16），但并不一定使用这些空间。</li><li>如果函数参数个数&gt;4，则前4个参数依次存入a0-a3寄存器中，从第5个参数开始，依次在前4个参数预留空间之外的空间内存储，即没有寄存器去保存这些值。</li><li>举例，如果一个C函数有6个参数，在汇编语言中需要调用的时候，应当将前4个参数存在a0-a3寄存器中，第5个参数存在16(sp)的位置，第6个参数存在20(sp)的位置。区间0-15的空间保留但不使用。</li></ul><p><img src="https://img-blog.csdnimg.cn/img_convert/b77fb78ef5ddbb6e32bd214d6d53c340.png" alt="img"></p><p>而关于函数的返回值，MIPS ABI规定，返回值存在v0寄存器中。某些特殊的情况下也会用到v0寄存器中。某些特殊的情况下也会用到v1寄存器，但不常见。想了解更多关于返回值的知识，请查阅书籍<em>See MIPS Run Linux</em>。</p><h4 id="3-栈帧方法宏-include-x2F-stackframe-h"><a href="#3-栈帧方法宏-include-x2F-stackframe-h" class="headerlink" title="3.栈帧方法宏(include&#x2F;stackframe.h)"></a>3.栈帧方法宏(include&#x2F;stackframe.h)</h4><p>我们在进行用户态和内核态之间的切换，或者进程之间的切换时，需要保存现场。所谓现场，就是include&#x2F;trap.h中所定义的trap结构体，其中包含的信息有：</p><ul><li>32个寄存器的值</li><li>CP0部分寄存器的值</li><li>HI、LO两个乘除法寄存器的值</li><li>程序的指令计数器PC</li></ul><p>但是这个文件中只有结构体的定义，没有将数据存入结构体的操作。将寄存器中的值存入内存，显然要用汇编语言去完成。stackframe.h中定义了一些汇编函数的宏，方便我们对现场进行存取操作。下面摘录了其中的宏，并作出相应的解释。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs assembly">//TF_SIZE是Trapframe寄存器的字节大小<br>.macro STI//Set Interrupt，打开全局中断使能（允许中断）<br>.macro CLI//Close Interrupt，关闭全局中断使能（屏蔽中断）<br>.macro SAVE_ALL             //保存所有现场，将数据以Trapframe结构体形式存在sp为开头的空间中<br>.macro RESTORE_SOME         //恢复部分现场，此处的“部分”仅不包括sp的值<br>.macro RESTORE_ALL          //恢复所有现场，包括栈顶的位置<br>.macro RESTORE_ALL_AND_RET  //恢复现场并从内核态中返回<br>.macro get_sp               //获取栈顶位置，此函数会判断当前的状态是异常还是中断，<br>                            //从而决定栈顶是TIMESTACK还是KERNEL_SP。<br>                            //系统调用是编号为8的异常，进程切换是时钟中断信号。<br></code></pre></td></tr></table></figure><h3 id="二-系统调用"><a href="#二-系统调用" class="headerlink" title="二.系统调用"></a>二.系统调用</h3><h4 id="1-什么是系统调用"><a href="#1-什么是系统调用" class="headerlink" title="1.什么是系统调用"></a>1.什么是系统调用</h4><p>在硬件实现上，用户态的进程无法访问内核的地址空间，这意味着：</p><ul><li>无法存取内核内存数据</li><li>无法调用内核函数</li></ul><p>而所有对硬件的操作都是内核函数，因此用户需要使用系统调用来调用内核的函数。</p><h4 id="2-进入系统调用"><a href="#2-进入系统调用" class="headerlink" title="2.进入系统调用"></a>2.进入系统调用</h4><p>一件事情在脑海中浮现，在MIPS编程中我们是这样进行输入输出——向特定寄存器存放特殊值并调用syscall。而MOS中我们也是这样做的，系统调用的关键就在于用户态和内核态的切换，而这个切换就是在我们调用syscall指令时产生的。</p><p>而就在syscall指令调用后，CPU在硬件层面陷入内核态，其将触发异常分发机制，并最终调用到<code>handle_sys()</code>函数。该函数相当于系统调用的分发，其根据某特定寄存器的值从而找到需要调用的内核函数。</p><blockquote><p>你将见到这几种函数：</p><ul><li><p>syscall_……：用户空间内的函数，与sys_……成对存在</p></li><li><p>msyscall：设置系统调用号并让系统陷入内核态的函数</p></li><li><p>sys_……：内核函数</p><p>有趣的是，在这里我们会发现msyscall需要6个参数，这引起了我们的一个新知识点：大量的参数是如何进行传递的？<br>对于nn个参数的传递，栈帧sp会保留n∗4n∗4个字节的空间，而前4个参数会被放在a0到a3这四个寄存器中，但是栈帧中对应空间还是会被预留，其余参数存储在前四个参数的预留空间之上的区域。</p></li></ul></blockquote><p>注意到一个问题，多于四个的参数会被放到内存中，而这个空间是存在于用户态的，因此我们需要在内核中将这些参数转移到内核空间内，这步工作需要在<code>handle_sys()</code>函数的汇编代码实现了。</p><p>我们先来整理一下在MOS中进行系统调用的流程：</p><ol><li>调用一个封装好的用户空间的库函数（如writef）</li><li>调用用户空间的syscall_* 函数</li><li>调用msyscall，用于陷入内核态</li><li>陷入内核，内核取得信息，执行对应的内核空间的系统调用函数（sys_*）</li><li>执行系统调用，并返回用户态，同时将返回值“传递”回用户态</li><li>从库函数返回，回到用户程序调用处</li></ol><p><strong>msyscall</strong></p><p>msyscall执行的职能只是陷入内核态，并不涉及系统调用的分发。</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm"><span class="hljs-keyword">syscall</span><br><span class="hljs-keyword"></span><span class="hljs-keyword">jr </span><span class="hljs-built_in">ra</span><br><span class="hljs-keyword">nop</span><br></code></pre></td></tr></table></figure><p><strong>handle_sys</strong></p><p>syscall发生后，OS根据中断向量发现是调用了系统调用，从而通过中断分发到<code>handle_sys</code>函数。</p><p><code>handle_sys</code>函数通过分析传入的参数来找到具体的系统调用目标函数，并将传入的参数放到寄存器中，然后进入目标函数。</p><h3 id="三-进程通信-IPC"><a href="#三-进程通信-IPC" class="headerlink" title="三.进程通信 IPC"></a>三.进程通信 IPC</h3><p>进程间通信机制是基于系统调用来实现的。通信的本质就是交换数据，而交换数据的最大问题在于：在进程间，用户地址空间相互独立。</p><p>因此，我们需要通过以内核的2g空间来作为传递信息的媒介，同时我们可以发现，进程控制块是存储在内核空间内的，因此我们完全可以将需要传递的数据放在目标的进程控制块内，然后目标进程在从中读取。</p><p><a href="https://img2020.cnblogs.com/blog/2028226/202105/2028226-20210510193425197-1567369399.png"><img src="https://img-blog.csdnimg.cn/img_convert/4ead8de0f9fcfe0ec44a66ced90d877e.png" alt="image"></a></p><blockquote><p><em>值得一提的是，由于在我们的用户程序中，会大量使用srcva 为0 的调用来表示不需要传递物理页面，因此在编写相关函数时也需要注意此种情况。</em></p></blockquote><p>这两个过程是通过系统调用中的<code>sys_ipc_recv</code>与<code>sys_ipc_can_send</code>来实现。</p><p>前者需要将当前接收者的进程控制块的相应域设置好，并使用<code>sys_yield</code>使得当前进程放弃CPU。</p><p>后者需要检查目标是否准备好接受，并修改目标进程的进程控制块，将需要的信息放到他们的进程控制块内。</p><blockquote><p>需要注意，<em>如果需要传递物理页面信息，需要调用sys_mem_map函数将当前进程srcva对应位置的页面映射到目标进程的dstva处</em>。</p></blockquote><h3 id="四-Fork函数"><a href="#四-Fork函数" class="headerlink" title="四.Fork函数"></a>四.Fork函数</h3><p>fork函数能够从一个进程生成另一个进程，使得子进程拥有和旧进程绝大部分相同的信息。同时，fork会在父子进程中拥有不同的返回值。</p><ul><li>在fork 之前的代码段只有父进程会执行。</li><li>在fork 之后的代码段父子进程都会执行。</li><li>fork 在不同的进程中返回值不一样，在父进程中返回值不为0，在子进程中返回值为0。</li><li>父进程和子进程虽然很多信息相同，但他们的env_id 是不同的。</li></ul><p><a href="https://img2020.cnblogs.com/blog/2028226/202105/2028226-20210510193827711-1922362404.png"><img src="https://img-blog.csdnimg.cn/img_convert/6362b59d3b50d7331309cd0b8f0b5b1e.png" alt="image"></a></p><h5 id="写时复制机制"><a href="#写时复制机制" class="headerlink" title="写时复制机制"></a>写时复制机制</h5><p>父进程会为子进程设置虚拟空间，但是我们通过上图能够发现，实际的分配过程其实是通过duppage复制页表，并设置PTE_COW。COW就是写时复制的意思（Copy On Write）。</p><p>只有当父子进程中有修改内存的举动时，内核会根据PTE_COW捕获中断（一般指缺页中断，Page Fault），并单独为修改内存的进程分配物理页面，然后将该页面复制过去后再实行修改。</p><h5 id="区分父子进程的理论基础"><a href="#区分父子进程的理论基础" class="headerlink" title="区分父子进程的理论基础"></a>区分父子进程的理论基础</h5><p>fork()能够通过返回值来区别当前进程是否是子进程，若返回值为0则为子进程，否则为父进程。</p><p>而实现返回值差异性的函数是<code>syscall_env_alloc</code>函数，其属于用户函数，其触发系统调用后进行<code>sys_env_alloc</code>来创建和初始化一个新进程块。</p><p><strong>sys_env_alloc</strong></p><p>这个函数需要利用当前进程为模板来填写一个新的子进程块。其工作包括复制一份当前的运行现场<strong>、</strong>复制一下当前的PC值<strong>、</strong>修改子进程状态为阻塞、以及初始化其他进程控制块信息。</p><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs xl">int sys_env_alloc(void)<br>&#123;<br>int r;<br>struct Env *e;<br><span class="hljs-function"><span class="hljs-title">r</span> = env_alloc(&amp;e, curenv-&gt;</span>env_id);<br><span class="hljs-keyword">if</span> (r &lt; <span class="hljs-number">0</span>) return r;<br><span class="hljs-function"><span class="hljs-title">e</span>-&gt;</span>env_status = ENV_NOT_RUNNABLE;<br><span class="hljs-function"><span class="hljs-title">e</span>-&gt;</span><span class="hljs-function"><span class="hljs-title">env_pri</span> = curenv-&gt;</span>env_pri;<br><span class="hljs-function"><span class="hljs-title">bcopy</span>((void *)KERNEL_SP - sizeof(struct Trapframe), (void *)&amp;(e-&gt;</span>env_tf), sizeof(struct Trapframe));<br><span class="hljs-function"><span class="hljs-title">e</span>-&gt;</span><span class="hljs-function"><span class="hljs-title">env_tf</span>.pc = e-&gt;</span>env_tf.cp0_epc;<br><span class="hljs-function"><span class="hljs-title">e</span>-&gt;</span>env_tf.regs[<span class="hljs-number">2</span>] = <span class="hljs-number">0</span>;<br><br><span class="hljs-function"><span class="hljs-title">return</span> e-&gt;</span>env_id; <span class="hljs-comment">// 注意这个返回值是返回到父进程的</span><br>&#125;<br></code></pre></td></tr></table></figure><h5 id="在分道扬镳后，父子各自的工作"><a href="#在分道扬镳后，父子各自的工作" class="headerlink" title="在分道扬镳后，父子各自的工作"></a>在分道扬镳后，父子各自的工作</h5><p><strong>子进程</strong></p><p>子进程当前虽然拥有了一个进程控制块，但是仍然存在着几个问题：</p><ul><li>子进程被第一次调度时，其处在fork函数中（准确来说，是syscall_env_alloc返回后），此时函数中的各个变量仍然指向父进程中对应数据结构，子进程如何替换掉这些变量？</li><li>子进程的用户空间没有初始化，如何实现COW的设想？</li></ul><p>我们将在子进程中解决第一个问题，而第二个问题交由父进程解决</p><p><strong>设置进程控制块</strong></p><p>当从<code>syscall_env_alloc</code>返回后，子进程需要将当前函数内的进程控制块指针改为自己的。这一步通过调用<code>syscall_getenvid</code>这一系统调用实现。这一步后，子进程就能够从fork函数退出了（虽然当前处于阻塞状态）。</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs haxe"><span class="hljs-keyword">new</span><span class="hljs-type">envid</span> = syscall_env_alloc();<br><span class="hljs-keyword">if</span>(<span class="hljs-keyword">new</span><span class="hljs-type">envid</span>==<span class="hljs-number">0</span>) &#123;env = envs + ENVX(syscall_getenvid());<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;<br></code></pre></td></tr></table></figure><p><strong>父进程</strong></p><p>父进程需要为子进程进行很多初始化工作，包括遍历进程空间并合理设置空间权限，实现空间共享<strong>、</strong>实现写时复制的缺页中断机制</p><p><strong>进程映射</strong></p><p>通过遍历当前页目录，将页面按以下规则进行设置：</p><ul><li><strong>只读页面</strong> 按照相同权限（只读）映射给子进程即可</li><li><strong>共享页面</strong> 即具有PTE_LIBRARY 标记的页面，这类页面需要保持共享的可写的状态</li><li><strong>写时复制页面</strong> 即具有PTE_COW 标记的页面，这类页面是上一次的fork 的duppage的结果</li><li><strong>可写页面</strong> 需要给父进程和子进程的页表项都加上PTE_COW 标记</li></ul><p>这个功能由<code>duppage</code>函数实现。</p><p><strong>缺页中断</strong></p><p>MIPS下存在两种缺页中断。一种是TLB缺失导致的缺页中断，其会触发trap并分发到<code>handle_tlb</code>下，然后按照正常逻辑进行查表、重填等，此处按下不表。</p><p>另一种是写时复制触发的缺页中断，其会触发trap分发到另一个处理函数<code>handle_mod</code>下。这个函数会跳转到<code>page_fault_handler</code>下，处理当前写时复制异常。</p><p>注意！MOS系统在此处应用了微内核的思想，将处理异常的方式交由用户进程自身，即在进程控制块内定义了一个域<code>env_pgfault_handler</code>用于指定异常处理的函数，使得用户能够自定义处理过程。</p><p>处理写时复制异常的流程为：</p><ol><li><code>page_fault_handler</code>将当前现场保存在异常处理栈中，设置epc的值，以使得中断退出后跳转到指定用户进程指定的异常处理函数中。</li><li>退出中断，此时根据epc地址跳转到指定函数（注意这个函数是fork.c中的<code>pgfault</code>函数，这意味着它是用户态下执行的）中，处理缺页，然后恢复现场和sp寄存器，令进程恢复执行。</li></ol><h3 id="五-实验难点图解"><a href="#五-实验难点图解" class="headerlink" title="五.实验难点图解"></a>五.实验难点图解</h3><h4 id="1-MIPS调用规范（ABI）"><a href="#1-MIPS调用规范（ABI）" class="headerlink" title="1.MIPS调用规范（ABI）"></a>1.MIPS调用规范（ABI）</h4><p>MIPS ABI规定寄存器传参不需要复制到堆栈内<br><img src="https://img-blog.csdnimg.cn/d0adbe28df014c20bd4c8d7a04171beb.png" alt="在这里插入图片描述"></p><h4 id="2-进程间通信机制"><a href="#2-进程间通信机制" class="headerlink" title="2.进程间通信机制"></a>2.进程间通信机制</h4><p>进程间通信机制是基于系统调用来实现的。通信的本质就是交换数据。</p><p>这是通过系统调用中的<code>sys_ipc_recv</code>与<code>sys_ipc_can_send</code>来实现的。</p><p>前者需要将当前接收者的进程控制块的相应域设置好，并使用<code>sys_yield</code>使得当前进程放弃CPU。</p><p>后者需要检查目标是否准备好接受，并修改目标进程的进程控制块，将需要的信息放到他们的进程控制块内。<br><img src="https://img-blog.csdnimg.cn/681ed3bca76340449ab034513b02563a.png" alt="在这里插入图片描述"></p><h4 id="3-缺页中断的处理流程"><a href="#3-缺页中断的处理流程" class="headerlink" title="3.缺页中断的处理流程"></a>3.缺页中断的处理流程</h4><p><img src="https://img-blog.csdnimg.cn/e3bd09c97ec54b94b5e6c380f0fdfc82.png" alt="在这里插入图片描述"></p>]]></content>
    
    
    <categories>
      
      <category>OS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>OS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>OS-Lab3</title>
    <link href="/2022/07/17/OS-Lab3/"/>
    <url>/2022/07/17/OS-Lab3/</url>
    
    <content type="html"><![CDATA[<h3 id="一、进程相关函数"><a href="#一、进程相关函数" class="headerlink" title="一、进程相关函数"></a>一、进程相关函数</h3><p>在做lab3的实验时，发现函数嵌套的情况很多，首先整理这一块的逻辑。</p><p><img src="https://img-blog.csdnimg.cn/img_convert/9f6abdf31070433526fb37a1dbc9fed5.png" alt="img"></p><p>箭头表示函数调用</p><h4 id="1-初始化："><a href="#1-初始化：" class="headerlink" title="1.初始化："></a>1.初始化：</h4><ul><li>申请envs[]的空间；初始化env_free_list（把空闲进程env_status设置为ENV_FREE）</li></ul><h4 id="2-创立进程：设置env-pri"><a href="#2-创立进程：设置env-pri" class="headerlink" title="2.创立进程：设置env_pri"></a>2.创立进程：设置env_pri</h4><ul><li><p>env_alloc（）：</p><ul><li><p>从env_free_list取出一块空闲进程；</p></li><li><p>设置env_id，env_status，env_parent_id，env_tf.cp0_status，env_tf.regs[29]</p></li><li><p>env_setup_vm（）：</p></li><li><ul><li>为进程创建一页页目录，并建立好自映射</li><li>设置env_pgdir，env_cr3</li></ul></li></ul></li><li><p>load_icode（）：</p><ul><li>为进程申请一页作为栈，并建立好映射</li><li>设置env_tf.pc（为load_elf返回的binary的入口）</li><li>load_elf（）&#x2F;load_icode_mapper（）：<ul><li>以一个段（segment）为单位，把binary（进程的内容的二进制镜像）的内容复制到所在内存的虚拟地址</li><li>（load_elf负责找入口，mapper负责copy）</li></ul></li></ul></li></ul><h4 id="3-切换进程"><a href="#3-切换进程" class="headerlink" title="3.切换进程"></a>3.切换进程</h4><ul><li>保存当前进程的上下文，设置env_tf，env_tf.pc</li><li>恢复要启动的进程上下文，并启动新进程，设置env_status，env_pgdir，操作了env_tf，env_id</li></ul><h3 id="二、进程控制块-PCB"><a href="#二、进程控制块-PCB" class="headerlink" title="二、进程控制块(PCB)"></a>二、进程控制块(PCB)</h3><p>进程控制块(PCB) 是系统为了管理进程设置的一个专门的数据结构，用它来记录进程的外部特征，描述进程的运动变化过程。系统利用PCB 来控制和管理进程，所以 PCB 是系统感知进程存在的唯一标志 。</p><p>首先贴出PCB的构成。</p><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs gauss"> <span class="hljs-number">1</span> <span class="hljs-keyword">struct</span> <span class="hljs-type">Env</span> &#123;<br> <span class="hljs-number">2</span> <span class="hljs-comment">/* Trapframe 结构体的定义在include/trap.h 中，</span><br><span class="hljs-comment"> 3  * env_tf 的作用就是在进程因为时间片用光不再运行时，</span><br><span class="hljs-comment"> 4  * 将其当时的进程上下文环境保存在env_tf 变量中。</span><br><span class="hljs-comment"> 5  * 当从用户模式切换到内核模式时，内核也会保存进程上下文，</span><br><span class="hljs-comment"> 6  * 因此进程返回时上下文可以从中恢复。</span><br><span class="hljs-comment"> 7  */</span><br> <span class="hljs-number">8</span> <span class="hljs-keyword">struct</span> <span class="hljs-type">Trapframe</span> env_tf; <span class="hljs-comment">// Saved registers</span><br> <span class="hljs-number">9</span> <br><span class="hljs-number">10</span> <span class="hljs-built_in">LIST_ENTRY</span>(Env) env_link; <span class="hljs-comment">// Free LIST_ENTRY 构造空闲进程链表。</span><br><span class="hljs-number">11</span> <br><span class="hljs-number">12</span> u_int env_id; <span class="hljs-comment">// Unique environment identifier</span><br><span class="hljs-number">13</span> <br><span class="hljs-number">14</span> <span class="hljs-comment">/*该变量存储了创建本进程的进程id。</span><br><span class="hljs-comment">15  *这样进程之间通过父子进程之间的关联可以形成一颗进程树。</span><br><span class="hljs-comment">16  */</span><br><span class="hljs-number">17</span> u_int env_parent_id; <span class="hljs-comment">// env_id of this env&#x27;s parent</span><br><span class="hljs-number">18</span> <span class="hljs-comment">/*env_status : 该变量只能在以下三个值中进行取值：</span><br><span class="hljs-comment">19   – ENV_FREE : 表明该进程是不活动的，即该进程控制块处于进程空闲链表中。</span><br><span class="hljs-comment">20 </span><br><span class="hljs-comment">21   – ENV_NOT_RUNNABLE : 表明该进程处于阻塞状态，处于该状态的进程往往在</span><br><span class="hljs-comment">22     等待一定的条件才可以变为就绪状态从而被CPU 调度。</span><br><span class="hljs-comment">23 </span><br><span class="hljs-comment">24   – ENV_RUNNABLE : 表明该进程处于就绪状态，正在等待被调度，但处于RUNNABLE </span><br><span class="hljs-comment">25     状态的进程可以是正在运行的，也可能不在运行中。*/</span><br><span class="hljs-number">26</span> u_int env_status; <span class="hljs-comment">// Status of the environment</span><br><span class="hljs-number">27</span> <br><span class="hljs-number">28</span> Pde *env_pgdir; <span class="hljs-comment">// Kernel virtual address of page dir 这个变量保存了该进程页目录的虚拟地址。</span><br><span class="hljs-number">29</span> <br><span class="hljs-number">30</span> u_int env_cr3;<span class="hljs-comment">// 这个变量保存了该进程页目录的物理地址。</span><br><span class="hljs-number">31</span> <br><span class="hljs-number">32</span> <span class="hljs-built_in">LIST_ENTRY</span>(Env) env_sched_link;<span class="hljs-comment">//这个变量来构造就绪状态进程链表。</span><br><span class="hljs-number">33</span> <br><span class="hljs-number">34</span> u_int env_pri;<span class="hljs-comment">//这个变量保存了该进程的优先级。</span><br><span class="hljs-number">35</span> <br><span class="hljs-number">36</span> &#125;;<br></code></pre></td></tr></table></figure><h4 id="1-env-tf"><a href="#1-env-tf" class="headerlink" title="1.env_tf"></a>1.env_tf</h4><p>env_tf的类型是struct Trapframe，定义在trap.h中。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"> <span class="hljs-number">1</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">Trapframe</span> &#123; <span class="hljs-comment">//lr:need to be modified(reference to linux pt_regs) TODO</span><br> <span class="hljs-number">2</span>         <span class="hljs-comment">/* Saved main processor registers. */</span><br> <span class="hljs-number">3</span>         <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> regs[<span class="hljs-number">32</span>];<br> <span class="hljs-number">4</span> <br> <span class="hljs-number">5</span>         <span class="hljs-comment">/* Saved special registers. */</span><br> <span class="hljs-number">6</span>         <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> cp0_status;<br> <span class="hljs-number">7</span>         <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> hi;<br> <span class="hljs-number">8</span>         <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> lo;<br> <span class="hljs-number">9</span>         <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> cp0_badvaddr;<br><span class="hljs-number">10</span>         <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> cp0_cause;<br><span class="hljs-number">11</span>         <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> cp0_epc;<br><span class="hljs-number">12</span>         <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> pc;<br><span class="hljs-number">13</span> &#125;;<br></code></pre></td></tr></table></figure><p>①<strong>regs[29]：</strong>通用寄存器中的29号是栈寄存器，在env_alloc（）的时候设置为USTACKTOP（是用户栈，内核栈在0x8040 0000）</p><p><img src="https://img-blog.csdnimg.cn/img_convert/83cc2fb8904288d29efaa67497242d82.png" alt="img"></p><p>我们回忆起在load_icode（）也申请了一页作为栈映射到了USTACKTOP-BY2PG。刚好是regs[29]所在起始位置的下一页。</p><p>所以在env_alloc（）的时候调整了栈指针的位置为USTACKTOP，在env_icode（）时为栈专门申请了一页的空间[USTACKTOP-BY2PG，USTACKTOP]。</p><p>②<strong>pc：程序计数器，用于存放下一条指令的地址</strong></p><p>上面的函数我们一共有两个地方用到了pc。</p><p>第一处在env_alloc（）</p><p>e-&gt;env_tf.pc &#x3D; entry_point;</p><p>即将进程的起始地址移动到了binary的e_entry，可执行程序入口点地址。</p><p>第二处在env_run（）</p><p>curenv-&gt;env_tf.pc &#x3D; curenv-&gt;env_tf.cp0_epc;</p><p>env_tf.cp0_epc存的是下一条指令的地址，则将下一个pc的地址保存了，回复这个进程的时候可以直接跳转到那个位置。</p><p>③<strong>cp0_status</strong></p><p>在env_alloc（）中进行了这样的设置：</p><p>e-&gt;env_tf.cp0_status &#x3D; 0x10001004;</p><p>指导书中提到“MIPSR3000 里的SR(status register) 寄存器就是我们在env_tf里的cp0_ status，R3000 的SR 寄存器的低六位是一个二重栈的结构。”</p><p>二重栈在这个地方应该是指以大小2为单位的栈。所以实际上在中断发生和中断恢复时，会经历这样的倒腾。</p><blockquote><p>KUo 和IEo 是一组，每当中断发生的时候，硬件自动会将KUp 和IEp 的数值拷贝到这里；KUp 和IEp 是一组，当中断发生的时候，硬件会把KUc 和IEc 的数值拷贝到这里。其中KU 表示是否位于内核模式下，为1 表示位于内核模式下；IE 表示中断是否开启，为1 表示开启，否则不开启2。</p><p>而每当rfe 指令调用的时候，就会进行上面操作的逆操作。—《指导书》</p></blockquote><p>我后来发现PPT里有，请跳过这部分。</p><p>这一段没有关于KUo、IEo、KUp、IEp、KUc、IEc的解释，我估计是这样的，画图说明。</p><p><img src="https://img-blog.csdnimg.cn/img_convert/fcdb44a46b5fb9f3c5ff5d8abdd4a978.png" alt="img"></p><blockquote><p>下面这一段代码在运行第一个进程前是一定要执行的，所以就一定会执行rfe这条指令。</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm"><span class="hljs-keyword">lw </span><span class="hljs-built_in">k0</span>,TF_STATUS(<span class="hljs-built_in">k0</span>) <span class="hljs-comment"># 恢复CP0_STATUS 寄存器</span><br><span class="hljs-keyword">mtc0 </span><span class="hljs-built_in">k0</span>,CP0_STATUS<br><span class="hljs-keyword">j </span><span class="hljs-built_in">k1</span><br>rfe<br></code></pre></td></tr></table></figure></blockquote><p>KU：1–内核态，0–用户态；IE：1–开启中断，0–关闭中断。（这里应该是看KUc，IEc）</p><p>rfe会发生类似于中断恢复的操作，往右移动。我们为了设置初始状态为000001b（进入用户态，开启中断），所以我们先设置为000100b，再触发ref指令，使之变成000001b。</p><p>我们之前的设置是e-&gt;env_tf.cp0_status &#x3D; 0x10001004;其中还设置了“第28bit 设置为1，表示处于用户模式下。第12bit 设置为1，表示4 号中断可以被响应。”</p><h4 id="2-lcontext-curenv-gt-env-pgdir"><a href="#2-lcontext-curenv-gt-env-pgdir" class="headerlink" title="2.lcontext(curenv-&gt;env_pgdir)"></a>2.lcontext(curenv-&gt;env_pgdir)</h4><p>curenv-&gt;env_pgdir是页目录的内核虚拟地址<br>lontext 中有一句指令sw a0,mCONTEXT （a0是第一个参数即新进程的内核虚拟地址）</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">LEAF</span><span class="hljs-params">(lcontext)</span></span><br><span class="hljs-selector-class">.extern</span>mCONTEXT<br>swa0,mCONTEXT<br>jrra<br>nop<br><span class="hljs-function"><span class="hljs-title">END</span><span class="hljs-params">(lcontext)</span></span><br></code></pre></td></tr></table></figure><p>在pmap.c中有这样一句mCONTEXT &#x3D; (int)pgdir;是把全新的页目录kva存到mCONTEXT<br>这里就是把curenv的页目录kva存到mCONTEXT,mCONTEXT除了第一次创建页目录的使用,还会在do_refill里使用，这里暂不了解。这里大概是为了开启一个全新的进程时需要创建进程的页目录，需要mCONTEXT。</p><h3 id="三、关键函数理解"><a href="#三、关键函数理解" class="headerlink" title="三、关键函数理解"></a>三、关键函数理解</h3><p>首先第一部分我觉得比较关键的是对于一些非常关键的函数的理解与把握，这些函数是我们本次实验的精华所在，虽然好几个实验都不需要我们自己实现。首先是从第一个我们要填的函数说起吧：</p><h4 id="1-env-init"><a href="#1-env-init" class="headerlink" title="1.env_init"></a>1.env_init</h4><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">void<br>env<span class="hljs-constructor">_init(<span class="hljs-params">void</span>)</span><br>&#123;<br>       <span class="hljs-built_in">int</span> i;<br><br><span class="hljs-comment">/*precondition: envs pointer has been initialized at mips_vm_init, called by mips_init*/</span><br>       <span class="hljs-comment">/*1. initial env_free_list*/</span><br>       <span class="hljs-constructor">LIST_INIT(&amp;<span class="hljs-params">env_free_list</span>)</span>;<br>       <span class="hljs-comment">//step 1;</span><br>       <span class="hljs-comment">/*2. travel the elements in &#x27;envs&#x27;, initial every element(mainly initial its status, mark it as free) and inserts them into</span><br><span class="hljs-comment">       the env_free_list. attention :Insert in reverse order */</span><br>       <span class="hljs-keyword">for</span>(i=NENV-<span class="hljs-number">1</span>;i&gt;=<span class="hljs-number">0</span>;i--)&#123;<br>             envs<span class="hljs-literal">[<span class="hljs-identifier">i</span>]</span>.env_status = ENV_FREE;<br>             <span class="hljs-constructor">LIST_INSERT_HEAD(&amp;<span class="hljs-params">env_free_list</span>,<span class="hljs-params">envs</span>+<span class="hljs-params">i</span>,<span class="hljs-params">env_link</span>)</span>;<br>       &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>　　以上是env_init的实现。就是初始化env_free_list，然后按逆序插入envs[i]。</p><p>　　这里唯一值得并需要引起警惕的是逆序，因为我们使用的是LIST_INSERT_HEAD这个宏，任何一个对齐有所了解的人应该都知道，这个宏每次都会将一个结点插入，变成链表的第一个可用结点，而我们在取用的时候是使用LIST_FIRST宏来取的，所以如果这里写错了的话，可能在调度算法里就要有所更改。</p><p>　　可能会有同学问为什么NENV是envs的长度，这个实际上在pmap.c里面的mips_vm_init里可以找到我们的证据，证明envs数组确实给它分配了NENV个结构体的空间，所以它也就有NENV个元素了。</p><h4 id="2-env-setup-vm"><a href="#2-env-setup-vm" class="headerlink" title="2.env_setup_vm"></a>2.env_setup_vm</h4><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs xl">static int<br>env_setup_vm(struct Env *e)<br>&#123;<br>       <span class="hljs-comment">// Hint:</span><br><br>       int i, r;<br>       struct Page *p = NULL;<br><br>       Pde *pgdir;<br>       <span class="hljs-keyword">if</span> ((r = page_alloc(&amp;p)) &lt; <span class="hljs-number">0</span>)<br>       &#123;<br>               panic(<span class="hljs-string">&quot;env_setup_vm - page_alloc error\n&quot;</span>);<br>                       return r;<br>       &#125;<br>       <span class="hljs-function"><span class="hljs-title">p</span>-&gt;</span>pp_ref++;<br>       <span class="hljs-function"><span class="hljs-title">e</span>-&gt;</span>env_pgdir = (void *)page2kva(p);<br>       <span class="hljs-function"><span class="hljs-title">e</span>-&gt;</span>env_cr3 = page2pa(p);<br><br>       static_assert(UTOP % PDMAP == <span class="hljs-number">0</span>);<br>       <span class="hljs-keyword">for</span> (i = PDX(UTOP); i &lt;= PDX(~<span class="hljs-number">0</span>); i++)<br>         <span class="hljs-function"><span class="hljs-title">e</span>-&gt;</span>env_pgdir[i] = boot_pgdir[i];<br>       <span class="hljs-function"><span class="hljs-title">e</span>-&gt;</span><span class="hljs-function"><span class="hljs-title">env_pgdir</span>[PDX(VPT)]   = e-&gt;</span>env_cr3 ;<br>       <span class="hljs-function"><span class="hljs-title">e</span>-&gt;</span><span class="hljs-function"><span class="hljs-title">env_pgdir</span>[PDX(UVPT)]  = e-&gt;</span>env_cr3 ;<br><br>       return <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>　　其实这个函数并不需要我们实现，但是我还是想讲一讲这个函数的一些有意思的地方。</p><p>　　我们知道，每一个进程都有4G的逻辑地址可以访问，我们所熟知的系统不管是Linux还是Windows系统，都可以支持3G&#x2F;1G模式或者2G&#x2F;2G模式。3G&#x2F;1G模式即满32位的进程地址空间中，用户态占3G，内核态占1G。这些情况在进入内核态的时候叫做陷入内核，因为即使进入了内核态，还处在同一个地址空间中，并不切换CR3寄存器。但是！还有一种模式是4G&#x2F;4G模式，内核单独占有一个4G的地址空间，所有的用户进程独享自己的4G地址空间，这种模式下，在进入内核态的时候，叫做切换到内核，因为需要切换CR3寄存器，所以进入了不同的地址空间！</p><p>　　而我们这次实验，根据.&#x2F;include&#x2F;mmu.h里面的布局来说，我们其实就是2G&#x2F;2G模式，用户态占用2G，内核态占用2G。所以记住，我们在用户进程开启后，访问内核地址不需要切换CR3寄存器！其实这个布局模式也很好地解释了为什么我们需要把boot_pgdir里的内容拷到我们的e-&gt;env_pgdir中，在我们的实验中，对于不同的进程而言，其虚拟地址ULIM以上的地方，映射关系都是一样的！这是因为这2G虚拟地址与物理地址的对应，不是由进程管理的，是由内核管理的。</p><p>　　另外一点有意思的地方不知大家注意到没有，UTOP~ULIM明明是属于User的区域，却还是把内核这部分映射到了User区，而且我们看mmu.h的布局。我们仔细地来分析一下：</p><p>[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-aYxIgE0y-1653797805142)(C:\Users\夏伟\AppData\Roaming\Typora\typora-user-images\image-20220529102258920.png)]</p><p>　　 可以看到UTOP是0x7f40 0000，既然有映射，一定就有分配映射的过程，我们使用grep指令搜索一下 UENVS，发现它在这里有pmap.c里的mips_vm_init有所迹象：</p> <figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">envs = (<span class="hljs-keyword">struct</span> Env*)alloc(NENV*sizeof(<span class="hljs-keyword">struct</span> Env),BY2PG,<span class="hljs-number">1</span>);<br>   boot<span class="hljs-constructor">_map_segment(<span class="hljs-params">pgdir</span>,UENVS,NENV<span class="hljs-operator">*</span><span class="hljs-params">sizeof</span>(<span class="hljs-params">struct</span> Env)</span>,<span class="hljs-constructor">PADDR(<span class="hljs-params">envs</span>)</span>,PTE_R);<br></code></pre></td></tr></table></figure><p>　　可以发现什么呢？其实我们发现，UENVS和envs实际上都映射到了envs对应的物理地址。</p><p>　　其实足以看出来，内核在映射的时候已经为用户留下了一条路径，一条获取其他进程信息的路途。而且我们其实可以知道，这一部分对于进程而言应当是只能读不可以写的。开启中断后我们在进程中再访问内核就会产生异常来陷入内核了，所以应该是为了方便读一些进程信息，内核专门开辟了这4M的用户进程虚拟区。用户读这4M空间的内容是不需要产生异常的。</p><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs xl"><span class="hljs-function"><span class="hljs-title">e</span>-&gt;</span><span class="hljs-function"><span class="hljs-title">env_pgdir</span>[PDX(VPT)]  = e-&gt;</span>env_cr3 ;<br><span class="hljs-function"><span class="hljs-title">e</span>-&gt;</span><span class="hljs-function"><span class="hljs-title">env_pgdir</span>[PDX(UVPT)] = e-&gt;</span>env_cr3 ;<br></code></pre></td></tr></table></figure><h4 id="3-env-alloc"><a href="#3-env-alloc" class="headerlink" title="3.env_alloc"></a>3.env_alloc</h4><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-built_in">int</span><br>env<span class="hljs-constructor">_alloc(<span class="hljs-params">struct</span> Env <span class="hljs-operator">**</span><span class="hljs-params">new</span>, <span class="hljs-params">u_int</span> <span class="hljs-params">parent_id</span>)</span><br>&#123;<br>    <span class="hljs-built_in">int</span> r;<br>    <span class="hljs-keyword">struct</span> Env *e;<br><br>    <span class="hljs-comment">/* Step 1: Get a new Env from env_free_list*/</span><br>e=<span class="hljs-constructor">LIST_FIRST(&amp;<span class="hljs-params">env_free_list</span>)</span>;<br><span class="hljs-keyword">if</span>(e==NULL) return -E_NO_FREE_ENV;<br><br>    <span class="hljs-comment">/* Step 2: Call a certain function (has been completed just now) to init kernel memory layout for this new Env.</span><br><span class="hljs-comment">     *The function mainly maps the kernel address to this new Env address. */</span><br>env<span class="hljs-constructor">_setup_vm(<span class="hljs-params">e</span>)</span>;<br><br>    <span class="hljs-comment">/* Step 3: Initialize every field of new Env with appropriate values.*/</span><br>e-&gt;env_id=mkenvid(e);<br>e-&gt;env_parent_id=parent_id;<br>e-&gt;env_status=ENV_RUNNABLE;<br><br>    <span class="hljs-comment">/* Step 4: Focus on initializing the sp register and cp0_status of env_tf field, located at this new Env. */</span><br>    e-&gt;env_tf.regs<span class="hljs-literal">[<span class="hljs-number">29</span>]</span>=USTACKTOP; <br>    e-&gt;env_tf.cp0_status = <span class="hljs-number">0x10001004</span>;<br><br><br>    <span class="hljs-comment">/* Step 5: Remove the new Env from env_free_list. */</span><br><span class="hljs-constructor">LIST_REMOVE(<span class="hljs-params">e</span>,<span class="hljs-params">env_link</span>)</span>;<br>*<span class="hljs-keyword">new</span>=e;<br>return <span class="hljs-number">0</span>;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>这一部分呢，是单个进程控制块要被分配资源的时候做的一些初始化的工作，其中有几个比较有意思的点很值得深究：</p><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs xl"><span class="hljs-function"><span class="hljs-title">currentE</span>-&gt;</span>env_tf.pc = UTEXT + <span class="hljs-number">0</span>xb0;<br><span class="hljs-function"><span class="hljs-title">currentE</span>-&gt;</span>env_tf.cp0_status = <span class="hljs-number">0</span>x10001004;<br></code></pre></td></tr></table></figure><p>　　第一条可能会有比较大的疑问，为什么进程的二进制码分配到UTEXT对应的地址那里去了，而且也建立好映射关系了，怎么还要加个偏移量作为pc初始值呢？</p><p>　　我们知道pc初始值实际上是进程开始运行的地方，而这里为什么是UTEXT+0xb0，这0xb0是什么东西？我们需要去探究一下code_a.c或者code_b.c文件了，实际上经过一定的了解，这个文件应当是一个elf文件。看其前四个字节就能看出：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">0x7f</span> <span class="hljs-number">0</span>x46 <span class="hljs-number">0</span>x4c <span class="hljs-number">0</span>x46<br></code></pre></td></tr></table></figure><p>　　这是elf的标准头，而实际上像这样的标准头的长度是有0xb0的长度，这个实际上我们可以把code_a.c里的数组搞出来，然后变成一个elf文件，最后使用readelf来读取出地址，这样就能明白原理了。所以UTEXT+0xb0这个虚拟地址对应物理地址里面放着的，才是真正可执行代码的第一条。</p><p>　　再来就是这个0x10001004这个问题，这个问题很好玩。因为R3000自身的SR寄存器与mips其他版本的SR寄存器略有不同，它的最后六位记载了是一组深度为二的二重栈，不过笔者在这里还残留着一些不大不小的问题。《see mips run》中只是提到了关于这些寄存器的作用，而没有提到中断的时候这些寄存器应当是什么状态。如果有兴趣的同学可以grep一下 “CP0_STATUS” 和”cp0_status” 说不定能发现个中玄机。                   </p><h4 id="4-load-icode"><a href="#4-load-icode" class="headerlink" title="4.load_icode"></a>4.load_icode</h4><p>　　这个堪称是本次实验中为数不多的坑函数之一，所以我也就重点讲一下几个要点好了。</p><p>　　首先要解释的就是这个page_insert函数，这个函数看起来平淡无奇，但是如果层层深入，就能发现里面的一些奥妙之处。</p><p>　　我们首先来看page_insert：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-built_in">int</span> page<span class="hljs-constructor">_insert(Pde <span class="hljs-operator">*</span><span class="hljs-params">pgdir</span>, <span class="hljs-params">struct</span> Page <span class="hljs-operator">*</span><span class="hljs-params">pp</span>, <span class="hljs-params">u_long</span> <span class="hljs-params">va</span>, <span class="hljs-params">u_int</span> <span class="hljs-params">perm</span>)</span><br>&#123;<br>u_int PERM;<br>Pte *pgtable_entry;<br>PERM = perm <span class="hljs-pattern-match">| <span class="hljs-constructor">PTE_V</span>;</span><br><span class="hljs-pattern-match"></span><br><span class="hljs-pattern-match"><span class="hljs-operator">/</span><span class="hljs-operator">*</span> <span class="hljs-constructor">Step</span> 1: <span class="hljs-constructor">Get</span> corresponding page table entry. <span class="hljs-operator">*</span><span class="hljs-operator">/</span></span><br><span class="hljs-pattern-match">pgdir<span class="hljs-constructor">_walk(<span class="hljs-params">pgdir</span>, <span class="hljs-params">va</span>, 0, &amp;<span class="hljs-params">pgtable_entry</span>)</span>;</span><br><span class="hljs-pattern-match"></span><br><span class="hljs-pattern-match"><span class="hljs-keyword">if</span> (pgtable<span class="hljs-constructor">_entry</span> != 0 <span class="hljs-operator">&amp;&amp;</span> (<span class="hljs-operator">*</span>pgtable<span class="hljs-constructor">_entry</span> &amp; <span class="hljs-constructor">PTE_V</span>) != 0) &#123;</span><br><span class="hljs-pattern-match"><span class="hljs-keyword">if</span> (pa2page(<span class="hljs-operator">*</span>pgtable<span class="hljs-constructor">_entry</span>) != pp) &#123;</span><br><span class="hljs-pattern-match">page<span class="hljs-constructor">_remove(<span class="hljs-params">pgdir</span>, <span class="hljs-params">va</span>)</span>;</span><br><span class="hljs-pattern-match">&#125; <span class="hljs-keyword">else</span>&#123;</span><br><span class="hljs-pattern-match">tlb<span class="hljs-constructor">_invalidate(<span class="hljs-params">pgdir</span>, <span class="hljs-params">va</span>)</span>;</span><br><span class="hljs-pattern-match"><span class="hljs-operator">*</span>pgtable<span class="hljs-constructor">_entry</span> = (page2pa(pp) | <span class="hljs-constructor">PERM</span>);</span><br><span class="hljs-pattern-match">return 0;</span><br><span class="hljs-pattern-match">&#125;</span><br><span class="hljs-pattern-match">&#125;</span><br><span class="hljs-pattern-match"></span><br><span class="hljs-pattern-match"><span class="hljs-operator">/</span><span class="hljs-operator">*</span> <span class="hljs-constructor">Step</span> 2: <span class="hljs-constructor">Update</span> <span class="hljs-constructor">TLB</span>. <span class="hljs-operator">*</span><span class="hljs-operator">/</span></span><br><span class="hljs-pattern-match"></span><br><span class="hljs-pattern-match"><span class="hljs-operator">/</span><span class="hljs-operator">*</span> hint: use tlb<span class="hljs-constructor">_invalidate</span> <span class="hljs-keyword">function</span> <span class="hljs-operator">*</span><span class="hljs-operator">/</span></span><br><span class="hljs-pattern-match"></span><br><span class="hljs-pattern-match">tlb<span class="hljs-constructor">_invalidate(<span class="hljs-params">pgdir</span>,<span class="hljs-params">va</span>)</span>;</span><br><span class="hljs-pattern-match"><span class="hljs-operator">/</span><span class="hljs-operator">*</span> <span class="hljs-constructor">Step</span> 3: <span class="hljs-constructor">Do</span> check, re-get page table entry <span class="hljs-keyword">to</span> validate the insertion. <span class="hljs-operator">*</span><span class="hljs-operator">/</span></span><br><span class="hljs-pattern-match"></span><br><span class="hljs-pattern-match"><span class="hljs-operator">/</span><span class="hljs-operator">*</span> <span class="hljs-constructor">Step</span> 3.1 <span class="hljs-constructor">Check</span> <span class="hljs-keyword">if</span> the page can be insert, <span class="hljs-keyword">if</span> can’t return -<span class="hljs-constructor">E_NO_MEM</span> <span class="hljs-operator">*</span><span class="hljs-operator">/</span></span><br><span class="hljs-pattern-match"><span class="hljs-keyword">if</span>(pgdir<span class="hljs-constructor">_walk(<span class="hljs-params">pgdir</span>,<span class="hljs-params">va</span>,1,&amp;<span class="hljs-params">pgtable_entry</span>)</span>!=0)</span><br><span class="hljs-pattern-match">&#123;</span><br><span class="hljs-pattern-match">return -<span class="hljs-constructor">E_NO_MEM</span>;</span><br><span class="hljs-pattern-match">&#125;</span><br><span class="hljs-pattern-match"><span class="hljs-operator">/</span><span class="hljs-operator">*</span> <span class="hljs-constructor">Step</span> 3.2 <span class="hljs-constructor">Insert</span> page <span class="hljs-keyword">and</span> increment the pp<span class="hljs-constructor">_ref</span> <span class="hljs-operator">*</span><span class="hljs-operator">/</span></span><br><span class="hljs-pattern-match"><span class="hljs-operator">*</span>pgtable<span class="hljs-constructor">_entry</span>=page2pa(pp)|<span class="hljs-constructor">PERM</span>;</span><br><span class="hljs-pattern-match">pp-&gt;pp<span class="hljs-constructor">_ref</span><span class="hljs-operator">++</span>;</span><br><span class="hljs-pattern-match">return 0;</span><br><span class="hljs-pattern-match">&#125;</span><br></code></pre></td></tr></table></figure><p>　　实际上这个函数是这样一个流程：</p><p>　　先判断va是否有对应的页表项，如果页表项有效。或者叫va是否已经有了映射的物理地址。如果有的话，则去判断这个物理地址是不是我们要插入的那个物理地址，如果不是，那么就把该物理地址移除掉；如果是的话，则修改权限，放到tlb里去。</p><p>　　关于page_inert以下两点一定要注意：</p><ul><li>page_insert处理将同一虚拟地址映射到同一个物理页面上不会将当前已有的物理页面移除掉，但是需要修改掉permission；</li><li>只要对页表有修改，都必须tlb_invalidate一下，否则后面紧接着对内存的访问很有可能出错。这就是为什么有一些同学直接使用了pgdir_walk而没有page_insert产生错误的原因。</li></ul><p>　　既然提到了tlb_invalidate函数，那么我们来仔细分析一下这个函数，这个函数代码如下：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">void<br>tlb<span class="hljs-constructor">_invalidate(Pde <span class="hljs-operator">*</span><span class="hljs-params">pgdir</span>, <span class="hljs-params">u_long</span> <span class="hljs-params">va</span>)</span><br>&#123;<br>        <span class="hljs-keyword">if</span> (curenv)<br>                tlb<span class="hljs-constructor">_out(PTE_ADDR(<span class="hljs-params">va</span>)</span><span class="hljs-pattern-match">|<span class="hljs-constructor">GET_ENV_ASID(<span class="hljs-params">curenv</span>-&gt;<span class="hljs-params">env_id</span>)</span>);</span><br><span class="hljs-pattern-match">        <span class="hljs-keyword">else</span></span><br><span class="hljs-pattern-match">                tlb<span class="hljs-constructor">_out(PTE_ADDR(<span class="hljs-params">va</span>)</span>);</span><br><span class="hljs-pattern-match">&#125;</span><br></code></pre></td></tr></table></figure><p>　　关于为什么要使用GET_ENV_ASID宏，助教老师给的指导书里其实没有讲太清楚，tlb的ASID区域只有20位，而我们mkenvid函数调用后得到的id值是可以超出20位的，大家可以在env_init初始化的时候打印env_id的值，然后在init.c里面create 1024个进程即可看到实际上envid最大可达1ffbfe，而使用GET宏之后最大可达ffc0，而且都可以为tlb用于区分进程，所以肯定是位数越少越好啦。而且还有一个比较有意思的地方，GET宏里实际上是让env_id先 &gt;&gt;11 然后 &lt;&lt;6 达到最后效果的，这样和&gt;&gt;5有什么区别呢？区别就在于 如果先&gt;&gt;11再 &lt;&lt;6，后6位一定是0！（2进制位），所以我猜后六位一定是有其独特用处的，否则在这里也不会强调清零，不过我们这次实验里还没有看到特殊用处。</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs x86asm">LEAF(tlb_out)<br>//<span class="hljs-number">1</span>: j <span class="hljs-number">1b</span><br><span class="hljs-keyword">nop</span><br>mfc0<span class="hljs-built_in">k1</span>,CP0_ENTRYHI<br>mtc0a0,CP0_ENTRYHI<br><span class="hljs-keyword">nop</span><br>// insert tlbp <span class="hljs-keyword">or</span> tlbwi<br>tlbp<br><span class="hljs-keyword">nop</span><br><span class="hljs-keyword">nop</span><br><span class="hljs-keyword">nop</span><br><span class="hljs-keyword">nop</span><br>mfc0<span class="hljs-built_in">k0</span>,CP0_INDEX<br>bltz<span class="hljs-built_in">k0</span>,NOFOUND<br><span class="hljs-keyword">nop</span><br>mtc0<span class="hljs-meta">zero</span>,CP0_ENTRYHI<br>mtc0<span class="hljs-meta">zero</span>,CP0_ENTRYLO0<br><span class="hljs-keyword">nop</span><br>// insert tlbp <span class="hljs-keyword">or</span> tlbwi<br>tlbwi<br><span class="hljs-symbol">NOFOUND:</span><br><br>mtc0<span class="hljs-built_in">k1</span>,CP0_ENTRYHI<br><br>jra<br><span class="hljs-keyword">nop</span><br>END(tlb_out)<br><br></code></pre></td></tr></table></figure><p> 　这段汇编是tlb_invalidate函数的精华所在，CP0_ENTRYHI实际上就是用来给tlb倒腾数据的，不用太在意其本身的作用。</p><p> 　前两句是指把之前的CP0_ENTRYHI存在k1里面暂存一下。然后我们就有一条很关键的汇编指令 tlbp ，很关键。</p><p>　　通过查mips手册可以知道tlbp的功能如下：<br><img src="https://img-blog.csdnimg.cn/05a8460c52bb4747b81352ef5bdc8d98.png" alt="在这里插入图片描述"><br>　　之后的几个nop应该是为tlb指令设置的流水缓冲，因为tlbp执行的周期要比一般指令长。其实这条汇编的目的就是：</p><p>　　To find a matching entry in the TLB.所以说实际上是把va及其对应的物理地址存在tlb里了，而且tlbp应该是依托于CP0_INDEX和CP0_EnrtyHI寄存器的。那么后面的那些读CP0_INDEX实际上是对tlbp执行是否成功的一个判断而已。注意，这里的tlbp就是在内核态下进行的，所以不会产生异常。如果在用户态下修改CP0的寄存器，或者使用tlbp汇编等，那就说明是tlb缺失或page_fault了！</p><p>　　那么再返回我们的page_insert来看看下一句，下一句是建立一个va与pa之间的桥梁，一个页表的建立，pgdir_walk(pgdir, va, 1, &amp;pgtable_entry)，所以说我们其实在最开始load_icode的时候，实际上是建立了不止size大小的页，还需要建立一个能够映射到该页的页表！那么在最后，为页表项的内容设置权限位PTE_R。恩，那么page_insert函数就此结束了。</p><p>　　page_insert函数结束了，不代表我们这个load_icode结束。下一步则是bcopy。</p><p>　　bcopy这个函数本身不坑，坑的是用法。首先对比原文中的这句我们来粗浅地看一下bcopy：</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-built_in">bzero</span>(page2kva(page),BY2PG);<br><span class="hljs-built_in">bcopy</span>((void *)binary,<span class="hljs-built_in">page2kva</span>(page),BY2PG);<br></code></pre></td></tr></table></figure><p>　　我个人以为这里bzero清零比较好，因为不能保证lab2哪里有问题还会影响到这里来。我倾向于一页一页地清除目标页，分配原始页，当然实验证明这样写也是没有任何问题的。那么下面来解释一下为什么这里用的是page2kva(page)，而不是用与UTEXT有关的数值？</p><p>　　首先我们解释过了，UTEXT+0xb0是程序的入口，何谓入口？比如我们现在启动了一个进程，我们如何能从哪里开始，该怎样跑呢？这取决于我们run一个进程前的准备工作，当然这个工作在进程切换时也需要做，其中很重要的一点就是保存pc。这一点很重要，极其重要。如果是第一次run一个进程的时候，我们的pc是务必要被设置为UTEXT+0xb0的，这也是在env_alloc里面所做的工作。之后有一些我们没有关注过的汇编程序就会默默地根据我们设置的pc去找我们的程序入口，默默地执行，遇到中断默默地保存，切换。于是就这样完成了进程的运行与切换大计。</p><p>　　那么我们这里bcopy不能用UTEXT来copy是因为，我们这里还没开始一个进程，没有其页目录来作为基址，所以你现在copy到的地方也只是内核的UTEXT处。我们都知道在env_run时要切换页目录，切换为进程的页目录后，我们就再也找不到这部分copy的东西了（因为env_setup_vm只复制内核页目录ULIM以上的部分）。所以我们要copy到的地方一定是要内核和每个进程均可以访问的，显而易见要copy到ULIM以上的部分。即page2kva(page)这个地方。当然，你可以选择先切换到进程的页目录，然后copy，然后在结束的时候切换回内核的页目录，</p><p>　　再次强调一点，bcopy也好，bzero也好，在我们编写的程序中，只要是作为访问地址来使用的（什么叫作为地址来使用，就是可以取其内容的 *address)，全部都使用的是虚拟地址！　　</p><p>　　如果你还有更多的探索之心的话，我们可以这么来玩一下load_icode，你看我们之前bcopy不能copy到UTEXT的理由也知道了，那何不先切换到进程的页目录，复制完了以后再切换回来呢？事实上这种做法理论上是完全正确的，但是我在我们的实验里试验过发现不对！后来发现即使切换了页目录，也可以照常访问内核区的地址，完全没有问题！为什么？后来我才猛然想到，我们这次实验的lcontext切换页目录，完全是为tlb中断和page_fault服务的，所以指望lcontext来自动帮我们找到物理地址并且往里添加内容的话，是不可以的。</p><p>　　最后呢，实际上就是建个进程里的用户栈而已，这里区别开用户栈 和内存栈的区别。</p><p>　　多个进程运行时，实际上在内存中有一个栈型结构来存放进程的代码，数据，常量等，而在用户栈里放的则是运行过程中所定义的变量等，这点需要正确把握。当然最后要设置权限，PTE_R，这是写的权限，要设置给用户栈，否则后面进程没有办法写自己的栈了 。　　</p><h4 id="5-env-create"><a href="#5-env-create" class="headerlink" title="5.env_create"></a>5.env_create</h4><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">void<br>env<span class="hljs-constructor">_create(<span class="hljs-params">u_char</span> <span class="hljs-operator">*</span><span class="hljs-params">binary</span>, <span class="hljs-params">int</span> <span class="hljs-params">size</span>)</span><br>&#123;<br>     <span class="hljs-comment">/* Step 1: Use env_create_priority to alloc a new env with priority 1 */</span><br>env<span class="hljs-constructor">_create_priority(<span class="hljs-params">binary</span>,<span class="hljs-params">size</span>,1)</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>实际上这里env_create就很简单了，就是alloc一个进程控制块，然后加载其代码。</p><h4 id="6-env-run"><a href="#6-env-run" class="headerlink" title="6.env_run"></a>6.env_run</h4><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs xl">void<br>env_run(struct Env *e)<br>&#123;<br>struct Trapframe *old;<br>old=(struct Trapframe *)(TIMESTACK-sizeof(struct Trapframe));<br>    <span class="hljs-comment">/* Step 1: save register state of curenv. */</span><br>    <span class="hljs-comment">/* Hint: if there is an environment running, </span><br><span class="hljs-comment">     *   you should switch the context and save the registers. </span><br><span class="hljs-comment">     *   You can imitate env_destroy() &#x27;s behaviors.*/</span><br>     <span class="hljs-keyword">if</span>(curenv!=NULL)<br>&#123;<br><span class="hljs-function"><span class="hljs-title">curenv</span>-&gt;</span>env_tf=*old;<br><span class="hljs-function"><span class="hljs-title">curenv</span>-&gt;</span><span class="hljs-function"><span class="hljs-title">env_tf</span>.pc=old-&gt;</span>cp0_epc;<br>&#125;<br><br>    <span class="hljs-comment">/* Step 2: Set &#x27;curenv&#x27; to the new environment. */</span><br>curenv=e;<br><span class="hljs-function"><span class="hljs-title">curenv</span>-&gt;</span>env_status=ENV_RUNNABLE;<br><br>    <span class="hljs-comment">/* Step 3: Use lcontext() to switch to its address space. */</span><br><span class="hljs-function"><span class="hljs-title">lcontext</span>(curenv-&gt;</span>env_pgdir);<br><br>    <span class="hljs-comment">/* Step 4: Use env_pop_tf() to restore the environment&#x27;s</span><br><span class="hljs-comment">     *   environment   registers and return to user mode.</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * Hint: You should use GET_ENV_ASID there. Think why?</span><br><span class="hljs-comment">     *   (read &lt;see mips run linux&gt;, page 135-144)</span><br><span class="hljs-comment">     */</span><br><span class="hljs-function"><span class="hljs-title">env_pop_tf</span>(&amp;curenv-&gt;</span><span class="hljs-function"><span class="hljs-title">env_tf</span>,GET_ENV_ASID(curenv-&gt;</span>env_id));<br>&#125;<br></code></pre></td></tr></table></figure><p>   刚刚说到的load_icode是为数不多的坑函数之一，env_run也是，而且其实按程度来讲可能更甚一筹。</p><p>　　那我们来一步一步分析一下这个函数的坑处。</p><p>　　首先是要理解进程切换，需要做些什么？实际上进程切换的时候，为了保证下一次进入这个进程的时候我们不会再“从头来过”，我们要保存一些信息，那么，需要保存什么信息呢？保存的应该是以下几方面：</p><p>　　[1]进程本身的状态</p><p>　　[2]进程周围的环境的状态，环境就是指此时的CPU的状态</p><p>　　那么我们可能会产生疑问，进程本身的状态怎么记录呢？</p><p>　　进程本身的状态无非就是进程块里面那几个东西，包括id,parent_id,pc,tf…</p><p>　    Trapframe里面有 cp0_badvaddr,cp0_cause,cp0_epc,regs[32]…</p><p>　　这些东西不是进程自己的。这些都是CPU的状态。所以说实际上一个进程控制块中的tf，就是来记录它的环境的状态的。进程本身的状态在进程切换的时候是不会变的。会变的也是需要我们保存的实际上是进程的环境信息。</p><p>　　谨记这一点，或许你就能开始明白run代码中的第一句:</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">1 </span> <span class="hljs-keyword">if</span>(curenv)&#123;<br><span class="hljs-symbol">2 </span>              tf = TIMESTACK - sizeof(struct Trapframe);<br><span class="hljs-symbol">3 </span>              bcopy(tf,&amp;curenv-&gt;env_tf,sizeof(struct Trapframe));<br><span class="hljs-symbol">4 </span>              curenv-&gt;env_tf.pc = tf-&gt;cp0_epc;<br><span class="hljs-symbol">5 </span>        &#125;<br></code></pre></td></tr></table></figure><p>　　很多同学在这里可能遇到了他们在lab3中的最大困惑：</p><p>　　　　为什么这里不能从KERNEL_SP取东西，而是非要从TIMESTACK取。KERNEL_SP是用来干啥的？</p><p>　　为了搞清楚这一点，我们需要知道：什么时候我们把东西往TIMESTACK放，又是什么时候取出来的？</p><p>　　笔者在 .&#x2F;include&#x2F;stackframe.h 找到了一点端倪：</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm"> <span class="hljs-number">1</span> <span class="hljs-meta">.macro</span> get_sp<br> <span class="hljs-number">2</span>         <span class="hljs-keyword">mfc0 </span>   <span class="hljs-built_in">k1</span>, CP0_CAUSE<br> <span class="hljs-number">3</span>         <span class="hljs-keyword">andi </span>   <span class="hljs-built_in">k1</span>, <span class="hljs-number">0x107C</span><br> <span class="hljs-number">4</span>         <span class="hljs-keyword">xori </span>   <span class="hljs-built_in">k1</span>, <span class="hljs-number">0x1000</span><br> <span class="hljs-number">5</span>         <span class="hljs-keyword">bnez </span>   <span class="hljs-built_in">k1</span>, <span class="hljs-number">1</span>f<br> <span class="hljs-number">6</span>         <span class="hljs-keyword">nop</span><br><span class="hljs-keyword"></span> <span class="hljs-number">7</span>         li      <span class="hljs-built_in">sp</span>, <span class="hljs-number">0x82000000</span><br> <span class="hljs-number">8</span>         <span class="hljs-keyword">j </span>      <span class="hljs-number">2</span>f<br> <span class="hljs-number">9</span>         <span class="hljs-keyword">nop</span><br><span class="hljs-keyword"></span><span class="hljs-number">10</span> <span class="hljs-number">1</span>:<br><span class="hljs-number">11</span>         <span class="hljs-keyword">bltz </span>   <span class="hljs-built_in">sp</span>, <span class="hljs-number">2</span>f<br><span class="hljs-number">12</span>         <span class="hljs-keyword">nop</span><br><span class="hljs-keyword"></span><span class="hljs-number">13</span>         <span class="hljs-keyword">lw </span>     <span class="hljs-built_in">sp</span>, KERNEL_SP<br><span class="hljs-number">14</span>         <span class="hljs-keyword">nop</span><br><span class="hljs-keyword"></span><span class="hljs-number">15</span> <br><span class="hljs-number">16</span> <span class="hljs-number">2</span>:      <span class="hljs-keyword">nop</span><br><span class="hljs-keyword"></span><span class="hljs-number">17</span> <br><span class="hljs-number">18</span> <span class="hljs-meta">.endm</span><br></code></pre></td></tr></table></figure><p>　　实际上我们的TIMSTACK就是0x82000000，因为我们本次都是时钟中断，所以sp是TIMSTACK区。</p><p>　　而我们再仔细地观察这个头文件，发现其实里面的宏汇编 RESTORE_SOME 和env_pop_tf 几乎一模一样。TIMESTACK是时钟中断后的存储区，而KERNEL_SP应当是系统调用后的存储区。我们可以把run里面的TIMSTACK改成 KERNEL_SP试试，发现其实KERNEL_SP在第一个进程执行完之后就没更新过，这是显而易见的，因为我们第一个进程启动后，就再也没有给过内核进程控制权啊！不过我们的猜想估计要到后面的实验才能认证。</p><p>　  那么实际上我们在往某个寄存器比如$1里放东西的时候，应该是放到了sp为起始虚拟地址对应的物理地址处，那么就是</p><ul><li>　　env_pop_tf 负责放东西到sp(这里是TIMESTACK)中去；</li><li>　　而这开头的一段负责从sp里取出东西来(这里是TIMSTACK)。</li></ul><p>　　所以我们一开始没有正在运行的进程块的时候，是不需要取的，但是一旦一个进程块运行到末尾的话，就会向TIMSTACK中存入东西。</p><p>　　比如我们进程1开始运行，运行到env_run的末尾，我们把当时的环境保存了下来。运行一段时间后，时钟中断导致切换，发现要到进程2了，在切换之前，我们把进程1的离开时的状态保存在其tf内，离开的状态其实就在TIMESTACK中。因为我理解的这个TIMESTACK就是当前访问CPU的寄存器所用虚拟地址，所以其所对应的值就是CPU的各个寄存器的值，所以就会在进程运行时改变，所以要更新。</p><p>　　注意还有一个小坑的地方在于 如果要env_pop_tf的时候，千万记得要先lcontext切换了页目录，否则是会出错的。env_pop_tf 的字面意思估计大家也明白了，就是把env里的tf 压到 寄存器里去。　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　</p><h3 id="四、实验难点图示"><a href="#四、实验难点图示" class="headerlink" title="四、实验难点图示"></a>四、实验难点图示</h3><h4 id="1-加载二进制镜像"><a href="#1-加载二进制镜像" class="headerlink" title="1.加载二进制镜像"></a>1.加载二进制镜像</h4><p>这一部分的内容较多且难度较大，由三个函数共同完成，即：</p><ul><li>env.c中的<code>load_icode</code></li><li>kernal_elfloader.c中的<code>load_elf</code></li><li>env.c中的<code>load_icode_mapper</code></li></ul><p>其中<code>load_icode</code>为实现这个功能的代码，它的功能在于：</p><ol><li>分配内存</li><li>将二进制代码装入分配好的内存中</li></ol><p>其中，第二步，即装入内存的操作交给了函数<code>load_elf</code>来完成，而<code>load_elf</code>的工作又被分为：</p><ol><li>解析<code>ELF</code>结构</li><li>将<code>ELF</code>的内容复制到内存中</li></ol><p>其中，第二步，即将内容复制到内存中的操作又交给了<code>load_icode_mapper</code>函数去进行，所以三段代码的协作方式如下图：<br><img src="https://img-blog.csdnimg.cn/460c00d903ef4eeeab68eb0b58856b7e.png#pic_center" alt="在这里插入图片描述"><br>在函数<code>load_elf</code>中，我们不难发现，我们在<code>load_icode_mapper</code>中用到的许多参量在这里都有了很明确的实例对应，具体映射如下：<br><img src="https://img-blog.csdnimg.cn/b669a709f75843dba015820f2468f188.png#pic_center" alt="在这里插入图片描述"></p><p>因此我们只要将给定的ELF文件进行正确解析，就能利用<code>load_icode_mapper</code>对其进行内容复制</p><p>函数<code>load_icode</code>重点在于设置<code>PC</code>值，即从<code>load_elf</code>中返回的<code>entry_point</code></p><h4 id="2-env-setup-vm函数的填写，初始化新进程地址空间"><a href="#2-env-setup-vm函数的填写，初始化新进程地址空间" class="headerlink" title="2.env_setup_vm函数的填写，初始化新进程地址空间"></a>2.<code>env_setup_vm</code>函数的填写，初始化新进程地址空间</h4><p>在这个函数中，内存空间被分成了如下的两个部分，即<code>UTOP</code>以上和<code>UTOP</code>以下，在<code>UTOP</code>以下的部分，我们需要将页目录的这一块区域清零，而在<code>UTOP</code>以上的部分，用户不能操作，属于内核态，因此我们可以将<code>boot_pgdir</code>的内容直接复制到进程的页目录中。</p><p>在<code>UTOP</code>之上有一块被称为<code>UVPT</code>的地址，这一块区域作为用户进程页目录，需要用自映射机制进行单独处理。<br>地址空间的结构图如下：<br><img src="https://img-blog.csdnimg.cn/b00a9539795f449c9a8ac6d1d733e146.png#pic_center" alt="在这里插入图片描述"></p><h4 id="3-sched-yield-进程切换的调度算法"><a href="#3-sched-yield-进程切换的调度算法" class="headerlink" title="3.sched_yield() 进程切换的调度算法"></a>3.sched_yield() 进程切换的调度算法</h4><p>进程的调度也是基于这个时间片来进行，主要的步骤为如下几步：</p><ol><li>设置两个队列，其中一个为目前的进程调度队列<code>q0</code>，另一个为一个空队列<code>q1</code>。</li><li>首先判断当前队列指针指向的队首进程的<code>env_status</code><ul><li>如果为<code>ENV_FREE</code>，则要将该进程从队列中移除</li><li>如果为<code>ENV_NOT_RUNNABLE</code>，则直接将其插入另一个队列的尾部</li><li>如果为<code>ENV_RUNNABLE</code>，则判断这个进程的时间片是否用完，若用完则复原其时间片并将其插入到另一个队列尾部</li><li>当一个队列为空时，将指针转移到另一个队列队首<br><img src="https://img-blog.csdnimg.cn/49f861a6d63047a0a906b3b617325ca9.png#pic_center" alt="在这里插入图片描述"></li></ul></li></ol>]]></content>
    
    
    <categories>
      
      <category>OS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>OS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>OS-Lab2</title>
    <link href="/2022/07/17/OS-Lab2/"/>
    <url>/2022/07/17/OS-Lab2/</url>
    
    <content type="html"><![CDATA[<h4 id="一-TLB访存机制"><a href="#一-TLB访存机制" class="headerlink" title="一.TLB访存机制"></a>一.TLB访存机制</h4><p>当一个虚拟地址被送到MMU中进行翻译的时候，硬件首先在TLB中寻找包含这个地址的页面，如果它的虚页号在TLB中，并且没有违反保护位，那么就可以直接从TLB中得到相应的物理页号，而不去访问页表；如果发现虚页号在TLB中不存在，那么MMU将进行常规的页表查找，同时通过一定的策略来将这一页的页表项替换到TLB中，之后再次访问这一页的时候就可以直接在TLB中找到。</p><p>拿到了物理地址后，可以直接访问内存拿数据，不过会慢，所以，Cache就是部分物理地址到数据的映射。是内存的一部分copy。<br><img src="https://img-blog.csdnimg.cn/fa249c54c01849e5a595009ceb03cd18.jpeg#pic_center" alt="在这里插入图片描述"></p><h4 id="二-二级页表"><a href="#二-二级页表" class="headerlink" title="二.二级页表"></a>二.二级页表</h4><p>首先，c语言可以操作任何空间的地址，这个就是虚拟地址。</p><p>我们要做的就是模拟二级页表机制，往虚拟地址里面填写物理地址，再通过f(va)−&gt;pa和f(pa)→va转换取到地址里面的东西。</p><p>简单来说，把放着很多很多页的虚拟地址，按照虚拟地址的索引，把它对应的物理地址放到另一个虚拟地址pgidr里。</p><p>这样就“假装”建立起了二级页表，物理地址从未使用过，要访问时永远要加上ULIM。</p><p><code>Page</code>结构体其实是物理地址的一个“象征”。因为它减去pages拿到ppn以后，shift12位再加上ULIM，就是虚拟地址，减去ULM又变回物理地址。建立起来虚拟页和物理页之间的桥梁。尽管自己不是真正的4KB页，但是是桥梁。</p><h4 id="三-Page存储结构"><a href="#三-Page存储结构" class="headerlink" title="三.Page存储结构"></a>三.Page存储结构</h4><p><img src="https://img-blog.csdnimg.cn/6789262634cc4ac3b67edfab1d3ab7f5.jpeg#pic_center" alt="在这里插入图片描述"></p><h4 id="四-自映射机制图示"><a href="#四-自映射机制图示" class="headerlink" title="四.自映射机制图示"></a>四.自映射机制图示</h4><p><img src="https://img-blog.csdnimg.cn/82fdc306b4ae46bbaded906cc289a783.jpeg#pic_center" alt="在这里插入图片描述"></p><h4 id="五-页面与地址的转化"><a href="#五-页面与地址的转化" class="headerlink" title="五.页面与地址的转化"></a>五.页面与地址的转化</h4><p> 在本次实验中涉及到许多的页面与地址的转化，其中用到许多已经定义的函数，现整理如下：</p><p> <strong>page2pa：得到某个page结构体的物理地址</strong></p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-comment">/* Get the physical address of Page &#x27;pp&#x27;.</span><br><span class="hljs-comment"> */</span><br>static inline u_long<br><span class="hljs-built_in">page2pa</span>(struct Page *pp)<br>&#123;<br>return <span class="hljs-built_in">page2ppn</span>(pp) &lt;&lt; PGSHIFT;<br>&#125;<br></code></pre></td></tr></table></figure><p> <strong>pa2page：得到某个物理地址所对应的Page结构体</strong></p><figure class="highlight sas"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs sas"><span class="hljs-comment">/* Get the Page struct whose physical address is &#x27;pa&#x27;.</span><br><span class="hljs-comment"> */</span><br>static inline struct <span class="hljs-keyword">Page</span> <span class="hljs-comment">*</span><br><span class="hljs-comment">pa2page(u_long pa)</span><br><span class="hljs-comment">&#123;</span><br><span class="hljs-comment">if (PPN(pa) &gt;= npage) &#123;</span><br><span class="hljs-comment">panic(&quot;pa2page called with invalid pa: %x&quot;, pa);</span><br>&#125;<br><br><span class="hljs-keyword">return</span> <span class="hljs-variable">&amp;pages</span>[PP<span class="hljs-meta">N</span>(pa)];<br>&#125;<br></code></pre></td></tr></table></figure><p> <strong>page2kva：得到某个Page结构体的内核虚拟地址</strong></p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-comment">/* Get the kernel virtual address of Page &#x27;pp&#x27;.</span><br><span class="hljs-comment"> */</span><br>static inline u_long<br><span class="hljs-built_in">page2kva</span>(struct Page *pp)<br>&#123;<br>return <span class="hljs-built_in">KADDR</span>(page2pa(pp));<br>&#125;<br></code></pre></td></tr></table></figure><p> <strong>PPN：得到某个虚拟地址的页号</strong></p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs lisp">#define PPN(<span class="hljs-name">va</span>)(((<span class="hljs-name">u_long</span>)(<span class="hljs-name">va</span>))&gt;&gt;12)<br></code></pre></td></tr></table></figure><p> <strong>PADDR：将某个内核虚拟地址转化为物理地址</strong></p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-comment">// translates from kernel virtual address to physical address.</span><br><span class="hljs-selector-id">#define</span> <span class="hljs-built_in">PADDR</span>(kva)\<br>(&#123;\<br>u_long a = (u_long) (kva);\<br>if (a &lt; ULIM)\<br><span class="hljs-built_in">panic</span>(&quot;PADDR called with invalid kva %<span class="hljs-number">08</span>lx&quot;, a);\<br><span class="hljs-selector-tag">a</span> - ULIM;\<br>&#125;)<br></code></pre></td></tr></table></figure><p> <strong>KADDR：将某个物理地址转化为内核虚拟地址</strong></p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-comment">// translates from physical address to kernel virtual address.</span><br><span class="hljs-selector-id">#define</span> <span class="hljs-built_in">KADDR</span>(pa)\<br>(&#123;\<br>u_long ppn = PPN(pa);\<br>if (ppn &gt;= npage)\<br><span class="hljs-built_in">panic</span>(&quot;KADDR called with invalid pa %<span class="hljs-number">08</span>lx&quot;, (u_long)pa);\<br>(pa) + ULIM;\<br>&#125;)<br></code></pre></td></tr></table></figure><p> 本次实验的前半部分涉及了许多对这类函数的应用，熟练掌握这类函数实现各类地址查询是本次实验的一大难点。</p><h4 id="六-部分实验代码详解"><a href="#六-部分实验代码详解" class="headerlink" title="六.部分实验代码详解"></a>六.部分实验代码详解</h4><p>部分代码含义解释如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs cpp"> <span class="hljs-number">1</span> <span class="hljs-meta">#<span class="hljs-keyword">define</span> BY2PG        4096             <span class="hljs-comment">// 页面大小的Byte数，一个页面大小为4kb</span></span><br> <span class="hljs-number">2</span> <span class="hljs-meta">#<span class="hljs-keyword">define</span> PDMAP        (4*1024*1024)    <span class="hljs-comment">// 一个页表管理1024个页面，大小总共4*1024*1024Byte</span></span><br> <span class="hljs-number">3</span> <span class="hljs-meta">#<span class="hljs-keyword">define</span> PGSHIFT        12             <span class="hljs-comment">// 页面的偏移位数，4kb对应12位</span></span><br> <span class="hljs-number">4</span> <span class="hljs-meta">#<span class="hljs-keyword">define</span> PDSHIFT        22        <span class="hljs-comment">// 页表的偏移位数，同上，即log2(PDMAP)</span></span><br> <span class="hljs-number">5</span> <span class="hljs-meta">#<span class="hljs-keyword">define</span> PDX(va)        ((((u_long)(va))&gt;&gt;22) &amp; 0x03FF) <span class="hljs-comment">// 取虚拟地址高10位，为页目录号</span></span><br> <span class="hljs-number">6</span> <span class="hljs-meta">#<span class="hljs-keyword">define</span> PTX(va)        ((((u_long)(va))&gt;&gt;12) &amp; 0x03FF) <span class="hljs-comment">// 取虚拟地址高11~20位，为页表号</span></span><br> <span class="hljs-number">7</span> <span class="hljs-meta">#<span class="hljs-keyword">define</span> PTE_ADDR(pte)    ((u_long)(pte)&amp;~0xFFF) <span class="hljs-comment">// 页表项取低12位，为页内偏移</span></span><br> <span class="hljs-number">8</span> <br> <span class="hljs-number">9</span> <span class="hljs-comment">// page number field of address</span><br><span class="hljs-number">10</span> <span class="hljs-meta">#<span class="hljs-keyword">define</span> PPN(va)        (((u_long)(va))&gt;&gt;12) <span class="hljs-comment">// 物理页号，为虚拟地址偏移12位</span></span><br><span class="hljs-number">11</span> <span class="hljs-meta">#<span class="hljs-keyword">define</span> VPN(va)        PPN(va) <span class="hljs-comment">// 虚页号</span></span><br><span class="hljs-number">12</span> <br><span class="hljs-number">13</span> <span class="hljs-meta">#<span class="hljs-keyword">define</span> VA2PFN(va)        (((u_long)(va)) &amp; 0xFFFFF000 )</span><br><span class="hljs-number">14</span> <span class="hljs-meta">#<span class="hljs-keyword">define</span> PTE2PT        1024</span><br><span class="hljs-number">15</span> <span class="hljs-comment">//$#define VA2PDE(va)        (((u_long)(va)) &amp; 0xFFC00000 )</span><br><span class="hljs-number">16</span> <br><span class="hljs-number">17</span> <span class="hljs-comment">/* Page Table/Directory Entry flags</span><br><span class="hljs-comment">18  *   these are defined by the hardware</span><br><span class="hljs-comment">19  */</span><br><span class="hljs-number">20</span> <span class="hljs-meta">#<span class="hljs-keyword">define</span> PTE_G        0x0100    <span class="hljs-comment">// 全局位</span></span><br><span class="hljs-number">21</span> <span class="hljs-meta">#<span class="hljs-keyword">define</span> PTE_V        0x0200    <span class="hljs-comment">// 有效位</span></span><br><span class="hljs-number">22</span> <span class="hljs-meta">#<span class="hljs-keyword">define</span> PTE_R        0x0400    <span class="hljs-comment">// 修改位，如果是0表示只对该页面进行过读操作，否则进行过写操作，要引发中断将内容写回内存</span></span><br><span class="hljs-number">23</span> <span class="hljs-meta">#<span class="hljs-keyword">define</span> PTE_D        0x0002    <span class="hljs-comment">// 文件缓存的修改位dirty</span></span><br><span class="hljs-number">24</span> <span class="hljs-meta">#<span class="hljs-keyword">define</span> PTE_COW        0x0001    <span class="hljs-comment">// 写时复制copy on write</span></span><br><span class="hljs-number">25</span> <span class="hljs-meta">#<span class="hljs-keyword">define</span> PTE_UC        0x0800    <span class="hljs-comment">// 未缓存uncached</span></span><br><span class="hljs-number">26</span> <span class="hljs-meta">#<span class="hljs-keyword">define</span> PTE_LIBRARY        0x0004    <span class="hljs-comment">// 共享内存</span></span><br></code></pre></td></tr></table></figure><p>其余的一些定义（异常码的解释略去）：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"> <span class="hljs-number">1</span> <span class="hljs-meta">#<span class="hljs-keyword">define</span> KERNBASE 0x80010000 <span class="hljs-comment">// 内核基地址</span></span><br> <span class="hljs-number">2</span> <br> <span class="hljs-number">3</span> <span class="hljs-meta">#<span class="hljs-keyword">define</span> VPT (ULIM + PDMAP ) <span class="hljs-comment">//</span></span><br> <span class="hljs-number">4</span> <span class="hljs-meta">#<span class="hljs-keyword">define</span> KSTACKTOP (VPT-0x100) <span class="hljs-comment">// 内核栈顶</span></span><br> <span class="hljs-number">5</span> <span class="hljs-meta">#<span class="hljs-keyword">define</span> KSTKSIZE (8*BY2PG) <span class="hljs-comment">// 内核栈大小</span></span><br> <span class="hljs-number">6</span> <span class="hljs-meta">#<span class="hljs-keyword">define</span> ULIM 0x80000000 <span class="hljs-comment">// 用户态地址上限</span></span><br> <span class="hljs-number">7</span> <br> <span class="hljs-number">8</span> <span class="hljs-meta">#<span class="hljs-keyword">define</span> UVPT (ULIM - PDMAP) <span class="hljs-comment">// </span></span><br> <span class="hljs-number">9</span> <span class="hljs-meta">#<span class="hljs-keyword">define</span> UPAGES (UVPT - PDMAP) <span class="hljs-comment">// 用户页表</span></span><br><span class="hljs-number">10</span> <span class="hljs-meta">#<span class="hljs-keyword">define</span> UENVS (UPAGES - PDMAP) <span class="hljs-comment">// 用户进程控制块</span></span><br><span class="hljs-number">11</span> <br><span class="hljs-number">12</span> <span class="hljs-meta">#<span class="hljs-keyword">define</span> UTOP UENVS <span class="hljs-comment">// 用户态高地址</span></span><br><span class="hljs-number">13</span> <span class="hljs-meta">#<span class="hljs-keyword">define</span> UXSTACKTOP (UTOP) <span class="hljs-comment">// 用户态异常栈</span></span><br><span class="hljs-number">14</span> <span class="hljs-meta">#<span class="hljs-keyword">define</span> TIMESTACK 0x82000000 <span class="hljs-comment">// 上下文保存栈</span></span><br><span class="hljs-number">15</span> <br><span class="hljs-number">16</span> <span class="hljs-meta">#<span class="hljs-keyword">define</span> USTACKTOP (UTOP - 2*BY2PG) <span class="hljs-comment">// 用户栈</span></span><br><span class="hljs-number">17</span> <span class="hljs-meta">#<span class="hljs-keyword">define</span> UTEXT 0x00400000 <span class="hljs-comment">// 用户代码段</span></span><br></code></pre></td></tr></table></figure><p>最后是一些函数与函数宏：</p><ul><li><code>void bcopy(const void *, void *, size_t)</code>：内存拷贝</li><li><code>void bzero(void *, size_t)</code>：内存清空</li><li><code>assert(x)</code>：支持断言机制。</li><li><code>TRUP(_p)</code>：相当于<code>min(_p, ULIM)</code>，似乎是为了防止用户读写内核段内存。</li></ul><p>在进行内存初始化时，<code>mips_detect_memory()</code>、<code>mips_vm_init()</code>与<code>page_init()</code>被依次调用。<code>mips_detect_memory()</code>用来初始化一些全局变量（此处将物理内存大小设置为64MB，在实际中，内存大小是由硬件得到的，这里只是模拟了检测物理内存大小这个过程）。其余的函数的功能为：</p><ul><li><code>static void *alloc(u_int n, u_int align, int clear)</code>：申请一块内存，返回首地址。</li><li><code>static Pte *boot_pgdir_walk(Pde *pgdir, u_long va, int create)</code>：从页目录项中找出虚拟地址<code>va</code>对应的页表项，若<code>create</code>置位，则不存在时创建。</li><li><code>void boot_map_segment(Pde *pgdir, u_long va, u_long size, u_long pa, int perm)</code>：将虚拟地址<code>va</code>映射到物理地址<code>pa</code>。</li><li><code>void mips_vm_init()</code>：创建一个二级页表。</li><li><code>void page_init(void)</code>：将内存分页并初始化空闲页表。</li><li><code>int page_alloc(struct Page **pp)</code>：分配一页内存并把值赋给pp。</li><li><code>void page_free(struct Page *pp)</code>：释放一页内存。</li><li><code>int pgdir_walk(Pde *pgdir, u_long va, int create, Pte **ppte)</code>：建立起二级页表结构后从页目录中找到va对应页表项的函数。</li><li><code>int page_insert(Pde *pgdir, struct Page *pp, u_long va, u_int perm)</code>：将物理页pp映射到va。</li><li><code>struct Page * page_lookup(Pde *pgdir, u_long va, Pte **ppte)</code>：找到虚拟地址va对应的物理页面。</li><li><code>void page_decref(struct Page *pp)</code>：降低物理页面的引用次数，降到0后释放页面。</li><li><code>void page_remove(Pde *pgdir, u_long va)</code>：释放虚拟地址va对应的页面。</li><li><code>void tlb_invalidate(Pde *pgdir, u_long va)</code>：更新TLB。</li></ul>]]></content>
    
    
    <categories>
      
      <category>OS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>OS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>OS-Lab1</title>
    <link href="/2022/07/17/OS-Lab1/"/>
    <url>/2022/07/17/OS-Lab1/</url>
    
    <content type="html"><![CDATA[<h4 id="一-内核的物理位置"><a href="#一-内核的物理位置" class="headerlink" title="一.内核的物理位置"></a>一.内核的物理位置</h4><p>操作系统最重要的部分是操作系统内核，因为内核需要直接与硬件交互管理各个硬件，从而利用硬件的功能为用户进程提供服务。</p><p>启动操作系统，我们就需要将内核代码在计算机结构上运行起来，一个程序要能够运行，其代码必须能够被 CPU 直接访问，所以不能在磁盘上，因为 CPU 无法直接访问磁盘。</p><blockquote><p>CPU可以直接从硬盘里调用数据，然而这样太慢了，而内存则比硬盘快得多，把用有的东西先放入内存里面，CPU调用起来就快得。</p></blockquote><p>所以不可能将内核代码保存在内存中。所以直观上可以认识到：</p><p>(1) 磁盘不能直接访问</p><p>(2) 内存掉电易失，内核文件有可能放置的位置只能是 CPU 能够直接访问的非易失性存储器——ROM 或 FLASH 中。</p><p>将硬件初始化的相关工作从操作系统中抽出放在bootloader中实现，意味着通过这种方式实现了硬件启动和软件启动的分离。 因此需要存储在非易失性存储器中的硬件启动相关指令不需要很多，能够很容易地保存在ROM或FLASH中。</p><p>bootloader在硬件初始化完后，需要为软件启动（即操作系统内核的功能）做相应的准备， 比如需要将内核镜像文件从存放它的存储器（比如磁盘）中读到RAM中。既然bootloader需要将内核镜像文件加载到内存中， 那么它就能选择使用哪一个内核镜像进行加载，即实现多重开机的功能。使用bootloader后，我们就能够在一个硬件上运行多个操作系统了</p><h4 id="二-Bootloader"><a href="#二-Bootloader" class="headerlink" title="二.Bootloader"></a>二.Bootloader</h4><p>而当内存被初始化，bootloader将后续代码载入到内存中后，位于内存中的代码便能完整地使用C语言的各类功能了。 所以说，内存中的代码拥有了一个正常的C环境。</p><p>在 stage 1 时，需要初始化硬件设备，包括watchdog timer、中断、时钟、内存等。需要注意的一个细节是，此时内存 RAM 尚未初始化完成， 因而 stage 1 直接运行在存放 bootloader 的存储设备上（比如FLASH）。由于当前阶段不能在内存 RAM 中运行，其自身运行会受诸多限制， 比如有些 flash 程序不可写，即使程序可写的 flash 也有存储空间限制。这就是为什么需要stage 2的原因。 stage 1除了初始化基本的硬件设备以外，会为加载stage 2准备RAM空间，然后将stage 2的代码复制到RAM空间，并且设置堆栈，最后跳转到stage 2的入口函数。</p><p>stage 2运行在RAM中，此时有足够的运行环境，所以可以用C语言来实现较为复杂的功能。 这一阶段的工作包括，初始化这一阶段需要使用的硬件设备以及其他功能，然后将内核镜像文件从存储器读到RAM中，并为内核设置启动参数， 最后将CPU指令寄存器的内容设置为内核入口函数的地址，即可将控制权从bootloader转交给操作系统内核。</p><p>gxemul支持加载elf格式内核，所以启动流程被简化为加载内核到内存，之后跳转到内核的入口。启动完毕</p><h4 id="三-编译和链接"><a href="#三-编译和链接" class="headerlink" title="三.编译和链接"></a>三.编译和链接</h4><p>printf的实现是在链接(Link)这一步骤中被插入到最终的可执行文件中的。那么，了解这个细节究竟有什么用呢？ 作为一个库函数，printf被大量的程序所使用。因此，每次都将其编译一遍实在太浪费时间了。printf的实现其实早就被编译成了二进制形式。</p><p>但此时，printf并未链接到程序中，它的状态与我们利用-c选项产生的hello.o相仿，都还处于未链接的状态。而在编译的最后，链接器(Linker)会将所有的目标文件链接在一起，将之前未填写的地址等信息填上，形成最终的可执行文件，这就是链接的过程。</p><p>对于拥有多个c文件的工程来说，编译器会首先将所有的c文件以文件为单位，编译成.o文件。最后再将所有的.o文件以及函数库链接在一起， 形成最终的可执行文件。</p><p>链接器通过哪些信息来链接多个目标文件呢？答案就在于在目标文件（也就是我们通过-c选项生成的.o文件）。 在目标文件中，记录了代码各个段的具体信息。链接器通过这些信息来将目标文件链接到一起。而ELF(Executable and Linkable Format)正是Unix上常用的一种目标文件格式。 其实，不仅仅是目标文件，可执行文件也是使用ELF格式记录的。</p><h4 id="四-va-list、va-start和va-end三个宏的用法。"><a href="#四-va-list、va-start和va-end三个宏的用法。" class="headerlink" title="四.va_list、va_start和va_end三个宏的用法。"></a>四.va_list、va_start和va_end三个宏的用法。</h4><p>1.c语言提供了函数的不定长参数使用，比如 void func(int a, …)。三个省略号，表示了不定长参数。</p><p>注意：c标准规定了，函数必须至少有一个明确定义的参数，因此，省略号前面必须有至少一个参数。</p><p>2.va_list宏定义了一个指针类型，这个指针类型指向参数列表中的参数。</p><p>3.void va_start(va_list ap, last_arg)，修改了用va_list申明的指针，比如ap，使这个指针指向了不定长参数列表省略号前的参数。</p><p>4.type va_arg(va_list, type)，获取参数列表的下一个参数，并以type的类型返回。</p><p>5.void va_end(va_list ap)， 参数列表访问完以后，参数列表指针与其他指针一样，必须收回，否则出现野指针。一般va_start 和va_end配套使用。</p><p>5.函数的参数一般从右至左先后入栈，根据栈的特性，也就是，最左边的参数最先出栈。贴一段代码介绍下va_list、va_start和va_end的使用。</p><p>感兴趣的，可以把函数的整型换成char或者int，参数列表判断条件为NUL，还可以为每个参数指定类型。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdarg.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">functestarg</span><span class="hljs-params">(<span class="hljs-type">int</span>, ...)</span></span>;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span> <span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-built_in">functestarg</span>(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>,<span class="hljs-number">10</span>,<span class="hljs-number">0</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">functestarg</span><span class="hljs-params">(<span class="hljs-type">int</span> a, ...)</span></span><br><span class="hljs-function"></span>&#123;<br>va_list argpointer;<br><span class="hljs-built_in">va_start</span>(argpointer, a);<br><span class="hljs-type">int</span> argument;<br><span class="hljs-type">int</span> count = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">while</span>(<span class="hljs-number">0</span> != (argument = <span class="hljs-built_in">va_arg</span>(argpointer, <span class="hljs-type">int</span>)))<br>&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;parameter%d:%d\n&quot;</span>, ++count, argument);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="五-ELF文件的结构"><a href="#五-ELF文件的结构" class="headerlink" title="五.ELF文件的结构"></a>五.ELF文件的结构</h4><p>ELF文件的解析</p><p>需要输出 ELF ⽂件的所有 section header 的序号和地址信息<br><img src="https://img-blog.csdnimg.cn/d85cbf57560b441b8b203c6a72f8be1b.png#pic_center" alt="在这里插入图片描述"></p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs awk">typedef struct &#123;<br>    unsigned char   e_ident[EI_NIDENT];     <span class="hljs-regexp">/* Magic number and other info */</span><br>    <span class="hljs-regexp">//</span> 存放魔数以及其他信息<br>    Elf32_Half      e_type;                 <span class="hljs-regexp">/* Object file type */</span><br>    <span class="hljs-regexp">//</span> 文件类型 <br>    Elf32_Half      e_machine;              <span class="hljs-regexp">/* Architecture */</span><br>    <span class="hljs-regexp">//</span> 机器架构<br>    Elf32_Word      e_version;              <span class="hljs-regexp">/* Object file version */</span><br>    <span class="hljs-regexp">//</span> 文件版本<br>    Elf32_Addr      e_entry;                <span class="hljs-regexp">/* Entry point virtual address */</span><br>    <span class="hljs-regexp">//</span> 入口点的虚拟地址<br>    Elf32_Off       e_phoff;                <span class="hljs-regexp">/* Program header table file offset */</span><br>    <span class="hljs-regexp">//</span> 程序头表所在处与此文件头的偏移<br>    Elf32_Off       e_shoff;                <span class="hljs-regexp">/* Section header table file offset */</span><br>    <span class="hljs-regexp">//</span> 段头表所在处与此文件头的偏移<br>    Elf32_Word      e_flags;                <span class="hljs-regexp">/* Processor-specific flags */</span><br>    <span class="hljs-regexp">//</span> 针对处理器的标记<br>    Elf32_Half      e_ehsize;               <span class="hljs-regexp">/* ELF header size in bytes */</span><br>    <span class="hljs-regexp">//</span> ELF文件头的大小（单位为字节）<br>    Elf32_Half      e_phentsize;            <span class="hljs-regexp">/* Program header table entry size */</span><br>    <span class="hljs-regexp">//</span> 程序头表入口大小<br>    Elf32_Half      e_phnum;                <span class="hljs-regexp">/* Program header table entry count */</span><br>    <span class="hljs-regexp">//</span> 程序头表入口数<br>    Elf32_Half      e_shentsize;            <span class="hljs-regexp">/* Section header table entry size */</span><br>    <span class="hljs-regexp">//</span> 段头表入口大小<br>    Elf32_Half      e_shnum;                <span class="hljs-regexp">/* Section header table entry count */</span><br>    <span class="hljs-regexp">//</span> 段头表入口数<br>    Elf32_Half      e_shstrndx;             <span class="hljs-regexp">/* Section header string table index */</span><br>    <span class="hljs-regexp">//</span> 段头字符串编号<br>&#125; Elf32_Ehdr;<br></code></pre></td></tr></table></figure><h4 id="六-lp-Print-函数流程图"><a href="#六-lp-Print-函数流程图" class="headerlink" title="六.lp_Print()函数流程图"></a>六.lp_Print()函数流程图</h4><p><img src="https://img-blog.csdnimg.cn/018a774203e24b81b0d1cbe2052970c4.png#pic_center" alt="在这里插入图片描述"></p>]]></content>
    
    
    <categories>
      
      <category>OS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>OS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>OS-Lab0</title>
    <link href="/2022/07/16/OS-Lab0/"/>
    <url>/2022/07/16/OS-Lab0/</url>
    
    <content type="html"><![CDATA[<h3 id="一-GIT-的常规操作"><a href="#一-GIT-的常规操作" class="headerlink" title="一.GIT 的常规操作"></a>一.GIT 的常规操作</h3><p>常规操作也是我自己平时常用的几个命令, 学自于 pro git 这本书中</p><h4 id="一-git-基本使用"><a href="#一-git-基本使用" class="headerlink" title="一.git 基本使用"></a>一.git 基本使用</h4><ol><li><p>clone现有仓库</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git <span class="hljs-built_in">clone</span> URL  (URL支持git，ssh，http，https等各种协议)<br></code></pre></td></tr></table></figure></li><li><p>git中文件的各个状态</p><ul><li>unstaged - git仓库中没有此文件的相关记录</li><li>modified - git仓库中有这个文件的记录，并且此文件当前有改动</li><li>staged - 追加,删除或修改的文件被暂时保存，这些追加,删除和修改并没有提交到git仓库</li><li>commited - 追加或修改的文件被提交到本地git仓库（git仓库中大部分都是这种文件，所以git status不显示这些文件）</li></ul></li><li><p>查看git仓库中各文件状态</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs lua">git <span class="hljs-built_in">status</span><br></code></pre></td></tr></table></figure></li><li><p>初始化一个仓库</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs csharp">git <span class="hljs-keyword">init</span><br></code></pre></td></tr></table></figure><p>在当前文件夹下生成.git目录，完成初始化，此时此文件夹下的所有文件处于unstaged状态</p></li><li><p>追加文件</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs x86asm">git <span class="hljs-keyword">add</span> <span class="hljs-keyword">test</span><span class="hljs-number">.</span>c<br></code></pre></td></tr></table></figure><p>test.c的文件变为staged状态，其他文件还是unstaged状态</p><p>5.1 追加文件的结果1 - 恢复为原先状态（变为unstaged）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git <span class="hljs-built_in">rm</span> --cache test.c<br></code></pre></td></tr></table></figure><p>5.2 追加文件的结果2 - 提交到git仓库（变为commited）</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">git <span class="hljs-keyword">commit</span> <span class="hljs-operator">-</span>m &quot;my message&quot;<br></code></pre></td></tr></table></figure></li><li><p>修改文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;aaa&quot;</span>  &gt;&gt; test.c<br></code></pre></td></tr></table></figure><p>test.c的状态变为modified</p><p>6.1 修改文件的结果1</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs x86asm">git <span class="hljs-keyword">add</span> <span class="hljs-keyword">test</span><span class="hljs-number">.</span>c  (暂时保存修改的内容，即变为staged）<br></code></pre></td></tr></table></figure><p>下面有2条路可以选择：<br>6.1.1 取消刚才的暂时保存</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs perl">git <span class="hljs-keyword">reset</span> test.c  （状态变回modified）<br></code></pre></td></tr></table></figure><p>6.2.2 将暂存的修改提交到git仓库</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">git <span class="hljs-keyword">commit</span> <span class="hljs-operator">-</span>m &quot;my message&quot;<br></code></pre></td></tr></table></figure><p>6.2 修改文件的结果2</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs x86asm">git checkout <span class="hljs-keyword">test</span><span class="hljs-number">.</span>c  （将<span class="hljs-keyword">test</span><span class="hljs-number">.</span>c恢复为git仓库中的最新版本，即变为commited状态，<span class="hljs-keyword">test</span><span class="hljs-number">.</span>c的内容和<span class="hljs-number">5.2</span>节一样）<br></code></pre></td></tr></table></figure></li><li><p>删除文件<br>7.1 从git仓库和磁盘上删除文件</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs x86asm">git rm <span class="hljs-keyword">test</span><span class="hljs-number">.</span>c  （当前目录中删除了<span class="hljs-keyword">test</span><span class="hljs-number">.</span>c，在git仓库中暂时删除了<span class="hljs-keyword">test</span><span class="hljs-number">.</span>c，相当于staged状态）<br></code></pre></td></tr></table></figure><p>7.1.1 从git仓库中删除test.c</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">git <span class="hljs-keyword">commit</span> <span class="hljs-operator">-</span>m &quot;my message&quot;  (git仓库以后不再维护test.c)<br></code></pre></td></tr></table></figure><p>7.1.2 删错了，恢复刚才的操作</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs x86asm">git reset HEAD <span class="hljs-keyword">test</span><span class="hljs-number">.</span>c  (恢复到删除前的状态，当前目录中已删除的<span class="hljs-keyword">test</span><span class="hljs-number">.</span>c也恢复了，<span class="hljs-keyword">test</span><span class="hljs-number">.</span>c仍文commited状态)<br></code></pre></td></tr></table></figure><p>7.2 仅从git仓库中删除文件</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs x86asm">git rm --cache <span class="hljs-keyword">test</span><span class="hljs-number">.</span>c （当前目录中没有删除了<span class="hljs-keyword">test</span><span class="hljs-number">.</span>c，仅在git仓库中暂时删除了<span class="hljs-keyword">test</span><span class="hljs-number">.</span>c，相当于staged状态）<br></code></pre></td></tr></table></figure><p>7.2.1 从git仓库中删除test.c</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs x86asm">git commit -m <span class="hljs-string">&quot;my message&quot;</span>  (git仓库以后不再维护<span class="hljs-keyword">test</span><span class="hljs-number">.</span>c，但是当前目录中仍然有<span class="hljs-keyword">test</span><span class="hljs-number">.</span>c)<br></code></pre></td></tr></table></figure><p>7.2.2 删错了，恢复刚才的操作</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs perl">git <span class="hljs-keyword">reset</span> HEAD test.c  （和<span class="hljs-number">7.1</span>.<span class="hljs-number">2</span>一样）<br></code></pre></td></tr></table></figure><p>7.3 误删除后的恢复<br>如果删除了一个文件，并且commit之后发现删错了。也可以恢复，</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">git <span class="hljs-built_in">log</span>  （查看各次的提交信息）<br>git checkout commit号  （恢复到未删除前的commint号，此时删除的文件也恢复到磁盘上了）<br>git checkout master  (备份好删除的文件后，再回到最新状态)<br></code></pre></td></tr></table></figure></li></ol><h4 id="二-git-远程仓库"><a href="#二-git-远程仓库" class="headerlink" title="二.git 远程仓库"></a>二.git 远程仓库</h4><ol><li><p>查看远程仓库<br>1.1 简单查看-所有仓库</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">git <span class="hljs-title function_">remote</span> <span class="hljs-params">(只能查看远程仓库的名字)</span><br></code></pre></td></tr></table></figure><p>1.2 查看更多内容-所有仓库</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs scss">git remote -v (远程仓库的名字及git地址)<br></code></pre></td></tr></table></figure><p>1.3 查看单个仓库的信息</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">git remote show <span class="hljs-selector-attr">[remote-name]</span><br></code></pre></td></tr></table></figure></li><li><p>新建远程仓库</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs csharp">git remote <span class="hljs-keyword">add</span> [shortname] [url]<br>ex. git remote <span class="hljs-keyword">add</span> mc git:<span class="hljs-comment">//www.host.com/gitdir/mycode.git</span><br></code></pre></td></tr></table></figure></li><li><p>修改远程仓库</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">git remote rename <span class="hljs-selector-attr">[oldnanme]</span> <span class="hljs-selector-attr">[newname]</span><br></code></pre></td></tr></table></figure></li><li><p>删除远程仓库</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git remote <span class="hljs-built_in">rm</span> [remote-name]<br></code></pre></td></tr></table></figure></li><li><p>远程仓库的数据<br>5.1 获取数据</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs scss">git fetch <span class="hljs-selector-attr">[remote-name]</span> (获取仓库的所有更新，但是不自动合并当前分支)<br>git pull (获取仓库的所有更新, 并且自动合并到当前分支)<br></code></pre></td></tr></table></figure><p>5.2 上传数据</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs css">git push <span class="hljs-selector-attr">[remote-name]</span> <span class="hljs-selector-attr">[branch-name]</span><br>ex. git push origin master<br></code></pre></td></tr></table></figure></li></ol><h4 id="三-git-分支"><a href="#三-git-分支" class="headerlink" title="三.git 分支"></a>三.git 分支</h4><ol><li><p>查看和切换分支</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs scss">git branch (查看所有的分支及当前处于哪个分支)<br>git branch -v (查看所有的分支的详细信息)<br>git branch <span class="hljs-attr">--merged</span> (查看已经合并的分支)<br>git branch <span class="hljs-attr">--no-merged</span> (查看还没合并的分支)<br>git checkout <span class="hljs-selector-attr">[branch-name]</span> (切换到某个分支)<br></code></pre></td></tr></table></figure></li><li><p>新建分支</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">git <span class="hljs-keyword">branch </span>[<span class="hljs-keyword">branch-name] </span> (新建一个分支)<br>git <span class="hljs-keyword">branch </span>-<span class="hljs-keyword">b </span>[<span class="hljs-keyword">branch-name] </span>(新建一个分支并切换到这个分支上)<br></code></pre></td></tr></table></figure></li><li><p>合并分支</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">git merge [<span class="hljs-keyword">branch-name]</span><br><span class="hljs-keyword"></span>ex. 将分支<span class="hljs-keyword">btest合并到主分支master</span><br><span class="hljs-keyword"></span>git checkout master<br>git merge <span class="hljs-keyword">btest</span><br></code></pre></td></tr></table></figure><p>merge时有冲突的文件会列出来，需要手动合并</p><p>将冲突手动解决后，再次用 git status来查看是否还有 unmerged的文件。<br>如果没有冲突的文件，就可以 git commit 来提交这次合并了。</p></li><li><p>删除分支</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">git <span class="hljs-keyword">branch </span>-d [<span class="hljs-keyword">branch-name]</span><br><span class="hljs-keyword"></span>或者 git <span class="hljs-keyword">branch </span>-D [<span class="hljs-keyword">branch-name] </span>(强制删除某个还未合并的分支)<br></code></pre></td></tr></table></figure></li><li><p>远程分支相关<br>5.1 新建远程分支</p><ol><li>git checkout [local_branch] (首先进入想要上传的分支)</li><li>git remote add [remote_repo] [remote_branch]<br>(这里的[remote_branch]是远程分支的名字，一般和[local_branch]同名,<br>[remote_repo]是远程仓库的名字)</li></ol><p>5.2 向远程分支推送数据</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">git push <span class="hljs-selector-attr">[remote_repo]</span> <span class="hljs-selector-attr">[remote_branch]</span><br></code></pre></td></tr></table></figure><p>5.3 删除远程分支</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-selector-tag">git</span> <span class="hljs-selector-tag">push</span> <span class="hljs-selector-attr">[remote_repo]</span> :<span class="hljs-selector-attr">[remote_branch]</span> (注意远程分支前有个<span class="hljs-string">&quot;:&quot;</span>)<br></code></pre></td></tr></table></figure></li></ol><h3 id="二-shell-变量的定义，赋值，运算"><a href="#二-shell-变量的定义，赋值，运算" class="headerlink" title="二.shell 变量的定义，赋值，运算"></a>二.shell 变量的定义，赋值，运算</h3><h4 id="一、变量类型"><a href="#一、变量类型" class="headerlink" title="一、变量类型"></a>一、变量类型</h4><h5 id="1-1、自定义变量"><a href="#1-1、自定义变量" class="headerlink" title="1.1、自定义变量"></a>1.1、自定义变量</h5><p>1.定义变量</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs csharp">不能使用纯数字命名，不能使用横杠命名<br>变量名=变量值<br>[<span class="hljs-meta">root@localhost ~</span>]<span class="hljs-meta"># name=erha   </span><br></code></pre></td></tr></table></figure><p>2.引用变量</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ruby"><span class="hljs-variable">$变</span>量名 或者 <span class="hljs-variable">$&#123;</span>变量量名&#125;<br></code></pre></td></tr></table></figure><p>3.查看变量值</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs ruby">echo<span class="hljs-variable">$变</span>量量名<br>[root<span class="hljs-variable">@localhost</span> ~]<span class="hljs-comment"># echo $name</span><br>erha<br></code></pre></td></tr></table></figure><p>4.取消变量</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs csharp">[<span class="hljs-meta">root@localhost ~</span>]<span class="hljs-meta"># unset  name</span><br>[<span class="hljs-meta">root@localhost ~</span>]<span class="hljs-meta"># echo $name</span><br></code></pre></td></tr></table></figure><p>5.作⽤用范围<br>仅在当前shell中有效</p><h5 id="1-2、系统环境变量"><a href="#1-2、系统环境变量" class="headerlink" title="1.2、系统环境变量"></a>1.2、系统环境变量</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$</span><span class="language-bash">1<span class="hljs-variable">$2</span><span class="hljs-variable">$3</span><span class="hljs-variable">$4</span><span class="hljs-variable">$5</span><span class="hljs-variable">$6</span> ...</span><br><span class="hljs-meta prompt_">#</span><span class="language-bash"><span class="hljs-variable">$1</span>代表向脚本内传递的第一个位置参数，<span class="hljs-variable">$2</span>代表第二个，依次类推。</span><br></code></pre></td></tr></table></figure><h5 id="1-3、预定义变量"><a href="#1-3、预定义变量" class="headerlink" title="1.3、预定义变量"></a>1.3、预定义变量</h5><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs powershell"><span class="hljs-variable">$0</span>脚本⽂文件名 <br><span class="hljs-variable">$</span>* <span class="hljs-variable">$</span><span class="hljs-selector-tag">@</span>所有的参数 <br><span class="hljs-variable">$</span><span class="hljs-comment">#参数的个数</span><br><span class="hljs-variable">$</span><span class="hljs-variable">$</span>当前进程的 PID <br><span class="hljs-variable">$</span>!上一个后台进程的 PID <br><span class="hljs-variable">$</span>?上一个命令的返回值 <span class="hljs-number">0</span> 表示成功<br></code></pre></td></tr></table></figure><p> <strong>小脚本</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs bash">[root@localhost ~]<span class="hljs-comment"># cat var.sh </span><br><span class="hljs-comment">#!/bin/bash</span><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;第一个参数：<span class="hljs-variable">$1</span>&quot;</span><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;第二个参数：<span class="hljs-variable">$2</span>&quot;</span><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;第三个参数：<span class="hljs-variable">$3</span>&quot;</span><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;第四个参数：<span class="hljs-variable">$4</span>&quot;</span><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;所有参数为：$*&quot;</span><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;参数个数为：<span class="hljs-variable">$#</span>&quot;</span><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;当前进程ID为：$$&quot;</span><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;上一个进程ID为：$!&quot;</span><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;当前脚本名称为：<span class="hljs-variable">$0</span>&quot;</span><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;当前脚本执行结果：$?&quot;</span><br></code></pre></td></tr></table></figure><p><strong>执行如下</strong></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs csharp">[<span class="hljs-meta">root@localhost ~</span>]<span class="hljs-meta"># sh var.sh 1 2 3 4 5 </span><br>第一个参数：<span class="hljs-number">1</span><br>第二个参数：<span class="hljs-number">2</span><br>第三个参数：<span class="hljs-number">3</span><br>第四个参数：<span class="hljs-number">4</span><br>所有参数为：<span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">4</span> <span class="hljs-number">5</span><br>参数个数为：<span class="hljs-number">5</span><br>当前进程ID为：<span class="hljs-number">8875</span><br>上一个进程ID为：<br>当前脚本名称为：<span class="hljs-keyword">var</span>.sh<br>当前脚本执行结果：<span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><h4 id="二、变量赋值"><a href="#二、变量赋值" class="headerlink" title="二、变量赋值"></a>二、变量赋值</h4><h5 id="2-1、直接赋值"><a href="#2-1、直接赋值" class="headerlink" title="2.1、直接赋值"></a>2.1、直接赋值</h5><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs csharp">[<span class="hljs-meta">root@localhost ~</span>]<span class="hljs-meta"># name=huahua</span><br><span class="hljs-meta">#注意等号两边不能有空格</span><br></code></pre></td></tr></table></figure><h5 id="2-2、从键盘读入"><a href="#2-2、从键盘读入" class="headerlink" title="2.2、从键盘读入"></a>2.2、从键盘读入</h5><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs diff">[root@localhost ~]# read 参数 变量名<br>可选参数<br><span class="hljs-deletion">-p :提示信息</span><br><span class="hljs-deletion">-t :等待时间</span><br><span class="hljs-deletion">-n :读入字符数</span><br></code></pre></td></tr></table></figure><p><strong>小脚本</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs bash">解压文件到指定位置<br>[root@localhost ~]<span class="hljs-comment"># cat tr.sh </span><br><span class="hljs-comment">#!/bin/bash</span><br><span class="hljs-built_in">read</span> -p <span class="hljs-string">&quot;请输入要解压的文件，及解压目录：&quot;</span> src dst<br><span class="hljs-keyword">if</span> [ -e <span class="hljs-variable">$src</span> ];<span class="hljs-keyword">then</span><br>tar -zxvf <span class="hljs-variable">$src</span> -C <span class="hljs-variable">$dst</span><br><span class="hljs-keyword">else</span><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;没有该文件...&quot;</span><br><span class="hljs-keyword">fi</span><br></code></pre></td></tr></table></figure><h5 id="2-3、强引用与弱引用"><a href="#2-3、强引用与弱引用" class="headerlink" title="2.3、强引用与弱引用"></a>2.3、强引用与弱引用</h5><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-string">&quot;&quot;</span> :弱引用，特殊字符依旧有特定含义。<br>[root@localhost ~]<span class="hljs-comment"># age=18</span><br>[root@localhost ~]<span class="hljs-comment"># echo &quot;$age&quot;</span><br><span class="hljs-number">18</span><br><br><span class="hljs-string">&#x27;&#x27;</span> :强引用，所有字符被当作普通字符处理。<br>[root@localhost ~]<span class="hljs-comment"># echo &#x27;$name&#x27;</span><br>$name<br></code></pre></td></tr></table></figure><h5 id="2-4、命令执行结果引用"><a href="#2-4、命令执行结果引用" class="headerlink" title="2.4、命令执行结果引用"></a>2.4、命令执行结果引用</h5><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs ruby"><span class="hljs-string">``</span> <span class="hljs-symbol">:</span>反引号，不过容易与引号混淆。<br>[root<span class="hljs-variable">@localhost</span> ~]<span class="hljs-comment"># t1=`date +%F`</span><br>[root<span class="hljs-variable">@localhost</span> ~]<span class="hljs-comment"># echo $t1</span><br><span class="hljs-number">2020</span>-<span class="hljs-number">01</span>-<span class="hljs-number">20</span><br><br><span class="hljs-variable">$(</span>)<span class="hljs-symbol">:</span><span class="hljs-variable">$加</span>小括号，不容易混淆，一般使用这种方式较多<br>[root<span class="hljs-variable">@localhost</span> ~]<span class="hljs-comment"># t2=$(date +%F)</span><br>[root<span class="hljs-variable">@localhost</span> ~]<span class="hljs-comment"># echo $t2</span><br><span class="hljs-number">2020</span>-<span class="hljs-number">01</span>-<span class="hljs-number">20</span><br></code></pre></td></tr></table></figure><h4 id="三、数学运算"><a href="#三、数学运算" class="headerlink" title="三、数学运算"></a>三、数学运算</h4><h5 id="3-1、整数运算（expr）"><a href="#3-1、整数运算（expr）" class="headerlink" title="3.1、整数运算（expr）"></a>3.1、整数运算（expr）</h5><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs csharp">加 减 乘 除 取余<br>+  -  \* /   % <br><br>[<span class="hljs-meta">root@localhost ~</span>]<span class="hljs-meta"># expr 1 + 1</span><br><span class="hljs-number">2</span><br>[<span class="hljs-meta">root@localhost ~</span>]<span class="hljs-meta"># expr 1 - 1</span><br><span class="hljs-number">0</span><br>[<span class="hljs-meta">root@localhost ~</span>]<span class="hljs-meta"># expr 1 \* 1</span><br><span class="hljs-number">1</span><br>[<span class="hljs-meta">root@localhost ~</span>]<span class="hljs-meta"># expr 1 / 1</span><br><span class="hljs-number">1</span><br>[<span class="hljs-meta">root@localhost ~</span>]<span class="hljs-meta"># expr 1 % 1</span><br><span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><h5 id="3-2、整数运算（-）"><a href="#3-2、整数运算（-）" class="headerlink" title="3.2、整数运算（$(())）"></a>3.2、整数运算（$(())）</h5><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs csharp">加 减 乘 除 取余 幂运算<br>+  -  * /   %   **<br><br>[<span class="hljs-meta">root@localhost ~</span>]<span class="hljs-meta"># echo $((1 + 2))</span><br><span class="hljs-number">3</span><br>[<span class="hljs-meta">root@localhost ~</span>]<span class="hljs-meta"># echo $((1 - 2))</span><br><span class="hljs-number">-1</span><br>[<span class="hljs-meta">root@localhost ~</span>]<span class="hljs-meta"># echo $((1 * 2))</span><br><span class="hljs-number">2</span><br>[<span class="hljs-meta">root@localhost ~</span>]<span class="hljs-meta"># echo $((1 / 2))</span><br><span class="hljs-number">0</span><br>[<span class="hljs-meta">root@localhost ~</span>]<span class="hljs-meta"># echo $((1 % 2))</span><br><span class="hljs-number">1</span><br>[<span class="hljs-meta">root@localhost ~</span>]<span class="hljs-meta"># echo $((1 ** 2))</span><br><span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><h5 id="3-3、整数运算（-）"><a href="#3-3、整数运算（-）" class="headerlink" title="3.3、整数运算（$[]）"></a>3.3、整数运算（$[]）</h5><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs ruby">与 <span class="hljs-variable">$(</span>())类似<br>[root<span class="hljs-variable">@localhost</span> ~]<span class="hljs-comment"># echo $[1+2]</span><br><span class="hljs-number">3</span><br>[root<span class="hljs-variable">@localhost</span> ~]<span class="hljs-comment"># echo $[1-2]</span><br>-<span class="hljs-number">1</span><br>[root<span class="hljs-variable">@localhost</span> ~]<span class="hljs-comment"># echo $[1*2]</span><br><span class="hljs-number">2</span><br>[root<span class="hljs-variable">@localhost</span> ~]<span class="hljs-comment"># echo $[1/2]</span><br><span class="hljs-number">0</span><br>[root<span class="hljs-variable">@localhost</span> ~]<span class="hljs-comment"># echo $[1**2]</span><br><span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><h5 id="3-4、整数运算（let）"><a href="#3-4、整数运算（let）" class="headerlink" title="3.4、整数运算（let）"></a>3.4、整数运算（let）</h5><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs csharp">加 减 乘 除 取余 幂运算<br>+  -  * /   %   **<br><br>[<span class="hljs-meta">root@localhost ~</span>]<span class="hljs-meta"># let nu=2**4</span><br>[<span class="hljs-meta">root@localhost ~</span>]<span class="hljs-meta"># echo $nu</span><br><span class="hljs-number">16</span><br></code></pre></td></tr></table></figure><h5 id="3-5、小数运算"><a href="#3-5、小数运算" class="headerlink" title="3.5、小数运算"></a>3.5、小数运算</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp">可以使用bc命令<br>[root@localhost ~]<span class="hljs-meta"># echo <span class="hljs-string">&quot;1.1&quot;</span>+<span class="hljs-string">&quot;2.3&quot;</span>|bc</span><br><span class="hljs-number">3.4</span><br></code></pre></td></tr></table></figure><h3 id="三-vim实用笔记"><a href="#三-vim实用笔记" class="headerlink" title="三.vim实用笔记"></a>三.vim实用笔记</h3><h4 id="一、vim实用基础配置"><a href="#一、vim实用基础配置" class="headerlink" title="一、vim实用基础配置"></a>一、vim实用基础配置</h4><p>配置出了可以通过命令实现外，也可以将set内容添加到vim配置文件&#x2F;etc&#x2F;vim&#x2F;vimrc中，当然，添加到vimrc就不需要在set前面加”:”了。</p><p><strong>1、设置显示行号可以使用命令</strong> ”:set number”</p><p><strong>2、文件自动保存</strong>，”:set autowrite”</p><p><strong>3、实用配置列表：</strong></p><p>因为这些配置实在太多，就不一一列举了，总结和摘录了一个常用的配置表，可以直接复制粘贴到vimrc配置文件中（“符号后面的都会被识别为注释）：</p><blockquote><p>syntax on “ 自动语法高亮，其实vim7.3版本语法默认是高亮的</p><p>colorscheme evening” 一种好看的配色方案</p><p>set shiftwidth&#x3D;4 “ 设定 &lt;&lt; 和 &gt;&gt; 命令移动时的宽度为 4个字符</p><p>set tabstop&#x3D;4 “ 设定 tab 长度为 4个字符</p><p>filetype plugin indent on “ 开启插件</p><p>set ignorecase “ 搜索时忽略大小写</p><p>set incsearch “ 即刻显示当前输入的搜索结果</p><p>set hlsearch “ 高亮搜索结果</p><p>set noerrorbells “ 关闭错误信息响铃</p><p>set autochdir “ 自动切换当前目录为当前文件所在目录</p><p>filetype indent on “自动缩进</p><p>set autoindent shiftwidth&#x3D;n “修正缩进，ctrl+T或ctrl+D或者&gt;&gt;、&lt;&lt;均对应n个字符缩进</p></blockquote><h4 id="二、vim查找功能"><a href="#二、vim查找功能" class="headerlink" title="二、vim查找功能"></a>二、vim查找功能</h4><p><strong>1、最基础的查找：</strong></p><p><Esc>状态，直接按 &#x2F; 键。然后输入要查找的内容。下一个查找结果按n。如果查找的内容带有符号‘.*[]^%&#x2F;n?~$ ，则添加转义字符方式“ \ ”再进行查找即可。</p><p><strong>2、精确查找：</strong></p><p>比如说我要确切地找到一个单词“top”。则按 &#x2F; 键，然后输入如下内容：</p><p>&#x2F;&lt;top&gt;</p><p>其实它的意思是，搜索以top开头，并以top结尾的单词。所以如果我们希望查找以top开头的所有单词：</p><p>&#x2F;&lt;top</p><p>以top结尾的单词：</p><p>&#x2F;top&gt;</p><p><strong>3、跨文件查找字符：</strong></p><p>比如，在进行某个文件的编辑时，我希望找到当前工作目录中所有含有”include”字符串的cpp文件：</p><blockquote><p>“:grep include *.cpp”</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>OS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>OS</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
